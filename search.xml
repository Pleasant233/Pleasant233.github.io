<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客搭建感想</title>
      <link href="/2024/10/16/hello-template/"/>
      <url>/2024/10/16/hello-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><ul><li>本地化部署流程</li><li>线上发布流程</li></ul><hr><h2 id="本地化部署"><a href="#本地化部署" class="headerlink" title="本地化部署"></a>本地化部署</h2><ul><li>前期准备<ul><li>首先，本地化部署需要提前安装好两个东西，<br>可参考hexo框架官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>需要下载node.js，同时下载npm，也就是版本管理器，这些可以帮助我们管理博客版本内容。<ul><li>node.js 官网：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>你可以直接在官网复制它的代码并且打开本地自带的Windows命令窗口：powershell，粘贴你复制的代码</li><li>等待安装完成就可以了</li></ul></li><li>下载git，git主要作用是建立起云端和本地之间的桥梁，让我们能够从云端拉取数据。<ul><li>同样可以在官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a> </li><li>git安装相对简单，你可以直接全部选择next就自动安装完成了，很无脑！</li></ul></li><li>在安装完成后，本地的环境就基本上搭建完成了。</li></ul></li></ul><h2 id="线上发布："><a href="#线上发布：" class="headerlink" title="线上发布："></a>线上发布：</h2><ul><li>首先访问：<a href="https://github.com/mmdjiji/hexo-template">https://github.com/mmdjiji/hexo-template</a> 获取该库的代码，并且由此新建一个库，<br>详细教程可参考：<a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&vd_source=a506bd54314456e886d3818e488bb1c8">https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&amp;vd_source=a506bd54314456e886d3818e488bb1c8</a></li><li>断点发生在使用spacecode编辑处，因为该方法是完全基于云端的部署，所以完全依赖虚拟机的网速<br>然而经过多方验证，虚拟机网速堪忧，因此在此我们选择在本地部署！</li></ul><h2 id="独家揭秘！"><a href="#独家揭秘！" class="headerlink" title="独家揭秘！"></a>独家揭秘！</h2><ul><li>本地化部署就是本教程独一无二之处，大部分教程都会将两者割裂，但本教程才是最无脑的过程，<br>前文我们已经提到，云端部署十分缓慢，那有没有办法加快这个速度呢？</li><li>答案当然是有的！我们可以利用githubdesktop更快捷的进行上传与下载，避免云端网速的问题！</li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><ul><li>首先，下载githubdesktop，这个在你的库里local选项就能下载，为了方便起见，本文还是给大家配图</li><li>配图使用PicGo，同样也会给大家介绍，并且介绍obsidian中的PicGo联动小功能！  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20111142.png"></li><li>下载安装完成后，我们就可以将线上的库克隆到本地了，这里各位自行摸索即可，很简单，就不再赘述</li></ul><h3 id="在bush窗口中完成部署"><a href="#在bush窗口中完成部署" class="headerlink" title="在bush窗口中完成部署"></a>在bush窗口中完成部署</h3><ul><li>克隆完成后，我们需要再本地进行编辑，首先，找到克隆库所在本地文件夹，在文件夹中右键</li><li>打开选项栏，选择open git bush here</li><li>然后我们就嫩得到一个这样的窗口，很好，你已经几乎要完成它了！  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912111820.png"></li><li>随后，我们需要先安装hexo框架，在对话框中输入：<br>   <code>$ npm install -g hexo-cli </code></li><li>等待安装完成，在这里你可以加速这个过程，可将上述代码替换为：<br>   <code>$ cnpm install -g hexo-cli</code></li><li>这是一个国内镜像，但前提是你需要下载它，你可以通过powershell输入：<br>   <code>npm install -g cnpm --registry=https://registry.npmmirror.com </code><br>   下载完成后，之后的所有需要npm的代码就都可以用cnpm替换了</li><li>之后我们继续键入<code>cnpm install</code>来安装依赖，请确保你进行了上一步！</li><li>在此之后，我们就完成了全部部署，你可以输入<code>hexo g</code>来检测部署结果</li><li>注意！按此方式部署的hexo是局部的，所以需要输入<code>npx+hexo...</code>命令！注意区分</li><li>若如图所示，则说明部署完成：  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912112800.png"></li><li>请注意，上图中，butterfly字样是主题，若未安装是不会显示的，这无伤大雅。</li></ul><h3 id="配合github上传"><a href="#配合github上传" class="headerlink" title="配合github上传"></a>配合github上传</h3><ul><li>第一阶段我们的githubdesktop就排上用场了，你只需要在面板中点击commit，</li><li>随后点击push origin 上传到云端即可了，返回到github库主页面，点击setting，查看page页面更新消息，你可以按F5刷新页面，不过多久，一个网站就搭建好了，并且你可以在本地完全控制它！</li></ul><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>这是我的第一篇真正的博客，讲解了如何优雅而简便的搭建一个你的博客，接下来我会更新后续的内容，包括技术美术全部相关学习心得，笔记，随笔，图形学系列课程，希望能共同学习交流，那么最后一步！</li><li>push to origin！</li></ul><hr><h1 id="参考链接与项目"><a href="#参考链接与项目" class="headerlink" title="参考链接与项目"></a>参考链接与项目</h1><ul><li>1.hexo官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>2.b站up主：方欲遣兵北逐胡的视频：【基于Hexo搭建本地博客并部署到云服务器教程】 <a href="https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>3.b站up主：吉吉学长的视频：【【Hexo | 03】创建属于你的追番列表】 <a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>全部为开源项目，不承担任何责任！</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——2</title>
      <link href="/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
      <url>/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h1><ul><li>长宽必须是2的幂数，并且上线不超过8192，当然也可以导入不符合该标准的纹理，但这样Ue就无法为我们生成MIPMAP了。</li><li>简单来说，MIPMAP就是为我们生成一系列的图片，让我们在场景中根据距离远近智能调节纹理质量，以此来降低性能开销的一种手段，同样的手段为LOD，只不过后者是只能调节物体面数的，在UE中更为强大的Nanite系统将同时为我们做到以上两点。</li></ul><h1 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h1><ul><li><p>Ue支持很多纹理格式，例如psd，tga等，这两者也是最常用的无损格式之一</p></li><li><p>Ue支持一种叫做3Dtexture的贴图，它可以通过直接在内容窗口中创建得到，下面是它的原理图：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240929200955.png" alt="image.png"></p></li><li><p>一般用于特效制作</p></li><li><p>虚拟纹理：虚拟纹理是Ue所具有的一种动态加载纹理的功能，同样可以减少性能开销，它可以智能加载所需要的贴图，不加载看不见的贴图，从而减少开销。</p></li><li><p>虚幻同样支持由SD导入纹理材质球</p></li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>默认导入状态下，纹理会被压缩为DXTC或BC格式，而B8G8R8A8或G8表示未压缩，HDR格式纹理的FloatRGBA也不会压缩纹理。</li><li>Ue具备一种特有的纹理压缩模式，称为Oodle，是一种高效快捷的纹理编码，它有多层线性级别，通过控制<code>Lambda</code>值来调节压缩级别，一般<code>Lambda</code> &#x3D; 1为最优秀</li><li>详细可以参考Ue官方文档：</li><li><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/">https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/</a></li><li>请注意在移动端中暂时无法使用该选项</li></ul><h1 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h1><ul><li>创建材质实例可以帮助我们快速的调整场景中已有材质物体的材质属性，类似于类的对象这一概念</li><li>我们可以通过将纹理贴图等节点暴露为参数，从而在实例化的材质中自定义调节，它不会影响我们父材质的效果</li><li>SwitchParam节点可以帮助我们设置默认参数与自定义参数，如果打开实例节点中的对应选项就可以调节输入，并且取代我们的默认参数值，关闭则可恢复默认</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——1</title>
      <link href="/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/"/>
      <url>/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="材质编辑器"><a href="#材质编辑器" class="headerlink" title="材质编辑器"></a>材质编辑器</h1><ul><li>材质编辑界面主要由几部分组成，分别是材质图标，节点表，材质属性表，和各类操作面板：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220416.png" alt="image.png"></li><li>类似于Blender的原理化BSDF节点，一开始就会存在的是右侧的输出节点</li><li>我们需要通过连线的方式，将节点连接到对应的输出端口上</li><li>在操作完成后，我们需要进行保存和应用，这些操作全部在上方的材质编辑器的操作面板上完成</li></ul><hr><h1 id="一些常用的材质节点"><a href="#一些常用的材质节点" class="headerlink" title="一些常用的材质节点"></a>一些常用的材质节点</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220757.png" alt="image.png"></li><li>以上是一些常用的基础材质节点，分别是：<ul><li>1+左键： 常量节点，用于输入一个常量</li><li>2+左键： 一个二维向量节点，用于输入一个二维向量</li><li>3+左键：一个三维向量节点，可以看到对应的RGB值，输入一个三维向量</li><li>M+左键：乘法，接受两个常量输入，输出他们相乘的结果</li><li>T+左键：输入一个材质，可以选择一个图像，输出RGB或其他选项</li></ul></li><li>还有更多的节点可以通过右键呼出搜索面板来进行搜索，与blender shift+a类似</li></ul><hr><h1 id="常用的输出端简介"><a href="#常用的输出端简介" class="headerlink" title="常用的输出端简介"></a>常用的输出端简介</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928221546.png" alt="image.png"></li><li>根据我们选择着色模型的不同，也会有对应的不同的输出端口，但常用的基本一致，比如作为颜色信息的基础颜色，控制粗糙度的粗糙度端口。以下是逐项的介绍</li></ul><h2 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h2><ul><li>类似于UnityShader中的Color Tint，是作为基本的输出颜色存在的，决定了材质视觉上的呈现，往往直接可以连接一张Texture</li></ul><h2 id="金属感"><a href="#金属感" class="headerlink" title="金属感"></a>金属感</h2><ul><li>取值为0-1，所有的导电物体都应该具备的属性，可以让视觉上材质呈现出金属质感，类似于哑光质感。</li></ul><h2 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h2><ul><li>取值为0-1，类似于UnityShader中的_Gloss属性，用于控制高光的大小</li></ul><h2 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h2><ul><li>取值为0-1，用于控制物体的粗糙程度，可以接受Texture输入，类似于diffuse与Specular的混合程度，0即为100%Specular，1即为100%diffuse</li></ul><h2 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h2><ul><li>用于控制高光反射的形状，底层逻辑是一张采样的贴图</li></ul><h2 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h2><ul><li>用于控制物体自发光强度，数值越大发光强度越高，在UE中可以照亮周围的物体</li></ul><h2 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h2><ul><li>取值为0-1，用于控制物体可见性的数值，本质依然是不透明度混合的结果，这个数值就是可以对其的范围进行调节。可参考UnityShader中不透明效果的代码实现</li></ul><h2 id="不透明蒙版"><a href="#不透明蒙版" class="headerlink" title="不透明蒙版"></a>不透明蒙版</h2><ul><li>不透明蒙版可以做出类似PS中剪贴蒙版的作用，可以对有A通道的照片素材进行裁切，并且让场景中的面片跟随变化轮廓</li></ul><h2 id="法线与切线"><a href="#法线与切线" class="headerlink" title="法线与切线"></a>法线与切线</h2><ul><li>经常用作制作物体表面凹凸质感，在UnityShader中，可以在切线空间下计算法线贴图也可以在世界空间计算，美术更喜欢前者，因为可以清晰判别模型的各个视觉方向。</li></ul><h2 id="全局位置偏移"><a href="#全局位置偏移" class="headerlink" title="全局位置偏移"></a>全局位置偏移</h2><ul><li>移动模型位置，更多用于动态效果的创建</li></ul><h2 id="次表面颜色"><a href="#次表面颜色" class="headerlink" title="次表面颜色"></a>次表面颜色</h2><ul><li>需要配合次表面着色模型开启，开启后可以实现透光效果</li></ul><h2 id="折射与像素深度偏移"><a href="#折射与像素深度偏移" class="headerlink" title="折射与像素深度偏移"></a>折射与像素深度偏移</h2><ul><li>前者多为玻璃材质所需，后者则是软化模型交界处质感</li></ul><hr><h1 id="渲染模式与着色模型"><a href="#渲染模式与着色模型" class="headerlink" title="渲染模式与着色模型"></a>渲染模式与着色模型</h1><ul><li><p>在UE中一共有六种材质域，数种着色模型：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928223722.png" alt="image.png"></p></li><li><p>许多与Unity共同的特点，只不过有更好的封装进而有更便捷的实现。例如混合模式就是UnityShader中的Blend关键字，可以很容易的进行混合模式的开启，从而渲染半透明等材质</p></li><li><p>同样，着色模型也为我们提供了实现某些渲染效果更轻松的实现，这些都是UE为我们进行的优化。</p></li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>这一节，我们初步认识了UE的材质编辑界面，简单来说，就是利用可视化节点的方式代替code编辑从而便捷的实现效果，但请记住，本身仍然是一个个函数实现，因此结合Shader代码的学习必不可少！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——2</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的语言—二进制"><a href="#计算机的语言—二进制" class="headerlink" title="计算机的语言—二进制"></a>计算机的语言—二进制</h1><ul><li>计算机内部都是由IC（集成电路）组成的，它们只具有两种状态，&#x3D;&#x3D;高电平和低电平&#x3D;&#x3D;，这个特性决定了计算机的数据只能以二进制来处理。</li><li>计算机处理的最小单位：位，就相当于二进制中的一位，也叫做bit。</li><li>八位二进制数被称为一个字节，字节(byte)是基本信息计量单位，是基本单位。</li><li>再用字节处理数据时，&#x3D;&#x3D;如果数字小于存储的字节数&#x3D;&#x3D;，那么高位就用0占位填补。</li><li>&#x3D;&#x3D;二进制数可以表示文字&#x3D;&#x3D;，&#x3D;&#x3D;图像等&#x3D;&#x3D;，其表示的内容取决于程序的编写方式。</li></ul><h1 id="二进制数的计算"><a href="#二进制数的计算" class="headerlink" title="二进制数的计算"></a>二进制数的计算</h1><ul><li>二进制数的本质就是逢二进位，那么它与十进制的转化就是用每一位的数字乘以它的位权。位权的意思就是基数的对应位数指数。  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417094555.png">  指数由第一位开始向左累加。</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>移位运算是指将二进制数值个数为进行左右的移位。&#x3D;&#x3D;移位有左移&#x3D;&#x3D;，&#x3D;&#x3D;右移两种&#x3D;&#x3D;。 <ul><li>运算符：&lt;&lt;被称为左移运算符，&gt;&gt;被称为右移运算符，两者的左侧是被移位值，右侧是要移位的位数。</li><li>左移：左移空出的低位要进行补0操作。<br>  移位可以重来充当乘除法运算，左移两位数值会变为原来的4倍。</li><li>右移：二进制中表示负数值时，&#x3D;&#x3D;会将最高位当作符号位来使用&#x3D;&#x3D;，如果最高位为0则为正数，反之为1则为负数。<br>  这就区分了有符号数和无符号数，有符号数就是有符号位的数</li><li>补数：因为计算机实际上是在做加法运算来进行减法。![[计算机底层结构——1#^3cacdc]]<br>  获得补数的方式就是将全部数位取反再加1，补数与原来的数字之和为0，这很像是相反数。</li></ul></li><li>计算机中，0包含在正数范围内，所以负数要比真正的正数多一个。</li></ul><h2 id="逻辑右移与算术右移"><a href="#逻辑右移与算术右移" class="headerlink" title="逻辑右移与算术右移"></a>逻辑右移与算术右移</h2><ul><li>逻辑右移： 当二进制数的值表示图形模式而非数值时，移位后就需要在最高位前补0</li><li>算术右移：移位后需要在最高位前填充移位前的符号位的值，比如若为0，则需要填充1，反之亦然。</li></ul><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><ul><li>在保持值不变的情况下，将原有的低位数转化为高位数，直接用符号位填充前面的所有位数。</li></ul><h2 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h2><ul><li>逻辑非：1变0,0变1的取反操作</li><li>逻辑与：两者同时为1时，结果为1</li><li>逻辑或：至少一方为1时，结果为1。</li><li>逻辑异或：排斥相同，相同为0不相同为1</li></ul><h1 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h1><ul><li>在使用二进制存储数据时，我们往往会出现大量的数据，而如何简化其表示，以便操作，就是我们要考虑的问题，因此，&#x3D;&#x3D;我们出现了将二进制转化为8进制甚至16进制的操作&#x3D;&#x3D;。</li></ul><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><ul><li>八进制是二进制的简化表示，每位八进制数对应三位二进制数<br>  <code>二进制 001 = 八进制 1  </code>二进制010  &#x3D;  八进制2</li></ul><h2 id="二进制转化为八进制"><a href="#二进制转化为八进制" class="headerlink" title="二进制转化为八进制"></a>二进制转化为八进制</h2><ul><li>将二进制三位一组分开，每三位表示八进制数一位</li><li>如1011101 按三位一组分组 001，011，101(注意，高位是00可以直接省略)</li><li>对应八进制数135</li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><ul><li>16进制数分为0，T，2，3，4，5，6，7，8，9，A，B，C，D，E，F</li><li>每位十六进制数对应四位二进制数</li><li><code>二进制0000 = 十六进制0</code><br>  <code>二进制0001 = 十六进制1</code><br>  <code>二进制1111 = 十六进制F</code></li></ul><h2 id="二进制转化为十六进制"><a href="#二进制转化为十六进制" class="headerlink" title="二进制转化为十六进制"></a>二进制转化为十六进制</h2><ul><li>将二进制数每四位一组进行分割，每组对应一位十六进制数</li><li>如二进制数11011010四位一组为1101,1010<br>  对应十六位数DA</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——1</title>
      <link href="/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/"/>
      <url>/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul><li><p>CPU是集成了&#x3D;&#x3D;控制器，运算器，寄存器，时钟&#x3D;&#x3D;的终端，它负责将我们的&#x3D;&#x3D;汇编语言&#x3D;&#x3D;解释为&#x3D;&#x3D;机器语言&#x3D;&#x3D;，从而供底层微处理器执行。他们通过&#x3D;&#x3D;总线&#x3D;&#x3D;相互连接，传递数据和指令。</p><ul><li><strong>寄存器</strong>：用于&#x3D;&#x3D;暂存指令&#x3D;&#x3D;，&#x3D;&#x3D;等对象&#x3D;&#x3D;。是内存的一种</li><li><strong>控制器</strong>：负责将内存上的指令数据&#x3D;&#x3D;读入寄存器&#x3D;&#x3D;并依据结果&#x3D;&#x3D;控制整个计算机&#x3D;&#x3D;，主要是输入输出时间的控制。</li><li><strong>运算器</strong>：负责运算寄存器中的数据，并把结果输出。</li><li><strong>时钟</strong>：发出CPU开始计时的时钟信号。（&#x3D;&#x3D;信号频率越高，CPU运行越快&#x3D;&#x3D;）</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><strong>内存</strong>指的是计算机的主存储器，负责存储指令和数据。&#x3D;&#x3D;每个字节都有一个地址编号&#x3D;&#x3D;，cpu通过它来读取指令与数据。</li></ul><h1 id="CPU与寄存器"><a href="#CPU与寄存器" class="headerlink" title="CPU与寄存器"></a>CPU与寄存器</h1><ul><li>CPU是寄存器的集合体，程序将寄存器作为对象来描述。</li><li><strong>汇编</strong>：指的是将汇编语言转化为机器语言。</li><li>寄存器种类多样：比如有&#x3D;&#x3D;程序计数器&#x3D;&#x3D;，&#x3D;&#x3D;标志寄存器&#x3D;&#x3D;，累加寄存器，&#x3D;&#x3D;基址寄存器&#x3D;&#x3D;，&#x3D;&#x3D;变址寄存器&#x3D;&#x3D;等。</li></ul><h1 id="寄存器与程序执行"><a href="#寄存器与程序执行" class="headerlink" title="寄存器与程序执行"></a>寄存器与程序执行</h1><ul><li><strong>寄存器</strong>中的<strong>程序计数器</strong>被赋予了分配程序执行顺序的能力。当硬盘中的文件被复制到内存后，程计会被&#x3D;&#x3D;设定为初始值0100&#x3D;&#x3D;，然后开始运行，&#x3D;&#x3D;每当&#x3D;&#x3D;CPU执行完一个指令，程计中的数值都会进行&#x3D;&#x3D;累加&#x3D;&#x3D;操作。CPU会按照程计的数值，从内存中读取命令并执行。</li><li><strong>循环，顺序，条件分支</strong>：这三种执行方式组成了程序的流程。<ul><li><strong>条件分支</strong>：如果在程序执行的过程中，需要有条件分支语句，那么在程计中，遇到这个语句，&#x3D;&#x3D;会将程计的数值设置为对应的地址数值&#x3D;&#x3D;，这个操作被称为&#x3D;&#x3D;jump&#x3D;&#x3D;。</li></ul></li></ul><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417091436.png" alt="Pasted image 20240417091436"></p><ul><li><p><strong>&#x3D;&#x3D;标志&#x3D;&#x3D;寄存器</strong>：标志寄存器主要的作用为将累加寄存器中的结果&#x3D;&#x3D;状态&#x3D;&#x3D;进行记录，比如正负奇偶都会将其进行保存。所以在条件分支前，由其判断是否进行jump。标志寄存器&#x3D;&#x3D;前三个字节分别表示正0负三种状态&#x3D;&#x3D;。</p></li><li><p>标志寄存器的判断，实际上是对数值进行&#x3D;&#x3D;减法&#x3D;&#x3D;运算，通过结果设定状态。 ^3cacdc</p></li><li><p><strong>函数的调用</strong></p><ul><li>函数在调用时，在程计中会存在一个&#x3D;&#x3D;函数调用点&#x3D;&#x3D;。</li><li>call，return指令：call指令在函数入口地址设定到程计前，会把&#x3D;&#x3D;函数调用后&#x3D;&#x3D;要执行的地址存储在栈中。<br>  栈相关：[[内存与数据类型#栈]]<br>  函数处理完后，在通过函数出口来执行&#x3D;&#x3D;return&#x3D;&#x3D;指令，将栈中的地址设定到程计中。</li></ul></li><li><p>基址寄存器与变址寄存器：通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似数组的操作。数组相关：[[数组部分]] </p><ul><li>CPU会将基址寄存器和变址寄存器中的&#x3D;&#x3D;值之和&#x3D;&#x3D;视作实际要去查看的内存地址。变址寄存器相当于&#x3D;&#x3D;数组索引功能！&#x3D;&#x3D;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——0</title>
      <link href="/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/"/>
      <url>/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><ul><li><p>何为计算机？</p><ul><li>计算机是执行输入，计算，输出的机器</li></ul></li><li><p>何为程序？</p><ul><li>程序是指令与数据的集合</li></ul></li><li><p>何为计算机的处理方式？</p><ul><li>计算机的处理方式与人类习惯不同</li></ul></li><li><p>计算机由软硬件共同组成</p></li></ul><h2 id="输入，运算与输出是硬件基础"><a href="#输入，运算与输出是硬件基础" class="headerlink" title="输入，运算与输出是硬件基础"></a>输入，运算与输出是硬件基础</h2><ul><li>计算机硬件由大量IC（集成电路）组成</li><li>IC上有很多引脚，有的用于输入有的用于输出，IC会在内部运算输入的信息，并把结果输出。</li><li>所有的计算机操作都归于输入计算与输出缺一不可</li></ul><h2 id="软件是指令与数据的集合"><a href="#软件是指令与数据的集合" class="headerlink" title="软件是指令与数据的集合"></a>软件是指令与数据的集合</h2><ul><li><p>所有的操作都是基于一条一条指令</p></li><li><p>一组指令可以成为<strong>函数，方法，语句</strong>等等。程序中的数据分为两类，一类作为指令执行对象的输入数据，另一类是输出数据。</p></li><li><p>我们将数据称为<strong>变量</strong> 。</p></li><li><p>正如数学中的函数概念一样，往往我们都将程序中的方法写作：<br>  <code>y = f(x)</code></p></li><li><p>其中x为输入数据，这表示将x输入到函数y中</p></li><li><p>在程序中可能是这个样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> answer = a+b+c/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序会通过编译（见1）将我们所写的高级语言代码转换成机器能看懂的机器语言代码。这会是一系列数值，它们既包含指令同样也包含数据。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240914112937.png" alt="image.png"></p></li></ul><h2 id="对于计算机来说什么都是数字"><a href="#对于计算机来说什么都是数字" class="headerlink" title="对于计算机来说什么都是数字"></a>对于计算机来说什么都是数字</h2><ul><li>计算机将一切都当作数字对待，最基础的可能是单纯的数字加减，但同样也可以是图片，音乐等等。</li></ul><h1 id="计算机组成简介"><a href="#计算机组成简介" class="headerlink" title="计算机组成简介"></a>计算机组成简介</h1><ul><li>计算机主要有CPU，内存和I&#x2F;O组成</li><li>CPU负责对数据运算和控制内存I&#x2F;O</li><li>内存负责存储CPU需要的指令与数据</li><li>I&#x2F;O则负责把键盘鼠标显示器等与主机连接实现数据的输入与输出</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>作为向美术等非专业人员介绍计算机相关内容的第一篇，诚惶诚恐，但愿能解答一些大家的疑惑，帮助大家更好的工作，本文会在后续持续跟进更改！感谢大家</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ul><li>计算机是怎样跑起来的（矢泽久雄）</li><li>程序是怎样跑起来的(矢泽久雄)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
