<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客搭建感想</title>
      <link href="/2024/11/24/hello-template/"/>
      <url>/2024/11/24/hello-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><ul><li>本地化部署流程</li><li>线上发布流程</li></ul><hr><h2 id="本地化部署"><a href="#本地化部署" class="headerlink" title="本地化部署"></a>本地化部署</h2><ul><li>前期准备<ul><li>首先，本地化部署需要提前安装好两个东西，<br>可参考hexo框架官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>需要下载node.js，同时下载npm，也就是版本管理器，这些可以帮助我们管理博客版本内容。<ul><li>node.js 官网：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>你可以直接在官网复制它的代码并且打开本地自带的Windows命令窗口：powershell，粘贴你复制的代码</li><li>等待安装完成就可以了</li></ul></li><li>下载git，git主要作用是建立起云端和本地之间的桥梁，让我们能够从云端拉取数据。<ul><li>同样可以在官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a> </li><li>git安装相对简单，你可以直接全部选择next就自动安装完成了，很无脑！</li></ul></li><li>在安装完成后，本地的环境就基本上搭建完成了。</li></ul></li></ul><h2 id="线上发布："><a href="#线上发布：" class="headerlink" title="线上发布："></a>线上发布：</h2><ul><li>首先访问：<a href="https://github.com/mmdjiji/hexo-template">https://github.com/mmdjiji/hexo-template</a> 获取该库的代码，并且由此新建一个库，<br>详细教程可参考：<a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&vd_source=a506bd54314456e886d3818e488bb1c8">https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&amp;vd_source=a506bd54314456e886d3818e488bb1c8</a></li><li>断点发生在使用spacecode编辑处，因为该方法是完全基于云端的部署，所以完全依赖虚拟机的网速<br>然而经过多方验证，虚拟机网速堪忧，因此在此我们选择在本地部署！</li></ul><h2 id="独家揭秘！"><a href="#独家揭秘！" class="headerlink" title="独家揭秘！"></a>独家揭秘！</h2><ul><li>本地化部署就是本教程独一无二之处，大部分教程都会将两者割裂，但本教程才是最无脑的过程，<br>前文我们已经提到，云端部署十分缓慢，那有没有办法加快这个速度呢？</li><li>答案当然是有的！我们可以利用githubdesktop更快捷的进行上传与下载，避免云端网速的问题！</li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><ul><li>首先，下载githubdesktop，这个在你的库里local选项就能下载，为了方便起见，本文还是给大家配图</li><li>配图使用PicGo，同样也会给大家介绍，并且介绍obsidian中的PicGo联动小功能！  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20111142.png"></li><li>下载安装完成后，我们就可以将线上的库克隆到本地了，这里各位自行摸索即可，很简单，就不再赘述</li></ul><h3 id="在bush窗口中完成部署"><a href="#在bush窗口中完成部署" class="headerlink" title="在bush窗口中完成部署"></a>在bush窗口中完成部署</h3><ul><li>克隆完成后，我们需要再本地进行编辑，首先，找到克隆库所在本地文件夹，在文件夹中右键</li><li>打开选项栏，选择open git bush here</li><li>然后我们就嫩得到一个这样的窗口，很好，你已经几乎要完成它了！  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912111820.png"></li><li>随后，我们需要先安装hexo框架，在对话框中输入：<br>   <code>$ npm install -g hexo-cli </code></li><li>等待安装完成，在这里你可以加速这个过程，可将上述代码替换为：<br>   <code>$ cnpm install -g hexo-cli</code></li><li>这是一个国内镜像，但前提是你需要下载它，你可以通过powershell输入：<br>   <code>npm install -g cnpm --registry=https://registry.npmmirror.com </code><br>   下载完成后，之后的所有需要npm的代码就都可以用cnpm替换了</li><li>之后我们继续键入<code>cnpm install</code>来安装依赖，请确保你进行了上一步！</li><li>在此之后，我们就完成了全部部署，你可以输入<code>hexo g</code>来检测部署结果</li><li>注意！按此方式部署的hexo是局部的，所以需要输入<code>npx+hexo...</code>命令！注意区分</li><li>若如图所示，则说明部署完成：  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912112800.png"></li><li>请注意，上图中，butterfly字样是主题，若未安装是不会显示的，这无伤大雅。</li></ul><h3 id="配合github上传"><a href="#配合github上传" class="headerlink" title="配合github上传"></a>配合github上传</h3><ul><li>第一阶段我们的githubdesktop就排上用场了，你只需要在面板中点击commit，</li><li>随后点击push origin 上传到云端即可了，返回到github库主页面，点击setting，查看page页面更新消息，你可以按F5刷新页面，不过多久，一个网站就搭建好了，并且你可以在本地完全控制它！</li></ul><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>这是我的第一篇真正的博客，讲解了如何优雅而简便的搭建一个你的博客，接下来我会更新后续的内容，包括技术美术全部相关学习心得，笔记，随笔，图形学系列课程，希望能共同学习交流，那么最后一步！</li><li>push to origin！</li></ul><hr><h1 id="参考链接与项目"><a href="#参考链接与项目" class="headerlink" title="参考链接与项目"></a>参考链接与项目</h1><ul><li>1.hexo官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>2.b站up主：方欲遣兵北逐胡的视频：【基于Hexo搭建本地博客并部署到云服务器教程】 <a href="https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>3.b站up主：吉吉学长的视频：【【Hexo | 03】创建属于你的追番列表】 <a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>全部为开源项目，不承担任何责任！！</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学3——变化的基础</title>
      <link href="/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1矩阵"><a href="#3-1矩阵" class="headerlink" title="3.1矩阵"></a>3.1矩阵</h1><h2 id="3-1-1-矩阵的定义"><a href="#3-1-1-矩阵的定义" class="headerlink" title="3.1.1 矩阵的定义"></a>3.1.1 矩阵的定义</h2><ul><li>矩阵就是二维的向量数组。</li><li>矩阵是由c列维度为R的向量组成的，我们标记一个矩阵的方法是标记它的行与列也就是Mr×c。</li><li>如下这是一个二行三列的矩阵：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026103749.png" alt="image.png"><br>          <code>3.1.1 一个二行三列矩阵</code></li><li>在计算机图形学中，我们经常利用矩阵来进行空间的变换，通过其与向量进行计算来变化空间。</li></ul><h2 id="3-1-2-方阵与对角单位阵"><a href="#3-1-2-方阵与对角单位阵" class="headerlink" title="3.1.2 方阵与对角单位阵"></a>3.1.2 方阵与对角单位阵</h2><ul><li>当矩阵的行与列相同时，我们称其为方阵，可用n来直接代表其维数，一个方阵也就是n×n维的矩阵。</li><li>更特殊一点，如果一个方阵的其他非对角元素均为0，对角元素为1，那么我们就称其为单位阵，单位阵在矩阵运算中充当着与实数运算中1相当的地位，也就是<strong>任何矩阵乘以单位阵</strong>得到的还是原矩阵（前提是它们能相乘）。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104332.png" alt="image.png"><br>          <code>3.1.2 一个单位阵</code></li></ul><h2 id="3-1-3-相等矩阵与转置矩阵"><a href="#3-1-3-相等矩阵与转置矩阵" class="headerlink" title="3.1.3 相等矩阵与转置矩阵"></a>3.1.3 相等矩阵与转置矩阵</h2><ul><li>判断一个矩阵相等的前提是，首先它们的维数相同，其次，它们逐行逐列对应的元素均相同，由此我们判断两个矩阵相等。</li><li>转置是一个操作，简单来说就是将矩阵的行与列交换，也就是第一行元素变成第一列元素，第一列元素反之变为第一行元素。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104648.png" alt="image.png"><br>          <code>3.1.3 矩阵的转置</code></li><li>转置我们用上标T来表示，一个矩阵转置的转置就等于其本身，单位阵的转置也等于其本身。</li></ul><h1 id="3-2-矩阵的运算"><a href="#3-2-矩阵的运算" class="headerlink" title="3.2 矩阵的运算"></a>3.2 矩阵的运算</h1><h2 id="3-2-1-矩阵的数乘与加法"><a href="#3-2-1-矩阵的数乘与加法" class="headerlink" title="3.2.1 矩阵的数乘与加法"></a>3.2.1 矩阵的数乘与加法</h2><ul><li>矩阵的数乘很简单，因为矩阵某些性质与向量类似，因此矩阵的数乘实际上就是每一行每一列都乘上这个数。</li><li>矩阵的加法就是每一行每一列对应的元素相加，而其前提是它们的维数相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026110956.png" alt="image.png"><br>          &#96;3.2.1 矩阵的加法</li></ul><h2 id="3-2-2-矩阵的乘法"><a href="#3-2-2-矩阵的乘法" class="headerlink" title="3.2.2 矩阵的乘法"></a>3.2.2 矩阵的乘法</h2><ul><li>矩阵乘法的前提是两个矩阵的行列对应相等，也就是Ac &#x3D; Bc &amp;&amp; Ar &#x3D; Br</li><li>其方法就是第一个矩阵的行乘以第二个矩阵的列，然后将其对应元素相加作为新矩阵的元素</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026111922.png" alt="image.png"><br>          <code>3.2.2 矩阵的乘法</code></li><li>如下面这个例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112057.png" alt="image.png"><br>          <code>3.2.2.1 矩阵乘法实例</code></li><li>因此作为矩阵乘法，其并不满足乘法的交换律，因为如果交换就会发生行列不相等的情况<ul><li>AB !&#x3D; BA</li></ul></li><li>同样的如果AB &#x3D; AC 不意味着 B &#x3D;C，但矩阵满足乘法结合律，如下</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112751.png" alt="image.png"><br>      <code>3.2.2.2 矩阵满足乘法结合律</code></li></ul><h2 id="3-2-3-行列式与逆阵"><a href="#3-2-3-行列式与逆阵" class="headerlink" title="3.2.3 行列式与逆阵"></a>3.2.3 行列式与逆阵</h2><ul><li>行列式的定义<ul><li>行列式是方阵M对应的一个标量，记作|M|</li><li>行列式的计算：<ul><li>余子式与代数余子式<ul><li>我们通过观察行列式的求解可发现，实际上它是由一个个代数余子式相加得来的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026114721.png" alt="image.png"><br>     <code>3.2.3 矩阵的余子式求解</code></li><li>观察上图，实际上我们会发现余子式就是该元素乘上去除掉该元素所在的那一行和那一列后组合而成的矩阵。</li></ul></li></ul></li><li>矩阵转置的行列式等于原矩阵的行列式</li></ul></li><li>行列式的几何意义<ul><li>二维行列式的几何意义代表以基向量为两边构造的平行四边形的有符号面积</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026121109.png" alt="image.png"><br>          <code>3.2.4行列式的几何意义</code></li><li>在三维中，行列式的几何意义是以基向量为三边的平行六面体的有符号面积。</li></ul></li><li>逆矩阵<ul><li>逆矩阵是只有方阵才具备的性质，它本质上是说明一个方阵与另一个方阵的乘积为1，这两个方阵互为逆阵。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123201.png" alt="image.png"><br>                  <code>3.2.3.1 逆矩阵计算的举例</code></li></ul></li><li>判断是否可逆<ul><li>判断一个矩阵是否可逆需要检测矩阵行列式的值，一个具有逆矩阵的矩阵其行列式不为0，反之则为0。</li></ul></li><li>求解逆阵<ul><li>这里就需要利用我们之前学习到的求矩阵代数余子式的方式，先求出矩阵的代数余子式，并用其组成一个新的矩阵，我们称其为伴随阵，随后将伴随阵除以行列式的值即可得到矩阵的逆阵</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123823.png" alt="image.png"><br>                  <code>3.2.3.2 求解一个矩阵的逆阵</code></li></ul></li><li>逆阵的应用<ul><li>逆阵往往被用于执行反向操作上，因为它可以将其逆阵转化为单位阵，也就是最后得到1，可视为取消操作。</li></ul></li></ul><h2 id="3-2-4-正交阵"><a href="#3-2-4-正交阵" class="headerlink" title="3.2.4 正交阵"></a>3.2.4 正交阵</h2><ul><li>定义：如果一个矩阵的转置（MT） 等于这个矩阵的逆，那么我们就称其为正交阵。</li><li>这个性质在以后得求矩阵逆的应用上非常方便，因为矩阵逆很难求，就像上面说的那样，因此如果知道该矩阵是个正交阵，那么我们可以直接求其转置，转置开销很小，所以就进一步优化了性能，简化了计算！</li></ul><hr><h1 id="3-3向量与矩阵"><a href="#3-3向量与矩阵" class="headerlink" title="3.3向量与矩阵"></a>3.3向量与矩阵</h1><h2 id="3-3-1-行向量与列向量"><a href="#3-3-1-行向量与列向量" class="headerlink" title="3.3.1 行向量与列向量"></a>3.3.1 行向量与列向量</h2><ul><li>向量其实就是单维度的矩阵，比如一个行向量其实就一个1×n的矩阵，一个列向量实际上就是n×1的矩阵。它们是可以与矩阵进行运算的，但为了使其运算有意义，矩阵的位置很重要，比如行向量只能在矩阵的左侧，而列向量则只能在矩阵的右侧</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026130105.png" alt="image.png"><br>                   <code>3.2.3.3 两个向量相乘为矩阵</code></li><li>所以实际上，结果向量的每一个元素，都是元向量与矩阵中单独行列的点积。</li><li>行向量左乘矩阵必为行向量，而列向量右乘矩阵必为列向量</li></ul><h2 id="3-3-2-矩阵的几何意义"><a href="#3-3-2-矩阵的几何意义" class="headerlink" title="3.3.2 矩阵的几何意义"></a>3.3.2 矩阵的几何意义</h2><ul><li><p>我们前文提到了基向量这个概念，其实坐标系就是用基向量来进行表示的，我们已经强调过了矩阵实际上最大的作用就是改变空间坐标，那么究竟是如何改变的呢？</p></li><li><p>实际上每个向量都可以写作基向量的形式，而不同空间的基向量组成不同，但它们都有一个特点，那就是它们之间线性无关（也就是不在一个平面上）</p></li><li><p>矩阵乘以向量，实际上就是对这个向量的基向量进行的点乘变化</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026131455.png" alt="image.png"><br>                  <code>3.3.2 一个缩放矩阵</code></p></li><li><p>所以综上所述，矩阵与向量相乘，实际上就是对向量的基向量进行变化，又因为向量的基向量决定一个空间，因此实际上就是将一个向量，从一个空间变换到了另一个空间。</p></li><li><p>至此，我们完成了基本上所有的线性代数方面的学习，接下来就是去实际应用了，我们将会看到矩阵的实际作用，包括但不限于上述的例子。</p></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学2——位置与方向</title>
      <link href="/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/"/>
      <url>/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-点"><a href="#2-1-点" class="headerlink" title="2.1 点"></a>2.1 点</h1><ul><li>在上一节我们讲到，<strong>坐标系</strong>是图形学以及数学物理学等等学科中非常重要而基本的概念</li><li>坐标系又是有一系列<strong>离散</strong>的点（离散就是分散开的不连续的）组成的。</li><li>那么在这里我们就可以很简单的定义点：</li></ul><h2 id="2-1-1-点的定义"><a href="#2-1-1-点的定义" class="headerlink" title="2.1.1 点的定义"></a>2.1.1 点的定义</h2><ul><li>图形学中<strong>点</strong> 是坐标系中的一个<strong>位置，同时也是一个数组，记录这这个点所代表的值</strong>我们称为<strong>坐标</strong></li><li>点具有数值，维度这两个特征，并且是唯一的。</li></ul><hr><h1 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h1><h2 id="2-2-1-物理学家眼里的向量"><a href="#2-2-1-物理学家眼里的向量" class="headerlink" title="2.2.1 物理学家眼里的向量"></a>2.2.1 物理学家眼里的向量</h2><ul><li>在物理学中，向量也被称为矢量，它更多是描述一种<strong>运动</strong>，包含了运动的<strong>速度和方向</strong>，它的位置是没有意义的，可以在任何位置出现，下面是一个简单的例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113238.png" alt="image.png"><br>                      <code>2.2.1物理学家眼中的向量</code></li><li>这是一个三维空间里的向量分布，可以看出它们仅仅代表着不同的方向以及长度大小，它们的颜色值是根据数值对应的RGB颜色计算出来的（就像我们上节课所了解到的）</li><li>这是一种理解方式，但计算机学家眼中，还有另一种理解。</li></ul><h2 id="2-2-2-计算机学家眼里的向量"><a href="#2-2-2-计算机学家眼里的向量" class="headerlink" title="2.2.2 计算机学家眼里的向量"></a>2.2.2 计算机学家眼里的向量</h2><ul><li>计算机学家眼中，向量与物理学家眼中的不太相同，我们更多只在意它的<strong>数值特征</strong>，毕竟计算机的根本就是一组一组的数据运算（详细可在计算机基础入门中了解）</li><li>因此在他们眼里，向量也许是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113747.png" alt="image.png"><br>                   <code>2.2.2 计算机学家眼中的向量</code></li><li>在这个例子中，我们记录的两个数本身有自身所代表的含义，而我们却忽略了其位置，毕竟一个房屋的售价和平米而言，位置信息对他们是无效的。</li><li>而数学家却尽力概括这两个观点，他们就提出了我们所学习到的数学上对向量的定义</li></ul><h2 id="2-2-3-向量的定义"><a href="#2-2-3-向量的定义" class="headerlink" title="2.2.3 向量的定义"></a>2.2.3 向量的定义</h2><ul><li><strong>向量是在坐标系下，以原点为起点的有一定距离的有向线段。</strong></li><li>本质上它们表示的是两点之间的<strong>差异，或者说是一个点如何变化到另一个点的指示。</strong></li><li>向量与点类似，同样具备两个特征，那就是<strong>方向（所指的角度）以及大小（它的长度）</strong></li><li>在计算机中，向量往往作为变化的一种手段，我们可以利用它进行物体或者数值的变换，这种变换是对于坐标系而言的。</li></ul><h2 id="2-2-4-基本的向量的运算"><a href="#2-2-4-基本的向量的运算" class="headerlink" title="2.2.4 基本的向量的运算"></a>2.2.4 基本的向量的运算</h2><ul><li><strong>点与向量的运算</strong><ul><li>点的减法运算<ul><li>向量是两点只差，有了这个根据我们就可以通过两点位置的计算来表示一个向量，比如从P点到O点的运动方式，我们就可以理解为一个向量，让我们表示它！</li><li>O(Ox，Oy) - P(Px，Py) &#x3D; Vpo</li><li>我们一定要从几何直观上理解它，就像这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023115903.png" alt="image.png"><br>                   <code>2.2.4 点与向量的运算</code></li></ul></li><li>点的加法运算<ul><li>实际上我们已经可以描述点的加法运算了，它本质上只是减法的逆运算，因此我们可以描述P到O的运算，就像这样：</li><li>P(Px，Py) + Vop &#x3D; (Ox，Oy) </li><li>描述的实际上还是这个过程，很容易理解。</li></ul></li></ul></li></ul><hr><ul><li><strong>向量之间的运算</strong><ul><li>向量与向量的<strong>加法</strong><ul><li>向量之间的加法本质上也可以用过<strong>点</strong>来定义，因为前文告诉我们实际上向量也是由点来表述的，因此我们可在二维坐标系下，定义一个向量的加减法，就像我们定义点与向量的运算一样</li><li>点P(Px，Py) ，(Ox，Oy) ，Q(Qx,Qy) </li><li>向量：O(Ox，Oy) - P(Px，Py) &#x3D; Vpo，Q(Qx，Qy) - P(Px，Py) &#x3D; Vpq</li><li>所以<ul><li>Vpo + Vpq &#x3D; O(Ox，Oy) - P(Px，Py) +Q(Qx，Qy) - P(Px，Py)<br>  &#x3D; (Ox+Qx - 2Px,Oy + Qy - 2Py)</li></ul></li><li>计算很简单，但我们如何去描述它呢，实际上它让我们做了什么？</li><li>前文提到，计算机中向量的运算实际上就是改变一个数的值，我们完成的实际上是一个全局尺度的变换。</li><li>从P出发我们先到了O，此时如果用我们上面的值来表示（Px + Ox - Px，Py+ Oy - Py）最后运算得到的就是O点，而后我们再向着Vpq所代表的方向运动那就是（Ox + Qx -Px，Oy + Qy - Py)。为何与上面的结果有所不同？</li><li>细心地同学会马上指出，你求得的结果是个点啊！</li><li>没错，我们上面推导的实际上是对于一个点而言的变化，而前面所推的则是向量的加减法。他们有什么区别？没错，因为向量是忽略位置而只是一个操作，所以我们没有加上最开始的点坐标。而他们之间其实就是这个差别。</li><li>由此我们系统的论证了为何向量是指示一个点到另一个点的变化。这种加法法则也被称为向量的四边形法则：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023131800.png" alt="image.png"><br>                 <code>2.2.4.1向量的四边形法则</code></li></ul></li></ul></li></ul><hr><ul><li><strong>向量的数乘</strong><ul><li>向量的数乘实际上并不难理解，数乘可以看做一个缩放操作，是只对于向量的数值大小进行的变化</li><li>但同样会有一个例外：如果乘数是个负数，那么就会导致向量变化为反方向的一个新向量，相当于向反方向进行缩放。</li></ul></li><li><strong>向量的模</strong><ul><li>向量的模|a|其实就是描述向量长度的方式，这个需要运用一定的勾股定理去理解，实际上我们是将向量的分量作为描述模的方式也就是<ul><li>|a|  &#x3D; √ Ax^2 + Ay^2</li></ul></li></ul></li><li><strong>向量的归一化</strong><ul><li>向量的归一化是保留向量方向信息而忽略其长度信息的一种操作。比如在计算光线与法线的过程中，我们只需要知道方向信息就可以了，而过多的信息会造成数据存储的浪费，而如何进行这个操作呢</li><li>我们观察模的定义，会发现，如果我们想让模为1，实际上只需要将一个向量的每一个值除以他们的模，这是个很巧妙的数学方法</li></ul></li><li><strong>基向量</strong><ul><li>现在，我们终于可以介绍这个概念了，基向量是我们描述一个坐标系的方式，往往一对或几对相互垂直的基向量使我们定义一个基本的坐标系空间的方式，他们的特点是：模长为1，方向相互垂直，本质上是便于我们通过这个向量，来描述其他向量。如我们之前的Vpo向量就可以写成：<ul><li>Vx &#x3D; （Ox - Px）* Xi ， Vy &#x3D; （Oy - Py ）* Yi</li></ul></li><li>这样做什么好处，好像根本没有什么变化啊！？毕竟模长是1乘上去压根不会有什么变化</li><li>实际上，这就是我们本次课或者说图形学最终的运行逻辑。就是通过变换基向量来进行空间的变换。试想一下，如果变换每一个向量每一个点来转换一个模型是不是会很麻烦？</li><li>那么如果我们变换基向量本身呢？没错，这样的话我们就可以很简单的将一个空间理所应当的改变为另一个空间了，而不用变换里面的每一个点。因为点本身就是这些基向量形成的，本质只是数乘而已。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023144002.png" alt="image.png"><br>              <code>2.2.4.2 三个基向量张成一个向量空间</code></li></ul></li><li><strong>向量的乘法</strong><ul><li>点积<ul><li>点积是向量与向量相乘的结果，它最后得到的是一个数，公式如下<ul><li>a·b  &#x3D; axbx + ayby</li></ul></li><li>点积不但可以描述角度信息也可以描述一个向量再另一个向量方向上的投影长度<ul><li>a·b &#x3D; |a||b|cos&lt;a,b&gt;</li></ul></li><li>通过这个公式我们可以快速得出a，b之间夹角值，以及ab的大致方向判断。</li></ul></li><li>点积的特性使我们可以利用它将一个向量分为水平方向和垂直方向的分向量，为我们后期描述向量之间的关系提供了一个有力手段。</li><li>点积的实际应用：<ul><li>比如在计算光线与物体法线的关系中，我们就可以通过点积运算快速得出一个物体的受光信息：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"><br>                  <code>2.2.4.3 点积的应用——判断着色</code></li></ul></li><li>叉积<ul><li>叉积是向量之间的另一种运算，不同的是，它只适用于3维计算，它得到的不是一个数而是一个向量。<ul><li>a×b &#x3D; 【aybz - azby，axbz - azbx，axby - aybx】</li><li>axb &#x3D; （aybz - azby）x +（axbz - azbx）y +（axby - aybx）z</li></ul></li><li>叉积描述的是一个垂直于相乘的两个向量所构成平面的向量，因此往往应用于求解法向量。</li><li>叉积同样可以描述两个向量之间的角度关系<ul><li>a×b &#x3D; |a||b|sin&lt;a,b&gt;</li></ul></li><li>但需要注意的是，叉积可能会存在两个不同结果，这显而易见，因为垂直于ab平面的向量有两个，如何去判别他们呢？</li><li>我们可以通过平移向量使他们首尾相连，并判断是顺时针还是逆时针方向，通过左右手坐标系来判别他们的方向</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104047.png" alt="image.png"><br>                  <code>2.2.4.4 叉积存在两个方向 </code></li></ul></li><li>叉积的应用<ul><li>判定左右</li><li>前文我们提到，叉积有两个方向，并且我们可以根据方向的不同判定原始向量的旋向性，那么由此，我们就可以判断这两个向量之间的左右关系了，比如顺时针的方向排布，b在a的左边</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025115422.png" alt="image.png"><br>                  <code>2.2.4.5 插件的应用——判断左右</code></li><li>判断内外</li><li>这是一个很重要的应用那就是判断一个点是否在三角形内，这会在我们后续的<strong>光栅化</strong>阶段应用。我们可以依次连接一点与一个三角形顶点，并将其作为一个向量与三角形顶点组成的向量做叉积，如果三个顶点判断都为同一侧(左侧或者右侧)我们就将其判定为在三角形内，并渲染这个点到屏幕上。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025120903.png" alt="image.png"><br>                  <code>2.2.4.6叉积的应用——判断内外</code></li></ul></li></ul></li></ul><hr><h2 id="进阶2-3-在Processing中实践"><a href="#进阶2-3-在Processing中实践" class="headerlink" title="进阶2.3 在Processing中实践"></a>进阶2.3 在Processing中实践</h2><h2 id="2-3-1-向量加减法的直观实现"><a href="#2-3-1-向量加减法的直观实现" class="headerlink" title="2.3.1 向量加减法的直观实现"></a>2.3.1 向量加减法的直观实现</h2><p>我们通过Processing来定义两个向量构造函数，在Processing中我们进行如下定义，首先我们需要定义一个Pvector基类来实现向量，如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162520.png" alt="Pasted image 20240524162520.png"></p><p>在这些代码中，我们分别创建了三个向量对象，并且为他们赋值，让他们分别在xy上有了对应的值，因此我们可以在ellipse这个函数之中传入我们创建的对象的值，这样，我们就可以在想对应的坐标处为中心，创建圆形，add参数本质上就是将向量的对应坐标相加，得到v3的值。</p><hr><p>效果如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162856.png" alt="Pasted image 20240524162856.png"></p><hr><h2 id="2-3-2-点乘的直观实现"><a href="#2-3-2-点乘的直观实现" class="headerlink" title="2.3.2 点乘的直观实现"></a>2.3.2 点乘的直观实现</h2><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164159.png" alt="Pasted image 20240524164159.png"></p><hr><p>同样，我们在其中使用dot函数，就可以进行点乘。我们还是定义两个向量，并且传入两个向量的位置，调用line绘制两条线段，而后，我们将v2标准化，也就是作为1，并且我们将标准化后的v2，作为值与v1进行点积，实际上我们得到的就是v1在v2上的投影，而后我们将v2乘上这个投影，并且绘制，就可以得到如下图形：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164140.png" alt="Pasted image 20240524164140.png"></p><hr><h2 id="2-3-3向量叉乘的直观实现："><a href="#2-3-3向量叉乘的直观实现：" class="headerlink" title="2.3.3向量叉乘的直观实现："></a>2.3.3向量叉乘的直观实现：</h2><p>叉乘本质上就是先进行两个向量的标准化，也就是与基向量点乘，而后，将它们赋值给一个新的向量。这个新的向量就是标准化之后的向量。</p><p>我们来看一下它的实现<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524183848.png" alt="Pasted image 20240524183848.png"></p><p>首先我们新建两个变量，然后在中心位置新建一个点，我们在这个点为基准，绘制两条支线，然后以这两条支线为基准，使用叉乘函数生成我们的第三条线段，它是垂直于另外两条线段的，然后我们将它标准化，也就是除以模长，之后，绘制：效果如下图：</p><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524184007.png" alt="Pasted image 20240524184007.png"></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——8</title>
      <link href="/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/"/>
      <url>/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/</url>
      
        <content type="html"><![CDATA[<h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>数据逻辑节点：Ue中常用的数据选择节点有：switch，if节点等，我们可以简单利用这些节点对数据进行简单的判断。</li></ul><h1 id="switch节点"><a href="#switch节点" class="headerlink" title="switch节点"></a>switch节点</h1><ul><li>我们可以利用ue中的switch节点进行一些数据运算的判断，可以输入两个数据以及一个判断数据，来在外部创建选项进行数据的切换。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017131843.png" alt="image.png"></li></ul></li></ul><h1 id="if-节点"><a href="#if-节点" class="headerlink" title="if 节点"></a>if 节点</h1><ul><li>我们可以使用if节点进行一些简单的逻辑判断，比如a是否大于b或相反，这些在进行一些需要判断范围或者蒙版遮罩比较适用。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132235.png" alt="image.png"></li></ul><hr><h1 id="常用的数学运算节点"><a href="#常用的数学运算节点" class="headerlink" title="常用的数学运算节点"></a>常用的数学运算节点</h1><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132429.png" alt="image.png"></p><ul><li>以上是Ue中常用的三个数学计算节点，分别为点积，叉积，以及归一化运算，其相关的数学基础比较容易，在此就不赘述，各位谨记，实际上颜色也是数据，是向量组成的矩阵，对其进行操作就是进行向量的运算。</li></ul><h2 id="点积运算"><a href="#点积运算" class="headerlink" title="点积运算"></a>点积运算</h2><ul><li>点积运算本质是判断两个向量的方向关系，方向不同点积的结果也不同。这里给出基本的点积运算逻辑：<br>               A · B &#x3D; |A|B|cos(a,b)  </li><li>从公式可以看出，得到的结果存在一个ab的夹角的余弦值，我们可以利用这个值进行一些条件判断或者效果制作。</li></ul><h2 id="叉积运算"><a href="#叉积运算" class="headerlink" title="叉积运算"></a>叉积运算</h2><ul><li>差集运算本质是已知两个向量求第三个与这两个向量所在平面垂直的向量方向，因此我们可以利用这两个向量得出第三个向量的方向，在判断一点与三角形位置关系的时候经常使用，以下是叉积的运算逻辑：<br>               A×B &#x3D; |A||B|sin(a,b)</li><li>从公式可以看出实际上与它们垂直的第三个向量的长度在数值上等于以a，b，夹角为θ组成的平行四边形的面积。<br>               |c|&#x3D;|a×b|&#x3D;|a||b|sin&lt;a，b&gt;</li></ul><h2 id="归一化运算"><a href="#归一化运算" class="headerlink" title="归一化运算"></a>归一化运算</h2><ul><li>归一化往往是在简化运算方面进行的，有些时候我们只需要向量的方向信息而忽略它的位置信息，这时候我们就可以使用归一化操作，忽略它的具体位置信息而保留它的方向，让其模长为1。以下是归一化运算逻辑<br>                     B&#x2F;|B|</li><li>去除其长度信息，只保留其方向信息</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学1——基本概念</title>
      <link href="/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1画布与坐标系"><a href="#1-1画布与坐标系" class="headerlink" title="1.1画布与坐标系"></a>1.1画布与坐标系</h1><h2 id="1-1-1画布的定义"><a href="#1-1-1画布的定义" class="headerlink" title="1.1.1画布的定义"></a>1.1.1画布的定义</h2><ul><li>画布实际上可以理解为显示到屏幕上的画面，是一个像素矩阵，无论是3D场景抑或是2D场景，最后都要通过画布来呈现</li><li>画布可以使用一个函数（会在编写着色器时遇到它）它接受一个坐标值，并绘制一个颜色。</li></ul><hr><h2 id="1-1-2-坐标系"><a href="#1-1-2-坐标系" class="headerlink" title="1.1.2 坐标系"></a>1.1.2 坐标系</h2><ul><li>坐标系量化排布数值的方式。我们这里讨论的主要是屏幕坐标系，在不同的平台坐标系的定义不一样，但它们都应该具备几个基本特征：<ul><li>坐标轴</li><li>原点</li><li>轴距</li></ul></li><li>比如在OpenGL中坐标是这样的，y轴正方向向上</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145259.png" alt="image.png"><br>                      <code>1.1.2.1 OpenGL坐标系</code></li></ul><hr><ul><li>而在DirectX中，坐标轴是这样的：<br>*<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145422.png" alt="image.png"><br>                      <code>1.1.2.2 DirectX坐标系</code></li><li>我们可以通过变化轴来进行坐标系的变化。</li></ul><hr><h2 id="1-1-3-左右手坐标系"><a href="#1-1-3-左右手坐标系" class="headerlink" title="1.1.3 左右手坐标系"></a>1.1.3 左右手坐标系</h2><ul><li>在计算机软件中，我们常常会接触到判断物体坐标系的情况，最常用的两个坐标系分别是左手坐标系和右手坐标系，它们最大的不同就是它们所对应的x轴方向不同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104607.png" alt="image.png"><br>          <code>1.1.2.3 左右手坐标系</code></li></ul><hr><ul><li>区别两个坐标系的方式是考虑他们的旋向性，两个坐标系无法通过旋转重合。</li><li>如Unity使用的就是左手坐标系，它的特点是x轴向右。我们可以通过左右手法则来判断左右手坐标系</li><li>左手坐标系下旋转方向是顺时针的，而右手法则下旋转方向是逆时针的，对应的大拇指的方向也是垂直方向同样是不一样的</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104937.png" alt="image.png"><br>          <code>1.1.2.4 左右手法则</code></li></ul><hr><h1 id="1-2-色彩与色彩空间"><a href="#1-2-色彩与色彩空间" class="headerlink" title="1.2 色彩与色彩空间"></a>1.2 色彩与色彩空间</h1><h2 id="1-2-1色彩的感性理解"><a href="#1-2-1色彩的感性理解" class="headerlink" title="1.2.1色彩的感性理解"></a>1.2.1色彩的感性理解</h2><ul><li>色彩的<strong>冷暖，色彩的对比度，色彩的饱和度，色彩的色相</strong></li></ul><h2 id="1-2-2色彩的理性理解"><a href="#1-2-2色彩的理性理解" class="headerlink" title="1.2.2色彩的理性理解"></a>1.2.2色彩的理性理解</h2><ul><li>由<strong>光源产生的光线</strong>，进入人眼，在人眼细胞产生一系列化学反应，信号传入大脑，最终形成感知</li></ul><hr><h2 id="1-2-3光源的定义"><a href="#1-2-3光源的定义" class="headerlink" title="1.2.3光源的定义"></a>1.2.3光源的定义</h2><ul><li>**发出光线的物体</li><li>光的波长：<ul><li>理论上是无穷大的，人眼的<strong>可见光范围</strong>决定了我们对其颜色的定义。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120443.png" alt="image.png"><br>                       <code> 1.2.3.1 光波总览</code></li></ul></li></ul><hr><ul><li>如何去<strong>定量</strong>描述光？<ul><li>光实际上是<strong>波</strong>，波形可以叠加，我们通过<strong>功率单位</strong>（流明，瓦数等）描述。</li><li>分光光度计：通过分光后对波长进行感知，最终得知光能量集中在550nm区域（图中绿色区域）</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120750.png" alt="image.png"><br>                      <code>1.2.3.2 人眼可见光范围</code></li></ul></li></ul><hr><h2 id="1-2-4-光传播的方式"><a href="#1-2-4-光传播的方式" class="headerlink" title="1.2.4 光传播的方式"></a>1.2.4 光传播的方式</h2><ul><li>基本的传播方式：<ul><li><strong>直射，折射，反射，</strong> 光线追踪方式</li></ul></li><li>反射过程中，光的<strong>能量会减少，因为材质吸收了一定能量的光</strong>而吸收了某种颜色的光就代表人眼<strong>无法再看到这部分光。</strong><br>因此我们能看到的就是它们<strong>补集</strong>，也就是反射出的光</li></ul><hr><h2 id="1-2-5-光源的接受者"><a href="#1-2-5-光源的接受者" class="headerlink" title="1.2.5 光源的接受者"></a>1.2.5 光源的接受者</h2><ul><li>光源的接受者实际上是摄像机视图，但最终呈现给的是人眼</li><li>关于人眼的HDR：人眼可以调节自动曝光，分辨出高亮度的区域中不同亮度层次的区域。</li><li>人眼感知色彩的细胞主要分为杆状细胞和锥状细胞<ul><li>前者主要负责对亮度的感知</li><li>后者负责感知色彩</li></ul></li><li>我们主要关注感知色彩的锥状细胞，它又能分为分别感知红绿蓝三种颜色的SML三种细胞</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122148.png" alt="image.png"><br>                      <code>1.2.5 锥状细胞感受管线波长图</code></li><li>很明显他们感知的光线光波长度不一样。</li></ul><hr><h2 id="1-2-6-色彩的猜想"><a href="#1-2-6-色彩的猜想" class="headerlink" title="1.2.6 色彩的猜想"></a>1.2.6 色彩的猜想</h2><ul><li><p>人们猜想人的眼睛有数百种感光细胞感受不同颜色</p></li><li><p>人们猜想人有三种细胞分别感受红绿蓝三种颜色</p></li><li><p>人们猜想人分别有感知黑白，红绿，黄蓝这几种细胞</p></li><li><p>后来第二种和第三种分别演变为了两种色彩模型</p></li></ul><hr><h2 id="1-2-7-艺术家们的Munsell色彩系统"><a href="#1-2-7-艺术家们的Munsell色彩系统" class="headerlink" title="1.2.7 艺术家们的Munsell色彩系统"></a>1.2.7 艺术家们的Munsell色彩系统</h2><ul><li>来自于美国艺术家AlbertHenryMunsell</li><li>是通过色卡描述色彩，旋转轴是色相，垂直是亮度，由内到外是饱和度</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122917.png" alt="image.png"><br>                      <code>1.2.7 Munsell 颜色描述系统</code></li></ul><hr><ul><li>更多是<strong>基于经验而不是物理</strong>，不过这种HSL（色相饱和亮度）的色彩方法仍然被大多数艺术家所接受，至今活跃于各大DCC软件平台中。（如Photoshop）</li></ul><hr><h2 id="1-2-8-科学家们的-RGB-CSS系统"><a href="#1-2-8-科学家们的-RGB-CSS系统" class="headerlink" title="1.2.8 科学家们的 RGB CSS系统"></a>1.2.8 科学家们的 RGB CSS系统</h2><ul><li>即RGB Color Specification System（RGB色彩规格系统）</li><li>来自于CIE在1931年建立的色彩系统，从物理的方式客观描述量化色彩 </li><li>通过三原色打光进行观察对比，对于不同的光得到不同的参数值，最后的的结果如下：</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022133857.png" alt="image.png"><br>                      <code>1.2.8 RGB CSS 描述系统波形图</code></li></ul><hr><ul><li>图中表示方式并不规范，因此科学家又对其进行了归一化操作。这个操作在图形学中很常见，主要是为了更加规范的量化数值，便于表述和调节，这里我们使用将rgb三个量相加并且分别被rgb的量所除去的方式建立这个归一化算式：<ul><li><code>R&#39; = R/RGB,   G&#39;= G/RGB,   B&#39; = B/RGB</code></li></ul></li><li>至此，利用此算式和其变式，我们就可以用其中两个已知数计算另外一个数的值。</li></ul><hr><h2 id="1-2-9-基础的色域概念"><a href="#1-2-9-基础的色域概念" class="headerlink" title="1.2.9 基础的色域概念"></a>1.2.9 基础的色域概念</h2><ul><li>在此基础上，我们将r与g分别作为xy轴，就可以创建一个二维色彩空间，来描述一个颜色r与g部分的组成，前文我们可知，任何一个颜色都是可以由两个参数得出的，因此b就可以通过r与g计算得到。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022134614.png" alt="image.png"></li></ul></li></ul><hr><ul><li>XYZ色彩空间<ul><li>在上述二维色彩空间或称色域的基础上，为了避免出现负数，科学家又进行了一次迭代，这是用数学的方式做的一次更新，避免了<strong>负数的产生</strong>，但本身目的就是为了<strong>简化计算</strong></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135023.png" alt="image.png"></li></ul></li></ul><hr><ul><li>转换的方式：<ul><li>XYZ转换使用了矩阵进行转化计算，矩阵相关运算我们在下一节进行，这里只需要知道，矩阵起到了转换空间坐标的作用：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135351.png" alt="image.png"></li></ul></li></ul><hr><ul><li>为了便于计算，人们同样对该矩阵进行了归一化操作：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135429.png" alt="image.png"><br>          <code>XYZ转换矩阵进行归一化操作</code></li></ul><hr><h2 id="1-2-10-色域与Yxy色彩空间"><a href="#1-2-10-色域与Yxy色彩空间" class="headerlink" title="1.2.10 色域与Yxy色彩空间"></a>1.2.10 色域与Yxy色彩空间</h2><ul><li>经过1.2.9的演变最终形成了色域马蹄图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135719.png" alt="image.png"><br>               <code>色域马蹄图</code></li></ul><hr><ul><li>但这只是一张二维图片，虽然是人眼可见的色域范围，但并没有亮度表示，因此又将Y轴单独拿出来与xy组成了Yxy色彩空间，这个色彩空间中的Y轴是亮度：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140002.png" alt="image.png"><br>                  <code>Yxy色彩空间</code></li></ul><hr><h2 id="1-2-11-色彩空间的定义"><a href="#1-2-11-色彩空间的定义" class="headerlink" title="1.2.11 色彩空间的定义"></a>1.2.11 色彩空间的定义</h2><ul><li>一个色彩空间所具备的基础<ul><li>色域（三个基色坐标，由此形成三角形）</li><li>伽马（对三角形进行切分,一种采样方式）</li><li>白点（色彩中心）</li></ul></li><li>Gamma值<ul><li>简单来说就是色域切分片段的比例，主要分为<ul><li>均匀切割（Gamma &#x3D; 1）便于计算</li><li>非均匀切割（Gamma !&#x3D; 1）</li></ul></li></ul></li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140752.png" alt="image.png"></li><li>对暗部描述更多，对亮部描述更少。</li></ul><hr><h2 id="1-2-12-sRGB空间"><a href="#1-2-12-sRGB空间" class="headerlink" title="1.2.12 sRGB空间"></a>1.2.12 sRGB空间</h2><ul><li>sRGB空间是一种常用的色彩空间，它的gamma值为2.2，由内而外切线越来越粗</li><li>为何要用gamma？<ul><li>便于储存（远古）</li><li>人对亮部信息感受少对暗部感受多</li></ul></li><li>目前大部分游戏都会使用线性空间。任何色彩空间都可以是线性的linear，但linear本身不是一个色彩空间，它只是一个伽马值。</li></ul><hr><h2 id="1-2-13-颜色的表示以及处理法"><a href="#1-2-13-颜色的表示以及处理法" class="headerlink" title="1.2.13 颜色的表示以及处理法"></a>1.2.13 颜色的表示以及处理法</h2><ul><li>我们来看在计算机中如何表示一个颜色</li><li>颜色通道<ul><li>我们通过八位二进制数来对颜色进行表示，八位二进制数最多能表示255个数值，一共三个通道24位二进制数，总共为1670万种。</li><li>这种格式也被称为R8G8B8格式</li></ul></li><li>颜色深度<ul><li>颜色深度就是二进制数的总位数，如上述这种格式的颜色深度为24位</li></ul></li><li>对于颜色的处理<ul><li>我们可以对颜色进行一些处理，比如对颜色值乘以一个数值，或者对两个颜色值进行加减法运算，这些都是常见的处理方式。但我们限制单个颜色通道的范围为0~255之间。大于或小于这个数值都会被归为最大或最小值。</li></ul></li></ul><hr><h2 id="进阶-1-2-14-色彩空间的转换"><a href="#进阶-1-2-14-色彩空间的转换" class="headerlink" title="进阶 1.2.14 色彩空间的转换"></a>进阶 1.2.14 色彩空间的转换</h2><ul><li>我们已经初步了解了色彩空间的概念，色彩空间有很多，我们可以通过程序方式，对色彩空间进行转换。各位可以运用自己的编程能力，完成一个RGB2HSV的转化运算。欢迎大家给出自己的解决方案！下面是提示：</li></ul><hr><ul><li>RGB2HSV</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141834.png" alt="image.png"></li><li>HSV2RGB<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141903.png" alt="image.png"></li><li>作为本章的小作业，我会在文末给出我的源码供大家参考！<br>  小提示：mod为取模运算，即取余数</li></ul><hr><h1 id="1-3-颜色模型"><a href="#1-3-颜色模型" class="headerlink" title="1.3 颜色模型"></a>1.3 颜色模型</h1><h2 id="1-3-1-什么是颜色模型"><a href="#1-3-1-什么是颜色模型" class="headerlink" title="1.3.1 什么是颜色模型"></a>1.3.1 什么是颜色模型</h2><ul><li>前文我们提到了色彩空间，其中简单介绍了两种颜色模型，颜色模型有很多，但它们可以大体上分为两类：加色法模型和减色法模型</li></ul><hr><h2 id="1-3-2-减色法模型（色料）"><a href="#1-3-2-减色法模型（色料）" class="headerlink" title="1.3.2 减色法模型（色料）"></a>1.3.2 减色法模型（色料）</h2><ul><li>减色法模型主要模拟现实中调颜料的过程，打印机的原理就是这样，我们之前讲过，颜色实际上是其材料发射出的颜色，而其余颜色都被吸收了，如果你去调一盘颜料，会发现最后混合在一起就会变为黑色(美术同学应该深有体会)</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144121.png" alt="image.png"></li></ul><hr><ul><li>但不管我们用什么颜料去调色也不应该会出现纯黑色，因此这个稍暗的颜色被称为黑色（K）</li><li>而它对应的三原色是品红M青色C和黄色Y因此也被称作CMYK模型。</li></ul><hr><h2 id="1-3-3-加色法模型（色光）"><a href="#1-3-3-加色法模型（色光）" class="headerlink" title="1.3.3 加色法模型（色光）"></a>1.3.3 加色法模型（色光）</h2><ul><li>与前文减色法相对，在计算机以及物理中，我们会用加色来模拟真正的光线，从纯黑一步步添加颜色，最后叠加在一起被称为白色，而构成它的三原色也就是我们熟悉的RGB三种颜色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144414.png" alt="image.png"></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>介绍了计算机图形学中图形渲染的基本概念，从画布和坐标系的基本定义入手，到光源、色彩及色彩空间的深入解析，再到颜色模型的区分。最终提供了一个基础的RGB转HSV的算法实现</li></ul><hr><h1 id="进阶作业案例"><a href="#进阶作业案例" class="headerlink" title="进阶作业案例"></a>进阶作业案例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HSV</span> &#123;</span><br><span class="line">    <span class="type">float</span> h; <span class="comment">// 色相</span></span><br><span class="line">    <span class="type">float</span> s; <span class="comment">// 饱和度</span></span><br><span class="line">    <span class="type">float</span> v; <span class="comment">// 价值 (亮度)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HSV <span class="title">rgbToHsv</span><span class="params">(<span class="type">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class="line">    HSV hsv;</span><br><span class="line">    <span class="type">float</span> r = rgb.r / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> g = rgb.g / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> b = rgb.b / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> maxVal = std::<span class="built_in">max</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> minVal = std::<span class="built_in">min</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> delta = maxVal - minVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算亮度</span></span><br><span class="line">    hsv.v = maxVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算饱和度</span></span><br><span class="line">    <span class="keyword">if</span> (maxVal != <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.s = delta / maxVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里如果 maxVal 是 0，说明 RGB 都是 0</span></span><br><span class="line">        hsv.s = <span class="number">0</span>;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 设定为 0</span></span><br><span class="line">        <span class="keyword">return</span> hsv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算色相</span></span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 如果没有颜色，则色相为 0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal == r) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * <span class="built_in">fmod</span>((g - b) / delta, <span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == g) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((b - r) / delta + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == b) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((r - g) / delta + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hsv.h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hsv.h += <span class="number">360</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hsv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RGB rgb;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 RGB 值 (r, g, b) 范围在 [0, 255] 之间: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; rgb.r &gt;&gt; rgb.g &gt;&gt; rgb.b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> (rgb.r &lt; <span class="number">0</span> || rgb.r &gt; <span class="number">255</span> || rgb.g &lt; <span class="number">0</span> || rgb.g &gt; <span class="number">255</span> || rgb.b &lt; <span class="number">0</span> || rgb.b &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RGB 值必须在 [0, 255] 之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HSV hsv = <span class="built_in">rgbToHsv</span>(rgb);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对应的 HSV 值为: &quot;</span> &lt;&lt; <span class="string">&quot;H: &quot;</span> &lt;&lt; hsv.h &lt;&lt; <span class="string">&quot;, S: &quot;</span> &lt;&lt; hsv.s &lt;&lt; <span class="string">&quot;, V: &quot;</span> &lt;&lt; hsv.v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>欢迎批评指正！</li></ul><hr><h2 id="参考资料以及链接"><a href="#参考资料以及链接" class="headerlink" title="参考资料以及链接"></a>参考资料以及链接</h2><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学0——图形学引入</title>
      <link href="/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/"/>
      <url>/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1-图形学能做些什么？"><a href="#0-1-图形学能做些什么？" class="headerlink" title="0.1 图形学能做些什么？"></a>0.1 图形学能做些什么？</h1><ul><li><strong>游戏方面</strong>：<ul><li><p>真实的渲染画面</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Forza%20Horizon%204%20Screenshot%202024.10.11%20-%2017.41.24.95.png" alt="Forza Horizon 4 Screenshot 2024.10.11 - 17.41.24.95.png"><br>                      <code>游戏：极限竞速：地平线四</code></p></li><li><p>风格化的渲染模式</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101238.png" alt="image.png"><br>                      <code>游戏：无主之地3</code></p></li></ul></li></ul><hr><ul><li><strong>特效电影方面</strong>：<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101412.png" alt="image.png"><br>                     <code>电影：黑客帝国</code></li></ul></li><li><strong>动画方面</strong>：<ul><li>真实系动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101636.png" alt="image.png"><br>                      <code>动画电影：疯狂动物城</code></li><li>三渲二风格动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101847.png" alt="image.png"><br>                      <code>动画短片：星穹铁道角色PV——飞霄【君莫笑】</code></li></ul></li></ul><hr><ul><li>设计与效果模拟<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022102238.png" alt="image.png"><br>                     <code>地形编辑软件：GeoGen</code></li></ul></li></ul><hr><ul><li>综上所属，实际上图形学本质上是属于人机交互与视觉传达的基础学科，它是<strong>物理与数学</strong>相结合的产物，用于描绘出现实世界的光影变化外貌轮廓。</li></ul><hr><h1 id="0-2-什么是渲染"><a href="#0-2-什么是渲染" class="headerlink" title="0.2 什么是渲染"></a>0.2 什么是渲染</h1><ul><li>渲染是将场景信息通过一系列操作（渲染流程）作为帧或者图像呈现在屏幕上的过程。</li><li>负责渲染帧或图像的部分被称为渲染引擎，渲染引擎如Unity，Ue等将场景的数据通过渲染流程呈现在屏幕上。</li></ul><hr><ul><li>学习图形学需要具备什么？<ul><li>需要具备一颗会<strong>观察生活，追求美好画面</strong>的审美的心</li><li>需要具备一个<strong>严谨分析，善于思考剖析原理</strong>的脑</li></ul></li></ul><hr><h1 id="0-3-究竟学习什么？"><a href="#0-3-究竟学习什么？" class="headerlink" title="0.3 究竟学习什么？"></a>0.3 究竟学习什么？</h1><ul><li>总体而言：学习基础，学习方法，学习思维模式，主要入门的是离线渲染中的光栅化部分</li><li>总体时间段：<ul><li><strong>基础课和入门课结束之后：11月中旬到春节前</strong></li><li>2025年寒假以前（除考试周外）：每周六下午一节</li><li>2025年寒假到春节前一周：每周两到三节</li></ul></li><li>分享形式：每周由部长与副部长轮流交替直播分享，有录屏文件</li><li>课程所需：电脑（不要求配置），Processing，VisualStudio，Photoshop<ul><li>提供课程录播文件（上传部长Bilibili），提供原版教案（上传部长博客网站），提供课程所需素材（包括但不限于代码，资产，软件等）</li></ul></li></ul><h1 id="0-4-具体阶段："><a href="#0-4-具体阶段：" class="headerlink" title="0.4 具体阶段："></a>0.4 具体阶段：</h1><ul><li>1.<strong>基础入门概念</strong>：<ul><li>画布，颜色模型，颜色深度和颜色表示等</li><li>数学：线性代数</li><li>计算机硬件</li><li>课程安排：两到三节课</li></ul></li><li>2.<strong>渲染管线综述</strong>：<ul><li>渲染管线的大致划分</li><li>各个阶段的详解</li><li>课程安排：一到两节课</li></ul></li><li>3.<strong>光栅化阶段1：变换与几何部分</strong><ul><li>聚焦单个片元： </li><li>如何绘制直线，三角形——配合代码编写程序</li><li>如何填充一个三角形？——配合代码编写程序</li><li>三角形的变换与着色</li><li>课程安排：四到五节课</li></ul></li><li><strong>4.光栅化阶段2：着色与处理</strong>  配合DCC软件<ul><li>介绍基础概念如着色模型处理技术等</li><li>介绍材质</li><li>介绍UV贴图等概念</li><li>课程安排：三到四节课</li></ul></li><li>综上，入门图形学课程深入浅出，为各位进行日后的创作与研究奠定理论基础，正所谓千里之行始于足下，我们一起进步！</li></ul><hr><p><strong>深入学习，找到自己感兴趣的方向!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——7</title>
      <link href="/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/"/>
      <url>/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/</url>
      
        <content type="html"><![CDATA[<h1 id="法线底层原理"><a href="#法线底层原理" class="headerlink" title="法线底层原理"></a>法线底层原理</h1><ul><li>法线是赋予模型材质凹凸感的工具，其本身实际上是一组组的向量数据，通过光线与这些向量数据做矩阵运算，来得到凹凸效果</li><li>Bump贴图和Normal贴图：<ul><li>两者都可以用于实现法线所能够实现的凹凸效果，但Bump只有单一的凹陷凸起变化，而法线则是可以向四面八方进行变化，因此它们视觉上的颜色也是不一样的</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015153242.png" alt="image.png"></li><li>不同的颜色代表不同的方向，这一点前文我们已经了解过了，其本质是对颜色通道的映射，因为颜色通道RGB本身也可以视作一种向量（颜色向量）</li></ul></li><li>面法线与顶点法线：<ul><li>每个顶点自然都有自己的法线方向，而面法线是通过对一个面片上的顶点法线（通常为3个）进行插值得到的。</li></ul></li></ul><hr><h1 id="法线与光照运算"><a href="#法线与光照运算" class="headerlink" title="法线与光照运算"></a>法线与光照运算</h1><ul><li>在图形学的学习过程中我们了解到，很多光照模型都加入了法线来进行不同着色程度的运算，这里我们可以简单抽象为：<ul><li>若法线方向与光照方向相反则为-1(注意计算中光线方向是由物体指向光源)</li><li>若法线方向与光照方向垂直则为0</li><li>若法线方向与光照方向相同则为1</li></ul></li><li>以上，我们可以简单得出一个拥有明暗交界面的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"></li></ul><hr><h2 id="Ue中的实现"><a href="#Ue中的实现" class="headerlink" title="Ue中的实现"></a>Ue中的实现</h2><ul><li>我们通过调取光源方向节点SkyAtomsphereLightDirection，用Dot节将其与VertexNormal节点做点积运算，最后得到一个上述效果的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154449.png" alt="image.png"></li></ul><hr><h1 id="法线贴图的数据原理"><a href="#法线贴图的数据原理" class="headerlink" title="法线贴图的数据原理"></a>法线贴图的数据原理</h1><ul><li><p>法线贴图是在切线空间的，而切线空间中的x，y轴分别为tan与bitan也就是切线与副切线，而与他们垂直的就是法线：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154804.png" alt="image.png"></p></li><li><p>根据这个原理，我们就可以进行一定的数据运算，来实现法线凸起的效果，因此我们可以分析出一张法线贴图实际上是分别具有三个颜色通道的值，分别代表tan，bitan方向上凸起程度，加在一起便成为了一张法线贴图，因此使用法线时需要使用RGB通道：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015155058.png" alt="image.png"></p></li><li><p>根据上面的原理，我们可以自行验证一下，三个方向是不是具备相互垂直的关系，我们利用dot节点和Append节点来用GB两个通道的值来代替R通道的值：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015160239.png" alt="image.png"></p><ul><li>R点积G得到的是除B通道外的值，因为这两个方向是互相垂直的，点积为0，取反之后得到的就是B通道的值了。不要想复杂哦！</li></ul><h1 id="不同的法线贴图"><a href="#不同的法线贴图" class="headerlink" title="不同的法线贴图"></a>不同的法线贴图</h1></li></ul><hr><ul><li>OpenGL法线与DirectX法线：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015165216.png" alt="image.png"></li><li>他们的最大区别是轴向不同，导致的结果就是代表的方向不同，会导致模型表面突出方向倒置，区别方法就是看符合左手坐标系还是右手坐标系，OpenGl右手DirectX左手，分别对应逆时针和顺时针</li><li>我们可以对其进行简单的取反操作来让轴向改变，由此来转换不同的贴图。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——6</title>
      <link href="/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/"/>
      <url>/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/</url>
      
        <content type="html"><![CDATA[<h1 id="棋盘格"><a href="#棋盘格" class="headerlink" title="棋盘格"></a>棋盘格</h1><ul><li><p>我们来看一个有趣的效果，顺便介绍UE中常用的三角函数节点。</p></li><li><p>上一节我们已经初步认识了三角函数的威力，学习并分析了arctan节点</p></li><li><p>今天，我们从最基本的sine和cosine节点来认识Ue中的三角函数节点以及作用。</p></li><li><p>效果分析：我们需要实现黑白相间的棋盘格，本质上就是黑白的重复，我们可以用PS简单实现一下，供我们分析！</p></li></ul><h2 id="PS中的实现"><a href="#PS中的实现" class="headerlink" title="PS中的实现"></a>PS中的实现</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%A3%8B%E7%9B%98%E6%A0%BC.png" alt="imag.png"></li><li>我们可以观察到，这个图形是由黑色（0）以及白色（1）区域构成的，那么我们需要考虑如何实现这个排序，黑色可以通过乘法得出，我们可以利用Mask节点，将这张图横竖分开，并进行操作，让它变为横竖都是黑白相间的纹理，这就要隆重介绍我们今天的主角——sine节点。</li></ul><h2 id="SIne节点"><a href="#SIne节点" class="headerlink" title="SIne节点"></a>SIne节点</h2><ul><li>SIne节点作为一个三角函数节点，它模拟的就是三角函数的数值，它有一个周期参数，并且拥有三角函数的最大值最小值，它接受一个标量并将其进行三角函数运算，会出现波峰和波谷，波峰为正值而波谷为负值</li><li>在Ue中就会显示为黑白相间的条纹颜色！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241014094712.png" alt="image.png"></li><li>如上图所示，这样我们就可以利用它来创建网格了！</li></ul><h1 id="网格的实现"><a href="#网格的实现" class="headerlink" title="网格的实现"></a>网格的实现</h1><ul><li><p>网格需要横向和竖向的排列，因此我们需要将原有的纹理坐标节点使用mask节点拆分为R通道与G通道，分别对其进行计算</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150346.png" alt="image.png"></p></li><li><p>随后，为了控制纹理细分数量，我们为两个拆分后的节点分别添加Multipl乘法节点，并且新建一个常量数值接入他们，我们通过控制常量的大小来控制网格的数量，实际上是控制uv的缩放</p></li><li><p>随后我们分别为这两个节点添加SINE节点，这样，我们就可以在SINE节点的预览窗口中观察到条纹状的纹理了</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150409.png" alt="image.png"></p></li><li><p>而后，我们需要考虑如何混合这两个结果，我们需要让黑的部分叠加白的部分，并保留下来，因此我们使用Multipl节点将两个结果值相乘，这样黑色（&lt;0）的部分就会被保留，因为0乘以任何数仍为0，于是我们就得到了一张有些模糊的网格图。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150436.png" alt="image.png"></p></li><li><p>这看起来还有些不对，因为sine得出的有很多非整数结果，它们导致我们的边缘值比较模糊（再次记忆我们的颜色值始终置于0,1之间）</p></li><li><p>因此我们需要将它们取整，我们使用Ceil节点，将其取整，这个函数我们高中就学习过，大于0的值会变为1,1-2则变为2，因此他们会取整为1，这样我们的边缘值就正常了！</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150455.png" alt="image.png"></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——5</title>
      <link href="/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/"/>
      <url>/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/</url>
      
        <content type="html"><![CDATA[<h1 id="材质中的渐变"><a href="#材质中的渐变" class="headerlink" title="材质中的渐变"></a>材质中的渐变</h1><ul><li>常用的渐变的分类<ul><li>方形渐变</li><li>中心渐变</li><li>角度渐变</li></ul></li><li>渐变与UV坐标的关系<ul><li>在Ue以及其它三维软件中，UV坐标的直观显示是一个由白到黑的颜色渐变，随着数值变化而渐变，因此这种显示方式决定了，我们可以利用它来进行渐变效果的模拟</li></ul></li></ul><h1 id="方形渐变"><a href="#方形渐变" class="headerlink" title="方形渐变"></a>方形渐变</h1><ul><li><p>方形渐变的拆解：</p><ul><li>方形渐变本质上，通过观察我们可以发现，实际上它就是两个方向渐变的叠加：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png" alt="未标题-1.png"></li><li>实际上我们可以通过从水平方向和竖直方向分别拆解这个渐变，它是由白（1）到黑（0）再到白（1）的过程，那么我们只需要让它的数值变化符合这个规律，并且在最后取其中的最小值即可完成上图效果的实现：</li></ul></li><li><p>详细实现过程（UE）</p></li><li><p>首先，我们需要进行的是第一部，UV坐标的分解和处理，当然，我们同样可以对二维数据同时处理，我们先考虑第二种：</p></li><li><p>创建UV节点（U+左键）并且创建一个Mask掩码节点，用于分离UV常量：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008100813.png" alt="image.png"></p></li><li><p>随后，我们根据拆解的分析，利用subtract节点，将数值范围调整为：-0.5,0,0.5，之后，我们利用绝对值节点ABS将数值取正，调整为0.5,0,0.5,再乘2，即可达成1,0,1的数值变化：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101232.png" alt="image.png"></p></li><li><p>但这时你若直接输出，则会发现它与我们的期待正好相反，我们所需要的是0，1，0，但现在是1,0,1，不用担心，我们只需将其取反，利用取反节点onesubx（1-x）即可将数值变化变为0,1,0：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101422.png" alt="image.png"></p></li><li><p>数值满足了，但此时若直接输出会发现，依然不是我们所需要的效果，这是为何呢？</p></li><li><p>原来实际上我们同时处理UV的代价就是它们是混合进行的，所以若想达到效果，就需要将混合去除，</p></li><li><p>我们同样利用掩码Mask节点，分离UV方向，然后做最后一步，那么就是按我们的需求混合，我们希望保留下黑色部分，黑色部分是0，也就是最小值min，因此我们需要利用最小值节点min，以此来获得最终图像的效果：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101750.png" alt="image.png"></p></li><li><p>这样我们的方形渐变就大功告成了！</p></li><li><p><strong>一些思考</strong>：</p><ul><li>既然它是一个效果材质，那么我们理应提供调节效果的手段，我们在目前先提供一个控制范围的参数，若想控制渐变的区域，我们可以利用之前学过的Power节点，让整体数值趋于0，这样我们就可以将渐变范围调整了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102405.png" alt="image.png"></li><li>其他的调整方式，也欢迎大家实践！</li></ul></li></ul><h1 id="中心渐变"><a href="#中心渐变" class="headerlink" title="中心渐变"></a>中心渐变</h1><ul><li>下面我们再来看一个类型，中心渐变</li><li>中心渐变的拆解：<ul><li>中心渐变是一个圆形，从中心向外变化，内部为0，最外部为1，常常用来作为相机晕影的效果出现</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102703.png" alt="image.png"></li><li>实际上，它是一个特殊的方形渐变，它是365°的方向上变化的方形渐变，正如圆本身是一个很多边的多边形一样。因此，我们可以用类似的思考方式去模拟：</li></ul></li><li>详细实现过程（UE）：</li><li>首先，同样我们需要创建一个UV节点，但与上面条件不同的是，我们需要利用另一个节点来完成对全部方向上渐变的计算，我们使用Distance节点，它可以测量输入值与一个接收的数值的距离，我们将其设定为0.5,0.5,也就是正中心的UV坐标，我们就可以的到一个很棒的效果，一个看起来不错的圆形渐变：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103405.png" alt="image.png"></li><li>但仔细观察你会发现，它有些暗，是的，它的变化范围并不是0-1而是0-0.75，这是为什么呢，根据简单的勾股定理计算，实际上斜边并没有到1，因此为了让它的范围正确，我们需要进行一系列调整，首先，利用乘法节点，将其范围增大到1以上，接着在利用subtract节点规范它的范围到0-1之间：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103621.png" alt="image.png"></li><li>我们可以肉眼直观地看到它的变化，接下来，我们依然要解决它数值相反的问题，所以使用1-x节点，调整它的数值范围，最后得到正确的效果。</li><li>我们可以利用我们得到的效果，制作一个晕影图片！</li><li>导入一张外部贴图，连接到一个新建的乘法节点上，并将1-x节点的输出连到这个乘法节点上：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104047.png" alt="image.png"></li><li><strong>同样的</strong>，我们也可以对其增加一些外部数据调整的节点，让这个材质更加具备一个材质应该有的属性！</li></ul><h1 id="角度渐变"><a href="#角度渐变" class="headerlink" title="角度渐变"></a>角度渐变</h1><ul><li>接下来是一个小难点，角度渐变</li><li>角度渐变的分析拆解：<ul><li>角度渐变实际上是根据角度的变化，渐变的颜色逐渐变化，也就是在一个圆（2π）的变化范围内，数据从0-1变化的过程，本质上与前两个渐变没有区别，难点在于它涉及到了一定的三角函数运算：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104626.png" alt="image.png"></li><li>不过我们依然可以对其进行分析，只要细心拆解，就不会有无法实现的效果，本篇略长，希望大家耐心学习，争取有所收获</li></ul></li><li>角度渐变的实现(UE):</li><li>首先，万变不离其宗，我们依然创建UV节点，同时分离UV方向，当然你也可以尝试不分离，并思考其中的关系，我们这里使用掩码Mask节点来分离UV：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105251.png" alt="image.png"></li><li>不同的是，我们需要对UV坐标进行数值上的调整，之前的调整方式有些麻烦了，我们可以通过一个高级节点来简化这个过程，但本质依旧还是一样的，只不过是一个上层的封装罢了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105422.png" alt="image.png"></li><li>这个节点可以接受四个数值，分别是原始的minMax值，和想要转换的max和min值，就可以将其变为对应数值范围的数据，随后，我们将其分别输出到一个关键节点arctan节点，它是我们实现这个效果的关键，从数学角度分析如下图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008115714.png" alt="image.png"></li><li>因此，我们得到的范围为从-π&#x2F;4到π&#x2F;4，也就是能看到的变化范围为45°,但实际上，ue中颜色变化范围是0-1，而45°还未达到上限，因此实际上我们看见的结果并非45度，而我们可以通过除法变化该图像范围</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008141113.png" alt="image.png"></li><li>该图实际显示的其实是-π到π，但实际上是0到2π所以如果我们将整个结果同时除以2π，最后我们将得到一个0-1范围的变化，而如果我们除以π，则是-1到0，0到1的变化，这里ue改变了原本数学的值域范围将它变为了-π到π的显示，而实际数值计算中却有所不同</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——4</title>
      <link href="/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/"/>
      <url>/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/</url>
      
        <content type="html"><![CDATA[<h1 id="数据维度的控制"><a href="#数据维度的控制" class="headerlink" title="数据维度的控制"></a>数据维度的控制</h1><ul><li>在UE中，我们可以利用一些节点来进行数据的拆分与提升，例如在UV方向上，我们就可以利用掩码节点Mask来进行通道的拆分，如下图所示，我们将原本的UV节点拆分为R(U)通道以及G(V)通道：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184403.png" alt="image.png"></li><li>同样，我们也可以利用节点将他们合并起来，对于合并输出节点Ue提供了基础的Append节点以及封装多个Append节点从而实现多个输入的MakeFloat系列节点，他们都可以接受两个以上的参数并将他们合并输出：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184606.png" alt="image.png"></li></ul><h1 id="色彩维度的控制"><a href="#色彩维度的控制" class="headerlink" title="色彩维度的控制"></a>色彩维度的控制</h1><ul><li>UE中图片的色彩控制有以下几种：<ul><li>Add节点的加法调节</li><li>Multiply节点的乘法调节</li><li>Power节点的乘方调节</li><li>CheapContrast与CheapContrastRGB的灰度和对比度调节</li><li>以及1-x节点的取反调节<br>  我们逐一进行介绍</li></ul></li></ul><hr><h2 id="ADD节点"><a href="#ADD节点" class="headerlink" title="ADD节点"></a>ADD节点</h2><ul><li>首先是Add节点，这一节点主要功能就是为原图像加上一个常量，因为图像输入的是RGBA通道值，就会为这些值加上一个量，如果大于1，则会为白色，这与我们之前了解的相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001194813.png" alt="image.png"></li></ul><hr><h2 id="Multiply节点"><a href="#Multiply节点" class="headerlink" title="Multiply节点"></a>Multiply节点</h2><ul><li>随后是Multiple节点，这一节点可以在原有通道的基础上，乘上一个常量，如果常量小于1，则会让整体变暗，大于一则变亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203147.png" alt="image.png"></li></ul><hr><h2 id="Power结点"><a href="#Power结点" class="headerlink" title="Power结点"></a>Power结点</h2><ul><li>再之后是Power节点，POW节点是指数节点，可以让原来的值乘以n次方，会让暗的地方更暗，亮的地方更亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203430.png" alt="image.png"></li></ul><hr><h1 id="CheapContrast以及RGB"><a href="#CheapContrast以及RGB" class="headerlink" title="CheapContrast以及RGB"></a>CheapContrast以及RGB</h1><ul><li>这两个节点分别是针对单通道的灰度调节节点以及针对三通道的对比度节点，实际区别就是接受的数据不一样，本身都是调节黑白灰关系的节点，为了让图片对比度更加明显：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203647.png" alt="image.png"></li></ul><hr><h2 id="1-x节点"><a href="#1-x节点" class="headerlink" title="1-x节点"></a>1-x节点</h2><ul><li>这个节点是为了取反操作而诞生的，本质上就是统一进行一个偏移，也就是减去1，这样图片的整体输出就截然相反了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204112.png" alt="image.png"></li></ul><hr><h1 id="一些额外的注意点"><a href="#一些额外的注意点" class="headerlink" title="一些额外的注意点"></a>一些额外的注意点</h1><ul><li>在上文提到POWER节点与CheapContrast节点都能让暗部更暗亮部更亮，而它们之间有什么区别呢？</li><li>答案是，他们的作用区间不一样，前者是在0-1之间，而后者则是以0.5为中间值进行变换，我们实践就会发现，结果就是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204718.png" alt="image.png"></li></ul><hr><h1 id="UV的运算"><a href="#UV的运算" class="headerlink" title="UV的运算"></a>UV的运算</h1><ul><li>UV节点可以控制一个纹理的缩放，本质是调整一个纹理的坐标位置，而模型的UV则与之无关，就好比UV是皮肤而纹理坐标是衣服，UV节点调整的是怎么穿这件衣服。</li><li>UV节点有几个重要参数：<ul><li>U方向偏移量</li><li>V方向偏移量</li><li>解除镜像U</li><li>解除镜像V</li></ul></li></ul><h2 id="U，V方向偏移量"><a href="#U，V方向偏移量" class="headerlink" title="U，V方向偏移量"></a>U，V方向偏移量</h2><ul><li>这两个参数控制的实际上是UV数值的大小，视觉上的效果就是UV相较于模型坐标的缩放大小，比如若增大UV的坐标，那么多出来的部分（因为UV本是0-1）就会平铺填充同样的图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214316.png" alt="image.png"></li><li>我们可以用ADD节点或Multiply节点来控制这个过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214413.png" alt="image.png"></li></ul><h2 id="U-V方向镜像解除"><a href="#U-V方向镜像解除" class="headerlink" title="U,V方向镜像解除"></a>U,V方向镜像解除</h2><ul><li>本质上，我们通过UV节点调节的纹理，是以0.5为中心调节的，若解除这一镜像，我们就会得到从0.5开始的纹理图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214651.png" alt="image.png"></li><li>上面的图像就是画面的下四分之一，也就是上端为0.5，左端为0.5的方式，这可以帮助我们进行一些的运算</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——3</title>
      <link href="/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/"/>
      <url>/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/</url>
      
        <content type="html"><![CDATA[<h1 id="数据是基础"><a href="#数据是基础" class="headerlink" title="数据是基础"></a>数据是基础</h1><ul><li>在Ue中，一切引擎中，一切都是由数据构成的。</li><li>Ue中最上层数据为四通道数据，即RGBA</li><li>数据代表颜色一样可以代表法线方向等等其他含义</li></ul><h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>本质都是向量的运算</li><li>一位数据因为是一个常量因此是可以与任意数据进行乘除法运算的</li></ul><hr><h1 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h1><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><ul><li>在Ue中基础颜色的色彩范围是0-1，它是根据输入值计算的，如果大于1则为1，小于0则为0.</li><li>而自发光颜色是可以无限增加的，直到照亮整个场景（配合虚幻五特有的Luman全局光照系统）</li></ul><hr><h2 id="色彩运算"><a href="#色彩运算" class="headerlink" title="色彩运算"></a>色彩运算</h2><h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><ul><li>前文提到，一切颜色依然是由数据组成的，因此我们同样可以通过向量运算来计算颜色：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090525.png" alt="image.png"></li><li>Ue中的颜色计算使用了与现实世界颜料不同的减色法，即模拟自然光是由白光分出的红绿蓝三色光。</li><li>上图的运算我们可知，白色对应RGB通道值为（1,1,1）,这也对应了前文提到色彩范围是0-1</li><li>除法运算同理</li></ul><hr><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><ul><li>乘法运算是根据向量基础进行的运算，如果将上图中的红色通道与绿色通道相乘，那么结果为0，自然会显示黑色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090932.png" alt="image.png"></li><li>而白色为（1,1,1）,那么它与任何颜色相乘，仍为该颜色</li></ul><hr><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><ul><li>在除法运算之中，如果除数为0，则会保存一个有效值，若全为0 则会不进行这个运算，同样返回原有值，但不建议这样做！任何情况下！</li></ul><hr><h1 id="纹理图像的运算"><a href="#纹理图像的运算" class="headerlink" title="纹理图像的运算"></a>纹理图像的运算</h1><ul><li>纹理图像是一个一个数组，它们同样可以进行加减法运算，因为本质都是向量组成的，这也被称为矩阵。</li></ul><h2 id="图像的加减法运算"><a href="#图像的加减法运算" class="headerlink" title="图像的加减法运算"></a>图像的加减法运算</h2><ul><li>这里我们通过PS来进行观察：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092206.png" alt="image.png"></li><li>这里我们设置了线性减淡添加，这本事就是一种相加算法，它会让图片越来越亮</li><li>反之如果我们使用相减运算，那么就会让图片越来越暗</li></ul><hr><h2 id="图像的乘除法"><a href="#图像的乘除法" class="headerlink" title="图像的乘除法"></a>图像的乘除法</h2><ul><li>在Ps中，乘法被称为正片叠底，因为是乘法，如果黑色部位乘上一个不为黑色的部位，那么就会让图片变暗，并且保留黑色部分。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092704.png" alt="image.png"></li><li>PS中，除法运算的方式叫做划分，它会根据图像的乘除关系，让图片变亮抑或是变暗，取决于除数与被除数的大小关系</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093000.png" alt="image.png"></li></ul><hr><h2 id="偏差比例运算"><a href="#偏差比例运算" class="headerlink" title="偏差比例运算"></a>偏差比例运算</h2><ul><li>这是一种组合运算，先加上一个值再乘上一个值，相当于先进行加法运算，再进行乘法运算</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093835.png" alt="image.png"></li></ul><hr><h2 id="线性插值运算"><a href="#线性插值运算" class="headerlink" title="线性插值运算"></a>线性插值运算</h2><ul><li>本质上是一种混合运算，可以通过调节Alpha输入的值来控制线性插值的结果。我们同样可以通过输入某一个纹理的Alpha值来控制。</li><li>一般Alpha通道值需要一个一维向量为参数，我们可以通过Clamp或saturate节点来限制范围，后者在UnityShader中就很常见，它的系统损耗最低，我们一般倾向于使用它作为限制数值范围的工具，但它的范围只有0-1这一个固定参数范围，而前者clamp可以接受我们自主定义：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930094924.png" alt="image.png"></li><li>混合节点最好使用Saturate节点控制，这样可以减少性能损耗！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——2</title>
      <link href="/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
      <url>/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h1><ul><li>长宽必须是2的幂数，并且上线不超过8192，当然也可以导入不符合该标准的纹理，但这样Ue就无法为我们生成MIPMAP了。</li><li>简单来说，MIPMAP就是为我们生成一系列的图片，让我们在场景中根据距离远近智能调节纹理质量，以此来降低性能开销的一种手段，同样的手段为LOD，只不过后者是只能调节物体面数的，在UE中更为强大的Nanite系统将同时为我们做到以上两点。</li></ul><h1 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h1><ul><li><p>Ue支持很多纹理格式，例如psd，tga等，这两者也是最常用的无损格式之一</p></li><li><p>Ue支持一种叫做3Dtexture的贴图，它可以通过直接在内容窗口中创建得到，下面是它的原理图：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240929200955.png" alt="image.png"></p></li><li><p>一般用于特效制作</p></li><li><p>虚拟纹理：虚拟纹理是Ue所具有的一种动态加载纹理的功能，同样可以减少性能开销，它可以智能加载所需要的贴图，不加载看不见的贴图，从而减少开销。</p></li><li><p>虚幻同样支持由SD导入纹理材质球</p></li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>默认导入状态下，纹理会被压缩为DXTC或BC格式，而B8G8R8A8或G8表示未压缩，HDR格式纹理的FloatRGBA也不会压缩纹理。</li><li>Ue具备一种特有的纹理压缩模式，称为Oodle，是一种高效快捷的纹理编码，它有多层线性级别，通过控制<code>Lambda</code>值来调节压缩级别，一般<code>Lambda</code> &#x3D; 1为最优秀</li><li>详细可以参考Ue官方文档：</li><li><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/">https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/</a></li><li>请注意在移动端中暂时无法使用该选项</li></ul><h1 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h1><ul><li>创建材质实例可以帮助我们快速的调整场景中已有材质物体的材质属性，类似于类的对象这一概念</li><li>我们可以通过将纹理贴图等节点暴露为参数，从而在实例化的材质中自定义调节，它不会影响我们父材质的效果</li><li>SwitchParam节点可以帮助我们设置默认参数与自定义参数，如果打开实例节点中的对应选项就可以调节输入，并且取代我们的默认参数值，关闭则可恢复默认</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——1</title>
      <link href="/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/"/>
      <url>/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="材质编辑器"><a href="#材质编辑器" class="headerlink" title="材质编辑器"></a>材质编辑器</h1><ul><li>材质编辑界面主要由几部分组成，分别是材质图标，节点表，材质属性表，和各类操作面板：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220416.png" alt="image.png"></li><li>类似于Blender的原理化BSDF节点，一开始就会存在的是右侧的输出节点</li><li>我们需要通过连线的方式，将节点连接到对应的输出端口上</li><li>在操作完成后，我们需要进行保存和应用，这些操作全部在上方的材质编辑器的操作面板上完成</li></ul><hr><h1 id="一些常用的材质节点"><a href="#一些常用的材质节点" class="headerlink" title="一些常用的材质节点"></a>一些常用的材质节点</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220757.png" alt="image.png"></li><li>以上是一些常用的基础材质节点，分别是：<ul><li>1+左键： 常量节点，用于输入一个常量</li><li>2+左键： 一个二维向量节点，用于输入一个二维向量</li><li>3+左键：一个三维向量节点，可以看到对应的RGB值，输入一个三维向量</li><li>M+左键：乘法，接受两个常量输入，输出他们相乘的结果</li><li>T+左键：输入一个材质，可以选择一个图像，输出RGB或其他选项</li></ul></li><li>还有更多的节点可以通过右键呼出搜索面板来进行搜索，与blender shift+a类似</li></ul><hr><h1 id="常用的输出端简介"><a href="#常用的输出端简介" class="headerlink" title="常用的输出端简介"></a>常用的输出端简介</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928221546.png" alt="image.png"></li><li>根据我们选择着色模型的不同，也会有对应的不同的输出端口，但常用的基本一致，比如作为颜色信息的基础颜色，控制粗糙度的粗糙度端口。以下是逐项的介绍</li></ul><h2 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h2><ul><li>类似于UnityShader中的Color Tint，是作为基本的输出颜色存在的，决定了材质视觉上的呈现，往往直接可以连接一张Texture</li></ul><h2 id="金属感"><a href="#金属感" class="headerlink" title="金属感"></a>金属感</h2><ul><li>取值为0-1，所有的导电物体都应该具备的属性，可以让视觉上材质呈现出金属质感，类似于哑光质感。</li></ul><h2 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h2><ul><li>取值为0-1，类似于UnityShader中的_Gloss属性，用于控制高光的大小</li></ul><h2 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h2><ul><li>取值为0-1，用于控制物体的粗糙程度，可以接受Texture输入，类似于diffuse与Specular的混合程度，0即为100%Specular，1即为100%diffuse</li></ul><h2 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h2><ul><li>用于控制高光反射的形状，底层逻辑是一张采样的贴图</li></ul><h2 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h2><ul><li>用于控制物体自发光强度，数值越大发光强度越高，在UE中可以照亮周围的物体</li></ul><h2 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h2><ul><li>取值为0-1，用于控制物体可见性的数值，本质依然是不透明度混合的结果，这个数值就是可以对其的范围进行调节。可参考UnityShader中不透明效果的代码实现</li></ul><h2 id="不透明蒙版"><a href="#不透明蒙版" class="headerlink" title="不透明蒙版"></a>不透明蒙版</h2><ul><li>不透明蒙版可以做出类似PS中剪贴蒙版的作用，可以对有A通道的照片素材进行裁切，并且让场景中的面片跟随变化轮廓</li></ul><h2 id="法线与切线"><a href="#法线与切线" class="headerlink" title="法线与切线"></a>法线与切线</h2><ul><li>经常用作制作物体表面凹凸质感，在UnityShader中，可以在切线空间下计算法线贴图也可以在世界空间计算，美术更喜欢前者，因为可以清晰判别模型的各个视觉方向。</li></ul><h2 id="全局位置偏移"><a href="#全局位置偏移" class="headerlink" title="全局位置偏移"></a>全局位置偏移</h2><ul><li>移动模型位置，更多用于动态效果的创建</li></ul><h2 id="次表面颜色"><a href="#次表面颜色" class="headerlink" title="次表面颜色"></a>次表面颜色</h2><ul><li>需要配合次表面着色模型开启，开启后可以实现透光效果</li></ul><h2 id="折射与像素深度偏移"><a href="#折射与像素深度偏移" class="headerlink" title="折射与像素深度偏移"></a>折射与像素深度偏移</h2><ul><li>前者多为玻璃材质所需，后者则是软化模型交界处质感</li></ul><hr><h1 id="渲染模式与着色模型"><a href="#渲染模式与着色模型" class="headerlink" title="渲染模式与着色模型"></a>渲染模式与着色模型</h1><ul><li><p>在UE中一共有六种材质域，数种着色模型：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928223722.png" alt="image.png"></p></li><li><p>许多与Unity共同的特点，只不过有更好的封装进而有更便捷的实现。例如混合模式就是UnityShader中的Blend关键字，可以很容易的进行混合模式的开启，从而渲染半透明等材质</p></li><li><p>同样，着色模型也为我们提供了实现某些渲染效果更轻松的实现，这些都是UE为我们进行的优化。</p></li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>这一节，我们初步认识了UE的材质编辑界面，简单来说，就是利用可视化节点的方式代替code编辑从而便捷的实现效果，但请记住，本身仍然是一个个函数实现，因此结合Shader代码的学习必不可少！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——2</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的语言—二进制"><a href="#计算机的语言—二进制" class="headerlink" title="计算机的语言—二进制"></a>计算机的语言—二进制</h1><ul><li>计算机内部都是由IC（集成电路）组成的，它们只具有两种状态，&#x3D;&#x3D;高电平和低电平&#x3D;&#x3D;，这个特性决定了计算机的数据只能以二进制来处理。</li><li>计算机处理的最小单位：位，就相当于二进制中的一位，也叫做bit。</li><li>八位二进制数被称为一个字节，字节(byte)是基本信息计量单位，是基本单位。</li><li>再用字节处理数据时，&#x3D;&#x3D;如果数字小于存储的字节数&#x3D;&#x3D;，那么高位就用0占位填补。</li><li>&#x3D;&#x3D;二进制数可以表示文字&#x3D;&#x3D;，&#x3D;&#x3D;图像等&#x3D;&#x3D;，其表示的内容取决于程序的编写方式。</li></ul><h1 id="二进制数的计算"><a href="#二进制数的计算" class="headerlink" title="二进制数的计算"></a>二进制数的计算</h1><ul><li>二进制数的本质就是逢二进位，那么它与十进制的转化就是用每一位的数字乘以它的位权。位权的意思就是基数的对应位数指数。  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417094555.png">  指数由第一位开始向左累加。</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>移位运算是指将二进制数值个数为进行左右的移位。&#x3D;&#x3D;移位有左移&#x3D;&#x3D;，&#x3D;&#x3D;右移两种&#x3D;&#x3D;。 <ul><li>运算符：&lt;&lt;被称为左移运算符，&gt;&gt;被称为右移运算符，两者的左侧是被移位值，右侧是要移位的位数。</li><li>左移：左移空出的低位要进行补0操作。<br>  移位可以重来充当乘除法运算，左移两位数值会变为原来的4倍。</li><li>右移：二进制中表示负数值时，&#x3D;&#x3D;会将最高位当作符号位来使用&#x3D;&#x3D;，如果最高位为0则为正数，反之为1则为负数。<br>  这就区分了有符号数和无符号数，有符号数就是有符号位的数</li><li>补数：因为计算机实际上是在做加法运算来进行减法。![[计算机底层结构——1#^3cacdc]]<br>  获得补数的方式就是将全部数位取反再加1，补数与原来的数字之和为0，这很像是相反数。</li></ul></li><li>计算机中，0包含在正数范围内，所以负数要比真正的正数多一个。</li></ul><h2 id="逻辑右移与算术右移"><a href="#逻辑右移与算术右移" class="headerlink" title="逻辑右移与算术右移"></a>逻辑右移与算术右移</h2><ul><li>逻辑右移： 当二进制数的值表示图形模式而非数值时，移位后就需要在最高位前补0</li><li>算术右移：移位后需要在最高位前填充移位前的符号位的值，比如若为0，则需要填充1，反之亦然。</li></ul><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><ul><li>在保持值不变的情况下，将原有的低位数转化为高位数，直接用符号位填充前面的所有位数。</li></ul><h2 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h2><ul><li>逻辑非：1变0,0变1的取反操作</li><li>逻辑与：两者同时为1时，结果为1</li><li>逻辑或：至少一方为1时，结果为1。</li><li>逻辑异或：排斥相同，相同为0不相同为1</li></ul><h1 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h1><ul><li>在使用二进制存储数据时，我们往往会出现大量的数据，而如何简化其表示，以便操作，就是我们要考虑的问题，因此，&#x3D;&#x3D;我们出现了将二进制转化为8进制甚至16进制的操作&#x3D;&#x3D;。</li></ul><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><ul><li>八进制是二进制的简化表示，每位八进制数对应三位二进制数<br>  <code>二进制 001 = 八进制 1  </code>二进制010  &#x3D;  八进制2</li></ul><h2 id="二进制转化为八进制"><a href="#二进制转化为八进制" class="headerlink" title="二进制转化为八进制"></a>二进制转化为八进制</h2><ul><li>将二进制三位一组分开，每三位表示八进制数一位</li><li>如1011101 按三位一组分组 001，011，101(注意，高位是00可以直接省略)</li><li>对应八进制数135</li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><ul><li>16进制数分为0，T，2，3，4，5，6，7，8，9，A，B，C，D，E，F</li><li>每位十六进制数对应四位二进制数</li><li><code>二进制0000 = 十六进制0</code><br>  <code>二进制0001 = 十六进制1</code><br>  <code>二进制1111 = 十六进制F</code></li></ul><h2 id="二进制转化为十六进制"><a href="#二进制转化为十六进制" class="headerlink" title="二进制转化为十六进制"></a>二进制转化为十六进制</h2><ul><li>将二进制数每四位一组进行分割，每组对应一位十六进制数</li><li>如二进制数11011010四位一组为1101,1010<br>  对应十六位数DA</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——1</title>
      <link href="/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/"/>
      <url>/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul><li><p>CPU是集成了&#x3D;&#x3D;控制器，运算器，寄存器，时钟&#x3D;&#x3D;的终端，它负责将我们的&#x3D;&#x3D;汇编语言&#x3D;&#x3D;解释为&#x3D;&#x3D;机器语言&#x3D;&#x3D;，从而供底层微处理器执行。他们通过&#x3D;&#x3D;总线&#x3D;&#x3D;相互连接，传递数据和指令。</p><ul><li><strong>寄存器</strong>：用于&#x3D;&#x3D;暂存指令&#x3D;&#x3D;，&#x3D;&#x3D;等对象&#x3D;&#x3D;。是内存的一种</li><li><strong>控制器</strong>：负责将内存上的指令数据&#x3D;&#x3D;读入寄存器&#x3D;&#x3D;并依据结果&#x3D;&#x3D;控制整个计算机&#x3D;&#x3D;，主要是输入输出时间的控制。</li><li><strong>运算器</strong>：负责运算寄存器中的数据，并把结果输出。</li><li><strong>时钟</strong>：发出CPU开始计时的时钟信号。（&#x3D;&#x3D;信号频率越高，CPU运行越快&#x3D;&#x3D;）</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><strong>内存</strong>指的是计算机的主存储器，负责存储指令和数据。&#x3D;&#x3D;每个字节都有一个地址编号&#x3D;&#x3D;，cpu通过它来读取指令与数据。</li></ul><h1 id="CPU与寄存器"><a href="#CPU与寄存器" class="headerlink" title="CPU与寄存器"></a>CPU与寄存器</h1><ul><li>CPU是寄存器的集合体，程序将寄存器作为对象来描述。</li><li><strong>汇编</strong>：指的是将汇编语言转化为机器语言。</li><li>寄存器种类多样：比如有&#x3D;&#x3D;程序计数器&#x3D;&#x3D;，&#x3D;&#x3D;标志寄存器&#x3D;&#x3D;，累加寄存器，&#x3D;&#x3D;基址寄存器&#x3D;&#x3D;，&#x3D;&#x3D;变址寄存器&#x3D;&#x3D;等。</li></ul><h1 id="寄存器与程序执行"><a href="#寄存器与程序执行" class="headerlink" title="寄存器与程序执行"></a>寄存器与程序执行</h1><ul><li><strong>寄存器</strong>中的<strong>程序计数器</strong>被赋予了分配程序执行顺序的能力。当硬盘中的文件被复制到内存后，程计会被&#x3D;&#x3D;设定为初始值0100&#x3D;&#x3D;，然后开始运行，&#x3D;&#x3D;每当&#x3D;&#x3D;CPU执行完一个指令，程计中的数值都会进行&#x3D;&#x3D;累加&#x3D;&#x3D;操作。CPU会按照程计的数值，从内存中读取命令并执行。</li><li><strong>循环，顺序，条件分支</strong>：这三种执行方式组成了程序的流程。<ul><li><strong>条件分支</strong>：如果在程序执行的过程中，需要有条件分支语句，那么在程计中，遇到这个语句，&#x3D;&#x3D;会将程计的数值设置为对应的地址数值&#x3D;&#x3D;，这个操作被称为&#x3D;&#x3D;jump&#x3D;&#x3D;。</li></ul></li></ul><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417091436.png" alt="Pasted image 20240417091436"></p><ul><li><p><strong>&#x3D;&#x3D;标志&#x3D;&#x3D;寄存器</strong>：标志寄存器主要的作用为将累加寄存器中的结果&#x3D;&#x3D;状态&#x3D;&#x3D;进行记录，比如正负奇偶都会将其进行保存。所以在条件分支前，由其判断是否进行jump。标志寄存器&#x3D;&#x3D;前三个字节分别表示正0负三种状态&#x3D;&#x3D;。</p></li><li><p>标志寄存器的判断，实际上是对数值进行&#x3D;&#x3D;减法&#x3D;&#x3D;运算，通过结果设定状态。 ^3cacdc</p></li><li><p><strong>函数的调用</strong></p><ul><li>函数在调用时，在程计中会存在一个&#x3D;&#x3D;函数调用点&#x3D;&#x3D;。</li><li>call，return指令：call指令在函数入口地址设定到程计前，会把&#x3D;&#x3D;函数调用后&#x3D;&#x3D;要执行的地址存储在栈中。<br>  栈相关：[[内存与数据类型#栈]]<br>  函数处理完后，在通过函数出口来执行&#x3D;&#x3D;return&#x3D;&#x3D;指令，将栈中的地址设定到程计中。</li></ul></li><li><p>基址寄存器与变址寄存器：通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似数组的操作。数组相关：[[数组部分]] </p><ul><li>CPU会将基址寄存器和变址寄存器中的&#x3D;&#x3D;值之和&#x3D;&#x3D;视作实际要去查看的内存地址。变址寄存器相当于&#x3D;&#x3D;数组索引功能！&#x3D;&#x3D;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——0</title>
      <link href="/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/"/>
      <url>/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><ul><li><p>何为计算机？</p><ul><li>计算机是执行输入，计算，输出的机器</li></ul></li><li><p>何为程序？</p><ul><li>程序是指令与数据的集合</li></ul></li><li><p>何为计算机的处理方式？</p><ul><li>计算机的处理方式与人类习惯不同</li></ul></li><li><p>计算机由软硬件共同组成</p></li></ul><h2 id="输入，运算与输出是硬件基础"><a href="#输入，运算与输出是硬件基础" class="headerlink" title="输入，运算与输出是硬件基础"></a>输入，运算与输出是硬件基础</h2><ul><li>计算机硬件由大量IC（集成电路）组成</li><li>IC上有很多引脚，有的用于输入有的用于输出，IC会在内部运算输入的信息，并把结果输出。</li><li>所有的计算机操作都归于输入计算与输出缺一不可</li></ul><h2 id="软件是指令与数据的集合"><a href="#软件是指令与数据的集合" class="headerlink" title="软件是指令与数据的集合"></a>软件是指令与数据的集合</h2><ul><li><p>所有的操作都是基于一条一条指令</p></li><li><p>一组指令可以成为<strong>函数，方法，语句</strong>等等。程序中的数据分为两类，一类作为指令执行对象的输入数据，另一类是输出数据。</p></li><li><p>我们将数据称为<strong>变量</strong> 。</p></li><li><p>正如数学中的函数概念一样，往往我们都将程序中的方法写作：<br>  <code>y = f(x)</code></p></li><li><p>其中x为输入数据，这表示将x输入到函数y中</p></li><li><p>在程序中可能是这个样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> answer = a+b+c/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序会通过编译（见1）将我们所写的高级语言代码转换成机器能看懂的机器语言代码。这会是一系列数值，它们既包含指令同样也包含数据。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240914112937.png" alt="image.png"></p></li></ul><h2 id="对于计算机来说什么都是数字"><a href="#对于计算机来说什么都是数字" class="headerlink" title="对于计算机来说什么都是数字"></a>对于计算机来说什么都是数字</h2><ul><li>计算机将一切都当作数字对待，最基础的可能是单纯的数字加减，但同样也可以是图片，音乐等等。</li></ul><h1 id="计算机组成简介"><a href="#计算机组成简介" class="headerlink" title="计算机组成简介"></a>计算机组成简介</h1><ul><li>计算机主要有CPU，内存和I&#x2F;O组成</li><li>CPU负责对数据运算和控制内存I&#x2F;O</li><li>内存负责存储CPU需要的指令与数据</li><li>I&#x2F;O则负责把键盘鼠标显示器等与主机连接实现数据的输入与输出</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>作为向美术等非专业人员介绍计算机相关内容的第一篇，诚惶诚恐，但愿能解答一些大家的疑惑，帮助大家更好的工作，本文会在后续持续跟进更改！感谢大家</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ul><li>计算机是怎样跑起来的（矢泽久雄）</li><li>程序是怎样跑起来的(矢泽久雄)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
