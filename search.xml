<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客搭建感想</title>
      <link href="/2025/01/12/hello-template/"/>
      <url>/2025/01/12/hello-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><ul><li>本地化部署流程</li><li>线上发布流程</li></ul><hr><h2 id="本地化部署"><a href="#本地化部署" class="headerlink" title="本地化部署"></a>本地化部署</h2><ul><li>前期准备<ul><li>首先，本地化部署需要提前安装好两个东西，<br>可参考hexo框架官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>需要下载node.js，同时下载npm，也就是版本管理器，这些可以帮助我们管理博客版本内容。<ul><li>node.js 官网：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>你可以直接在官网复制它的代码并且打开本地自带的Windows命令窗口：powershell，粘贴你复制的代码</li><li>等待安装完成就可以了</li></ul></li><li>下载git，git主要作用是建立起云端和本地之间的桥梁，让我们能够从云端拉取数据。<ul><li>同样可以在官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a> </li><li>git安装相对简单，你可以直接全部选择next就自动安装完成了，很无脑！</li></ul></li><li>在安装完成后，本地的环境就基本上搭建完成了。</li></ul></li></ul><h2 id="线上发布："><a href="#线上发布：" class="headerlink" title="线上发布："></a>线上发布：</h2><ul><li>首先访问：<a href="https://github.com/mmdjiji/hexo-template">https://github.com/mmdjiji/hexo-template</a> 获取该库的代码，并且由此新建一个库，<br>详细教程可参考：<a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&vd_source=a506bd54314456e886d3818e488bb1c8">https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&amp;vd_source=a506bd54314456e886d3818e488bb1c8</a></li><li>断点发生在使用spacecode编辑处，因为该方法是完全基于云端的部署，所以完全依赖虚拟机的网速<br>然而经过多方验证，虚拟机网速堪忧，因此在此我们选择在本地部署！</li></ul><h2 id="独家揭秘！"><a href="#独家揭秘！" class="headerlink" title="独家揭秘！"></a>独家揭秘！</h2><ul><li>本地化部署就是本教程独一无二之处，大部分教程都会将两者割裂，但本教程才是最无脑的过程，<br>前文我们已经提到，云端部署十分缓慢，那有没有办法加快这个速度呢？</li><li>答案当然是有的！我们可以利用githubdesktop更快捷的进行上传与下载，避免云端网速的问题！</li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><ul><li>首先，下载githubdesktop，这个在你的库里local选项就能下载，为了方便起见，本文还是给大家配图</li><li>配图使用PicGo，同样也会给大家介绍，并且介绍obsidian中的PicGo联动小功能！</li></ul>  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20111142.png">   * 下载安装完成后，我们就可以将线上的库克隆到本地了，这里各位自行摸索即可，很简单，就不再赘述  ### 在bush窗口中完成部署    * 克隆完成后，我们需要再本地进行编辑，首先，找到克隆库所在本地文件夹，在文件夹中右键   * 打开选项栏，选择open git bush here   * 然后我们就嫩得到一个这样的窗口，很好，你已经几乎要完成它了！  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912111820.png">   * 随后，我们需要先安装hexo框架，在对话框中输入：   `$ npm install -g hexo-cli `   * 等待安装完成，在这里你可以加速这个过程，可将上述代码替换为：   `$ cnpm install -g hexo-cli`   * 这是一个国内镜像，但前提是你需要下载它，你可以通过powershell输入：   `npm install -g cnpm --registry=https://registry.npmmirror.com `   下载完成后，之后的所有需要npm的代码就都可以用cnpm替换了   * 之后我们继续键入`cnpm install`来安装依赖，请确保你进行了上一步！   * 在此之后，我们就完成了全部部署，你可以输入`hexo g`来检测部署结果   * 注意！按此方式部署的hexo是局部的，所以需要输入`npx+hexo...`命令！注意区分   * 若如图所示，则说明部署完成：  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912112800.png">   * 请注意，上图中，butterfly字样是主题，若未安装是不会显示的，这无伤大雅。  ### 配合github上传   * 第一阶段我们的githubdesktop就排上用场了，你只需要在面板中点击commit，   * 随后点击push origin 上传到云端即可了，返回到github库主页面，点击setting，查看page页面更新消息，你可以按F5刷新页面，不过多久，一个网站就搭建好了，并且你可以在本地完全控制它！---# 结尾   * 这是我的第一篇真正的博客，讲解了如何优雅而简便的搭建一个你的博客，接下来我会更新后续的内容，包括技术美术全部相关学习心得，笔记，随笔，图形学系列课程，希望能共同学习交流，那么最后一步！   * push to origin！---# 参考链接与项目 * 1.hexo官网：https://hexo.io/zh-cn/ * 2.b站up主：方欲遣兵北逐胡的视频：【基于Hexo搭建本地博客并部署到云服务器教程】 https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4 * 3.b站up主：吉吉学长的视频：【【Hexo | 03】创建属于你的追番列表】 https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4 * 全部为开源项目，不承担任何责任！！]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学6——渲染管线综述</title>
      <link href="/2024/12/21/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A66%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/12/21/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A66%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-什么是渲染管线（渲染流水线）"><a href="#6-1-什么是渲染管线（渲染流水线）" class="headerlink" title="6.1 什么是渲染管线（渲染流水线）"></a>6.1 什么是渲染管线（渲染流水线）</h1><ul><li><strong>渲染管线</strong>或称<strong>渲染流水线</strong>实际上描述的就是存在在计算机内存中的数据<strong>如何渲染呈现在屏幕上的过程。</strong> 当下的大多数主流的设备终端都支持的一系列操作的总称，接下来我们将为各位分享详细的渲染流程，以及管线综述。</li></ul><h2 id="6-1-1-什么是SHADER？"><a href="#6-1-1-什么是SHADER？" class="headerlink" title="6.1.1 什么是SHADER？"></a>6.1.1 什么是SHADER？</h2><ul><li>Shader是着色器，是可编程渲染管线的一部分，有一定的着色器，顶点着色器（vertex Shader），片元着色器（Fragment Shader ）等，我们可以通过Shader与GPU交流，控制渲染细节。主要分为可编程和可配置两类。</li></ul><h2 id="6-1-2-SHADER与Material的关系？"><a href="#6-1-2-SHADER与Material的关系？" class="headerlink" title="6.1.2 SHADER与Material的关系？"></a>6.1.2 SHADER与Material的关系？</h2><ul><li>Shader与贴图等资源组合起来得到Material，材质好比商品，Shader是加工方法，而贴图是原材料</li></ul><hr><h1 id="6-2-渲染管线的流程"><a href="#6-2-渲染管线的流程" class="headerlink" title="6.2 渲染管线的流程"></a>6.2 渲染管线的流程</h1><h1 id="6-2-1-渲染管线的三个主要阶段"><a href="#6-2-1-渲染管线的三个主要阶段" class="headerlink" title="6.2.1 渲染管线的三个主要阶段"></a>6.2.1 渲染管线的三个主要阶段</h1><ul><li>渲染管线就像工厂中的流水线，主要分为以下三个阶段<ul><li>应用阶段</li><li>几何阶段</li><li>光栅化阶段</li></ul></li><li>第一个阶段主要由CPU负责，而后两个阶段则由GPU负责</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240827220247.png" alt="imag.png"><br>              <code>6.2.1 渲染管线大致流程划分</code></li><li>应用阶段又可分为加载显存数据，加速算法，设置渲染状态，调用DRAWCALL。此部分由CPU负责，主要将应用软件里的数据整理调试，并最后打包发送给GPU。</li></ul><hr><ul><li>几何阶段可分为顶点变换（也就是我们之前所提到的MVP矩阵）裁剪，屏幕映射，这三个阶段，最终将渲染出来的图元存储在缓存（buffer）之中。此阶段对应的是<strong>曲面细分着色器和顶点着色器</strong></li><li>光栅化阶段则将上一阶段的数据进行三角形设置，遍历，传递给<strong>片元着色器</strong>。最后通过逐片元操作，进行一系列的测试，在将片元对应像素绘制到屏幕之上。</li><li>由此便完成了基本的图像绘制流程，下面是这些流程的详细介绍与具体应用。</li></ul><hr><h1 id="6-2-2-应用阶段"><a href="#6-2-2-应用阶段" class="headerlink" title="6.2.2 应用阶段"></a>6.2.2 应用阶段</h1><ul><li>应用阶段大致步骤</li><li>**准备场景数据</li><li>场景物体数据<ul><li>物体的**变换数据，位置，旋转等</li><li>物体的**网格数据，顶点位置，UV贴图等</li></ul></li><li>摄像机数据<ul><li>摄像机的**位置方向，远近裁剪平面</li><li>正交透视FOV</li><li>**视口比例大小尺寸</li></ul></li></ul><hr><ul><li>光源以及阴影数据<ul><li>光源**类型，位置方向，角度</li><li>是否需要阴影，判断是否有**能够投射阴影的物体</li><li>阴影参数，对应光源序号，**阴影强度，级联参数，</li><li>**深度偏移，近平面偏移等</li><li>逐光源绘制阴影贴图：<ul><li>近平面偏移</li><li>逐级联，计算当前**光源加级联对应的观察矩阵投影矩阵以及对应阴影贴图里的视口</li><li>绘制到阴影贴图</li></ul></li></ul></li><li>其他全局数据</li></ul><hr><ul><li>加速算法，颗粒度剔除<ul><li>碰撞检测</li><li>加速算法<ul><li>可见光裁剪</li><li>可见场景物体裁剪<ul><li>八叉树，BSP数，K-D树，BVH包围盒等</li></ul></li></ul></li><li>遮挡剔除</li></ul></li></ul><hr><ul><li>设置渲染状态，准备渲染参数<ul><li>绘制设置<ul><li>使用着色器</li><li>合批方式</li></ul></li><li>绘制顺序(Render Queue)<ul><li>相对摄像机的距离</li><li>UICanvas等（Unity举例）</li></ul></li><li>渲染目标(RenderTarget)<ul><li>帧缓存（FrameBuffer）</li><li>渲染纹理RenderTexture</li></ul></li><li>渲染模式(RenderMode）<ul><li>如ForwardBase等</li></ul></li></ul></li></ul><hr><h2 id="6-2-3-DRAWCALL与OpenGL，DX等"><a href="#6-2-3-DRAWCALL与OpenGL，DX等" class="headerlink" title="6.2.3 DRAWCALL与OpenGL，DX等"></a>6.2.3 DRAWCALL与OpenGL，DX等</h2><ul><li>我们常说的OpenGL与DirectX是什么东西呢？</li><li>这两种都是图形API，也就是图形接口，它是渲染硬件上的一层抽象，我们通过编写HLSL，GLSL&#x2F;CG来调用这些接口，它们将向显卡硬件驱动发动相关指令，由硬件驱动翻译并让硬件执行，我们向硬件发出的命令被称为DRAWCALL。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241101150457.png" alt="image.png"><br>                       <code>渲染操作的逻辑层次</code></li></ul><hr><ul><li>目前游戏中的着色器语言是针对多平台的，它会根据平台不同智能编译成对应的机器语言，并传递对应的信息，所以在游戏中经常会遇到“编译着色器”这个提示，比如黑神话中的这个开头，其实就是在将统一的着色器语言，翻译成对应API对应驱动程序版本的底层机器语言</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241101150738.png" alt="image.png"><br><code>6.2.3 黑神话的着色器编译中~</code></li><li>提个小问题，这部分的速度快慢主要依靠的指标是什么？</li></ul><hr><ul><li>DRAWCALL</li><li>这个步骤实际上就是CPU调用图像编程接口的过程，例如OpenGL中的glDrawElements命令，这也是造成性能瓶颈最大的原因所在。DrawCall中造成性能问题的根本不是GPU而是CPU，实际上，在渲染流程中，我们会在此构建一个缓冲区，它存储CPU发出的指令，由GPU读取，这样GPU快速的读取就不会因为CPU的缓慢而减速。</li></ul><hr><ul><li>我们要尽可能的优化渲染流程，因此DrawCall便是我们的一大优化目标，因为每次发送DrawCall指令，CPU都要向GPU发送大量信息，例如模型的顶点法线等参数，这就会大量消耗时间。</li><li>怎么优化DrawCall？我们可以有很多种方式，这里主要讨论批处理方式（Batching）</li><li>Batching实际上可以理解为打包，而DrawCall可以理解为提交。</li></ul><hr><ul><li>顾名思义，这个方法就是让我们将很多的小DrawCall打包成为一个大的命令，来向GPU传输，以此降低批量传输的损耗，但是打包同样需要耗费时间，因此我们只针对静态的物体进行这个操作</li><li>目前在实际引擎应用中，主要有四种优化方式，Static Batching ，Dynamic Batching ，GPU Instance ， SRP Batcher。</li><li>旧有的优化方式（StaticBatching静态批处理）：<ul><li>避免添加大量的很小的网格（但是Nanite可以帮我们解决这点）</li><li>避免添加大量的材质（但是虚拟材质可以帮我们解决这点）</li><li>以上的优化方式在如今都可以不被考虑，但初学时依然需要记忆他们！</li></ul></li></ul><hr><h2 id="6-2-4-几何阶段"><a href="#6-2-4-几何阶段" class="headerlink" title="6.2.4 几何阶段"></a>6.2.4 几何阶段</h2><ul><li>顶点着色<ul><li>视图变换</li><li>顶点着色</li></ul></li><li>这个阶段对应的着色器就是顶点着色器，主要处理的是顶点由模型空间变换到视图坐标系的一系列变换，也就是前文我们推导的MVP变换矩阵的前两部分</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008193638.png" alt="image.png"><br>         <code>6.2.4 顶点的坐标变换</code></li></ul><hr><ul><li>可选点处理<ul><li>曲面细分，通过插值增加顶点，实现曲面细分效果。</li><li>几何着色器，操作图元，操作多个顶点组成的图元以生成更多图元。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008193848.png" alt="image.png"><br>     <code>6.2.4.1 几何着色器</code></li><li>什么是片元，图元？</li><li>几何顶点被组合为图元（点，线段或多边形），然后图元被合成片元，最后片元被转换为帧缓存中的象素数据。片元是增加了着色，深度等信息的顶点，其阶段是等价的。</li></ul></li></ul><hr><ul><li>投影<ul><li>正交</li><li>透视</li><li>至此完成顶点空间到投影空间的变换，变换的结果被称作归一化设备坐标系（NDC）<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008194030.png" alt="image.png"><br>      <code>6.2.4.2 投影操作</code></li></ul></li></ul><hr><ul><li>裁剪<ul><li>CVV剔除，如果变化后的图元大于NDC时，则会进行裁剪，保留在NDC立方体内的图元</li></ul></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193727.png" alt="image.png"><br>      <code>6.2.4.3 片元裁剪剔除</code><ul><li>正反面剔除（可配置）</li><li>剔除正面或者背面的片元，UnityShader中的Cull 指令</li></ul></li><li>图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐标被转换为窗口坐标。最后，光栅化将裁剪好的图元转换为片元。</li></ul><hr><ul><li>屏幕映射<ul><li>由连续的线变为二维坐标上离散的点</li></ul></li><li>将NDC根据屏幕比例和大小变化为实际屏幕显示的位置</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193807.png" alt="image.png"><br>                      <code>6.2.4.4 屏幕映射</code></li></ul><hr><h2 id="6-2-5-光栅化阶段"><a href="#6-2-5-光栅化阶段" class="headerlink" title="6.2.5 光栅化阶段"></a>6.2.5 光栅化阶段</h2><ul><li>三角形设置<ul><li>得到三角形边界信息</li></ul></li><li>三角形遍历<ul><li>寻找被三角形覆盖的像素，插值并填充三角形</li></ul></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027194356.png" alt="image.png"><br>                          <code>6.2.5. 三角形遍历</code></li><li>同时还能进行的操作，抗锯齿处理</li></ul><hr><ul><li>抗锯齿MSAA<ul><li>有三种主流的抗锯齿类型，分别是</li><li>SSAA<ul><li>将片元放大并存入缓冲，对放大n倍的buffer采样</li></ul></li><li>MSAA<ul><li>在光栅化阶段，计算多个覆盖样本</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027194759.png" alt="image.png"><br>                  <code>6.2.5.1 抗锯齿MSAA</code></li><li>这个操作是对片元进行深度测试和覆盖测试，来对像素进行叠加，计算多个覆盖版本，并且还可以将数据传递给后续逐片元操作中的混合操作。</li></ul></li><li>FXAA，TXAA<ul><li>后处理技术，不在光栅化阶段</li></ul></li></ul></li></ul><hr><ul><li>逐片元操作阶段<ul><li>片元着色器</li><li>颜色混合</li><li>目标缓冲区</li></ul></li><li>片元首先要通过模版，深度测试，才能和缓冲区也就是上一帧素材混合进入到颜色缓冲区。裁剪会根据需求发生在深度测试之前</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193959.png" alt="image.png"><br>                      <code>6.2.5.2 逐片元操作流程</code></li></ul><hr><ul><li>片元着色</li><li>使用三定点插值进行计算得到最终的着色结果</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027195715.png" alt="image.png"><br>                      <code>6.2.5.3 差值实现三角形着色</code></li></ul><hr><ul><li>颜色混合</li><li>透明度测试<ul><li>透明度小于某阈值被剔除</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027195814.png" alt="image.png"><br>                  <code>6.2.5.4 透明度测试</code></li></ul></li><li>模版测试，深度测试</li><li>存入深度信息和模版所需数据信息。这两个操作都是可配置的。</li></ul><hr><h2 id="6-2-5-模版测试"><a href="#6-2-5-模版测试" class="headerlink" title="6.2.5 模版测试"></a>6.2.5 模版测试</h2><ul><li>模版测试是位于<strong>逐片元操作</strong>中的一环，通过掩码读取<strong>模版缓冲区</strong>中的相关值，与参考值进行比较，这个比较结果可由开发者决定，不论通过与否，都可以修改缓冲区的值，主要用于<strong>设定渲染范围</strong>以及高阶的阴影边缘效果等</li></ul><hr><h2 id="6-2-6-深度测试"><a href="#6-2-6-深度测试" class="headerlink" title="6.2.6 深度测试"></a>6.2.6 深度测试</h2><ul><li>深度测试用于记录场景中片元深度，并且根据深度来调整渲染方案，可以省略不需要的片元来减少性能消耗，这个过程有时会在进入片元着色器阶段前进行。</li></ul><hr><h2 id="6-2-7-混合模式"><a href="#6-2-7-混合模式" class="headerlink" title="6.2.7 混合模式"></a>6.2.7 混合模式</h2><ul><li>混合(Blend)通过设置混合状态，来调节当前颜色值与颜色缓冲区中的颜色值之间的运算关系。</li><li>不透明材质则直接覆盖掉颜色缓冲区中的值，而对于半透明等材质就可以对其进行混合操作来进行更多元化的更改,混合操作是高度可配置的。</li></ul><hr><ul><li>颜色混合中的测试的顺序是什么样的？详细可以查看：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/d65dbf5a8b7abadbb5899871c6c48b3.jpg" alt="d65dbf5a8b7abadbb5899871c6c48b3.jpg"><br>                    <code>6.2.5.3 测试顺序</code></li></ul><hr><h1 id="6-3-固定渲染管线（已被淘汰）"><a href="#6-3-固定渲染管线（已被淘汰）" class="headerlink" title="6.3 固定渲染管线（已被淘汰）"></a>6.3 固定渲染管线（已被淘汰）</h1><ul><li>固定渲染管线如今几乎已经被抛弃，它是只有一定的配置能力而无法让我们掌控全局的渲染管线，我们只能通过控制管线流程的开关以此来实现局限的效果，现在已经被抛弃。目前主流的渲染管线为SRP（可编程渲染管线）</li></ul><h1 id="6-4-引擎中的渲染管线"><a href="#6-4-引擎中的渲染管线" class="headerlink" title="6.4 引擎中的渲染管线"></a>6.4 引擎中的渲染管线</h1><ul><li>首先，我们需要区分两个概念，一个叫做渲染模式，也就是所谓的前向渲染，延迟渲染，另外就是我们这节课所提到的渲染管线。</li><li>渲染模式更类似于处理方法，而渲染管线则是实际处理的对象，我们利用不同的处理方法处理渲染管线得到的数据。</li></ul><hr><ul><li>目前在Unity中，渲染管线主要分为Built-in 以及URP 和HDRP，后续Untiy大概率会合并URP 以及 HDRP。其中主要的区别是，Built-in是内置渲染管线，何为内置，也就是放在里面，它对于我们自定义的部分所提供的效果较少，适合完成一些对于定制需求效果没有那么高的项目。</li><li>而URP则更加通用，这也是为何称其为URP，它为我们提供了更多可自定义的部分，比如RenderFeather就可以允许我们更自由的调用或修改管线中我们想要的部分。</li></ul><hr><h1 id="6-5-结语"><a href="#6-5-结语" class="headerlink" title="6.5 结语"></a>6.5 结语</h1><ul><li>至此，我们已经大致了解了一个软件中的资产是如何渲染到屏幕之上的，接下来我们将细致剖析各个流程之中的细节，并亲自动手实践，体会一个简单的三角片元是如何渲染的。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>UnityShader入门精要——冯乐乐著</li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li><li>Games101计算机图形学入门——闫令琪</li><li>知乎诸佬<br>  猫都能看懂的URP RenderFeature使用及自定义方法 - 蚊子尼的文章 - 知乎<br>  <a href="https://zhuanlan.zhihu.com/p/396965255">https://zhuanlan.zhihu.com/p/396965255</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学5——变换2</title>
      <link href="/2024/12/14/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A65%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A22/"/>
      <url>/2024/12/14/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A65%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A22/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-变换的组合"><a href="#5-1-变换的组合" class="headerlink" title="5.1 变换的组合"></a>5.1 变换的组合</h1><h2 id="5-1-1-任何变换都可以由单个变换组合得到"><a href="#5-1-1-任何变换都可以由单个变换组合得到" class="headerlink" title="5.1.1 任何变换都可以由单个变换组合得到"></a>5.1.1 任何变换都可以由单个变换组合得到</h2><ul><li>在上一节我们了解到了基本的变换类型了，并接触了将变换统一的坐标类型——其次坐标，还了解了其表现形式，其次矩阵。</li><li>这一节我们来看变换组合中需要注意的点。</li><li>事实上，任何变换都可以由单个变换组合而来，但他们的顺序却是需要考虑的。</li></ul><hr><h2 id="5-1-2-不同的顺序带来不同的结果"><a href="#5-1-2-不同的顺序带来不同的结果" class="headerlink" title="5.1.2 不同的顺序带来不同的结果"></a>5.1.2 不同的顺序带来不同的结果</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028084338.png" alt="image.png"><br>      <code>5.1.2 不同的变换顺序带来的结果不同</code></li><li>图中是一个变换的例子，它先进行了平移而后进行了旋转，但如果是先旋转再平移，呈现出的结果就不同，这很好理解，因为操作导致顶点位置发生了改变，因此就会使得结果不一样。</li></ul><hr><ul><li>这也表明了数学上，矩阵不符合交换律。因此往往平移是最后发生的。</li><li>我们往往应用矩阵的顺序是由右向左进行的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028084718.png" alt="image.png"><br>      <code>5.1.2.1 矩阵的应用是由右向左进行的</code></li><li>但矩阵同样具有结合律，因此我们可以将复杂的矩阵操作何为一个矩阵来对向量进行操作变换，例如MVP矩阵。</li></ul><hr><h2 id="5-1-3-变换的分解"><a href="#5-1-3-变换的分解" class="headerlink" title="5.1.3  变换的分解"></a>5.1.3  变换的分解</h2><ul><li>变换能够组合自然也能够分解，一些复杂的变换我们都可以通过将其分解为简单变换来实现，比如下面这个变换。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028085652.png" alt="image.png"><br>          <code>5.1.3 变换的分解</code></li><li>仔细观察这个变换，实际上它做的操作是将该图形平移到远点后，对其旋转，而后再平移回这个图形位置，这样就用我们已有的知识完成了一个复杂的不以原点为中心旋转的变换。在后续的学习过程中我们都应该保持这种思考方式，化繁为简，抓住主要矛盾。</li></ul><hr><h1 id="5-2-三维的变换"><a href="#5-2-三维的变换" class="headerlink" title="5.2 三维的变换"></a>5.2 三维的变换</h1><h2 id="5-2-1-知识的迁移"><a href="#5-2-1-知识的迁移" class="headerlink" title="5.2.1 知识的迁移"></a>5.2.1 知识的迁移</h2><ul><li>实际上，三维空间中的坐标变换与二维空间类似，本质上只不过多了个维度，我们依然使用其次坐标方式表示任何变换。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028090209.png" alt="image.png"><br>              <code>5.2.1 一个三维变换矩阵</code></li><li>这里闫老师在101中给大家提了一个小思考，三维空间中是先考虑线性变换还是先考虑平移呢？</li><li>相信大家已经有了自己的答案，当然是先考虑线性变换啊！多加了个维度本质都是通用的嘛！</li></ul><hr><h2 id="5-2-2-三维空间的旋转"><a href="#5-2-2-三维空间的旋转" class="headerlink" title="5.2.2 三维空间的旋转"></a>5.2.2 三维空间的旋转</h2><ul><li>三维空间中的旋转可能乍一看很复杂，但我们同样可以对其进行分解。</li><li>以下是分别按X，Y，Z轴向进行旋转的旋转矩阵，请各位观察其特点。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028091513.png" alt="image.png"><br>          <code>5.2.2 三维轴向旋转矩阵</code></li><li>很容易可以发现，绕哪个轴旋转哪个轴的列不变，为1，这里涉及到之前提到过矩阵乘法，希望大家自己动手试一试，看看是不是这样。</li><li>细心的同学会发现了，有点小问题，为何中间的旋转矩阵右上方的sina 符号不太对？这是因为叉乘的性质，实际上，如果我们要得到一个现在图中的正方向的y我们需要用x叉乘z，这与其他两个方向正好相反（回顾左右手定则！）因此我们需要颠倒他们的符号。</li></ul><hr><h2 id="5-2-3-一般的三维旋转"><a href="#5-2-3-一般的三维旋转" class="headerlink" title="5.2.3 一般的三维旋转"></a>5.2.3 一般的三维旋转</h2><ul><li>我们会介绍三大方法，分别是欧拉角，矩阵法，四元数法，它们各有利弊。</li><li>1.<strong>欧拉角</strong></li><li>我们分别定义绕三个方向的旋转为ROll，Yaw，Pitch，这三个旋转方式，它们的任意组合就可以成为一个任意的旋转角度。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028092307.png" alt="image.png"><br>              <code>5.2.3 欧拉角旋转</code></li><li>Rxyz（a，β，γ） &#x3D;  Rx(α)Ry(β)Rz(γ)</li><li>但不可避免的会有一些问题，比如万向死锁，你可以浏览这个视频来了解<ul><li>【无伤理解欧拉角中的“万向死锁”现象】 <a href="https://www.bilibili.com/video/BV1Nr4y1j7kn/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Nr4y1j7kn/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li></ul></li></ul><hr><ul><li>2.<strong>矩阵法</strong>任意轴旋转：罗德里德斯公式</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526210933.png" alt="Pasted image 20240526210933.png"><br>          <code>5.2.3.1 罗德里德斯公式</code> </li><li>将该向量平移到原点后再变换</li><li>感兴趣的同学可以自行推导这个公式是如何产生的。这里放一下闫老师推导的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/GAMES101_Lecture_04_supp_1.jpg" alt="GAMES101_Lecture_04_supp_1.jpg"><br>          <code>5.2.3.2 罗德里德斯公式的推导</code></li><li>依然有缺点，那就是矩阵蠕变，简单来说就是矩阵运算参数出现差错导致整个矩阵出现问题</li><li>3.<strong>四元数</strong></li><li>是一种便于做<strong>旋转差值</strong>的方法，抽象出第四位度的虚数轴。</li><li>这里不会详细展开，有兴趣的可以查看这个视频来了解<ul><li>【四元数如何控制物体旋转？】 <a href="https://www.bilibili.com/video/BV14t421h7M4/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV14t421h7M4/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li></ul></li></ul><hr><h1 id="5-3-视图变换和投影变换"><a href="#5-3-视图变换和投影变换" class="headerlink" title="5.3 视图变换和投影变换"></a>5.3 视图变换和投影变换</h1><h2 id="5-3-1-类比拍照的MVP变换"><a href="#5-3-1-类比拍照的MVP变换" class="headerlink" title="5.3.1 类比拍照的MVP变换"></a>5.3.1 类比拍照的MVP变换</h2><ul><li>在生活中，我们经常需要拍摄某些事物，可能是美丽的风景，也可能是人物，动物等等，拍摄的过程大致可以分为三步：<ul><li>将物体摆好位置——模型变换</li><li>调整好适合的角度——视图变换</li><li>将三维场景拍摄到二维照片中——投影变换</li></ul></li><li>以上就是图形学中最重要的将三维场景投射到二维画面中的操作——MVP矩阵。</li></ul><hr><h2 id="5-3-2-视图变换"><a href="#5-3-2-视图变换" class="headerlink" title="5.3.2 视图变换"></a>5.3.2 视图变换</h2><ul><li>第一步，定义相机，如果我们要定义一个摄像机，最基本的要素是什么？没错，是摄像机的位置，这就是第一个要素Position，随后我们要拍摄物体，那么我们要定义相机向何处看，这是第二个关键点，Look——at观看的视角方向，第三个关键点，我们如何规定相机的旋转呢？我们需要固定一个向上的方向来确定相机视图的旋转。</li><li>因此我们得出了相机的三要素——POSITION，LOOK_AT，以及UP</li><li>第二部，我们来思考如果要得到一张图像，我们具备了摄像机的这三个属性，如何让摄像机移动的同时物体也进行移动呢，最好的选择就是，将摄像机放在原点位置，我们还为其规定了上一步提到的两个属性：LOOK_AT和UP，分别是-Z以及Y，你会发现他们也是满足叉乘结果的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030102821.png" alt="image.png"><br>                  <code>5.3.2 摄像机的位置与方向</code></li><li>如何将任意一点的摄像机移动到标准的观察位置呢？这就需要应用我们之前学到的矩阵了，我们需要先将摄像机移动到原点位置，再将视角方向和向上方向旋转到-z与y上。</li><li>这需要我们进行矩阵变换，之前在三维变换中我们已经了解过，矩阵的三维变换需要先平移后做其他的线性变换，那么看起来应该是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030103934.png" alt="image.png"><br>                      <code>5.3.2.1 视图变换矩阵</code></li><li>平移变换很好写，我们只需要让任意一个点乘以一个平移值为（-x,-y,-z）的其次平移阵就好了，看起来就像这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030104242.png" alt="image.png"><br>                  <code>5.3.2.2 视图变换中的平移变换</code></li><li>但接下来就不太好写了，我们如何将任意方向的轴旋转到固定的方向呢？这其实就要用到我们本节提到的新知识了，旋转矩阵是一个正交阵，如果你忘了正交阵是什么，回到第3讲中查看一下吧，我们继续，正交阵的特点是其转置等于逆，逆阵又是啥，逆阵相当于是反向的操作，也就是说我们只需要先整出来一个将确定方向的向量旋转到任意方向的矩阵就好了，这很好做，随后我们只需要将其转置，就可以得到我们需要的矩阵了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030104716.png" alt="image.png"><br>                  <code>5.3.2.3 正交矩阵的逆等于其转置</code></li><li>这样我们就完成了视图变换</li></ul><hr><h2 id="5-3-3投影变换"><a href="#5-3-3投影变换" class="headerlink" title="5.3.3投影变换"></a>5.3.3投影变换</h2><ul><li>投影变换分为两种：<ul><li>1.透视投影</li><li>2.正交投影</li></ul></li><li>两者的共同点都是将三维的视图投影到二维画面上的过程，两者之不同是在于后者正交投影没有所谓的透视效果，也就是近大远小的效果，我们分别来看，首先是正交投影</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008194030.png" alt="image.png"><br>                          <code>5.3.3 投影变换</code></li></ul><hr><ul><li>正交投影</li><li>正交投影模拟的是在摄像机距离物体无限远时，物体投射到摄像机屏幕上的效果，因为距离很远，因此就没有透视效果，可以看上图右图上的结果。</li><li>正交投影的操作是什么呢？实际上它是规定了空间中任意一个立方体的上下左右前后这三组平面，分别为TB，LR，以及NF(也被成为近，远裁剪平面)，其中NF不太好理解，因为我们是以右手坐标系为标准，因此实际上数值来讲F比N更小。（OpenGl中是左手坐标系）其F比N更大。</li><li>之后正交投影将其分别映射到位于原点的正则标准正方形（1^3）上，这就完成了正交投影的变换。</li><li>我们来看矩阵实现，很简单，我们需要做的事情是，首先，将这个立方体移动到原点位置，用的是一个平移矩阵，之后，我们将这个立方体缩放至标准大小也就是xy∈【-1,1】区间内。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030112934.png" alt="image.png"><br>                  <code>5.3.3.1 正交投影变换矩阵</code></li></ul><hr><ul><li>我们来看一下Unity里的正交投影和透视投影，正常移动摄像机对应的是透视投影，但当我们点到视口栏中的2D选项实际上就是正交投影。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030113840.png" alt="image.png"><br>                  <code>5.3.3.2 Unity中的正交投影</code></li></ul><hr><ul><li>透视投影变换</li><li>透视投影实际上与正交投影最大的区别就是，两条平行线在屏幕上看起来会变成相交的了，这其实比较容易理解，就像我们看火车轨道，街道尽头，我们都能指出它们相交的地方，也就是交点，这就是透视效应。</li><li>那么我们该如何理解透视投影呢？实际上做了些什么呢？我们可以这样理解，虽然与正交投影不同，透视投影远近平面是不一样大的，但我们可以在保证他们的远近比例关系情况下，将透视投影视椎体“挤压”成为一个正交投影的长方体视椎体，最后就可以用我们已经学会的正交投影来对其进行处理了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030115420.png" alt="image.png"><br>                  <code>5.3.3.3 如何做透视投影？</code></li><li>通过我们初中学习的相似三角形知识，我们可以对这个过程进行一个分析，我们专注于y值，那么我们会发现如果要将f平面上方的点挤压到与n平面平行的点，我们就要考虑如下视图中相似三角形的关系：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030115904.png" alt="image.png"><br>                  <code>5.3.3.4 NF平面的透视三角形关系</code></li><li>我们可以得到以下比例关系式：N&#x2F;Z &#x3D; Y’&#x2F;Y ，因此就可以推出Y’ &#x3D; N&#x2F;Z * Y</li><li>x的推理过程一模一样，不再赘述，最后得到X’ &#x3D; N&#x2F;Z * X</li><li>目前我们知道了XY变化的过程，对于Z任然不知道，但没关系，我们已经可以根据其它关系推导出完整的矩阵了，还记得之前我们怎么推导二维旋转矩阵的吗？欢迎各位跟我一起推导，下面放出我的手写推导过程</li><li>手推过程较长，各位只要细心观察一定能最后得到一样的结果。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/109b066181a02341a54c4424067c6a1.jpg" alt="109b066181a02341a54c4424067c6a1.jpg"><br>                  <code>5.3.3.5 MVP——透视投影矩阵推导过程</code></li><li>这样，经过这一个矩阵变换我们就可以得到位于裁剪空间下的物体坐标了。</li></ul><hr><h2 id="5-3-4-裁剪空间与裁剪平面"><a href="#5-3-4-裁剪空间与裁剪平面" class="headerlink" title="5.3.4 裁剪空间与裁剪平面"></a>5.3.4 裁剪空间与裁剪平面</h2><ul><li>前文我们提到过了裁剪平面这个概念，裁剪平面实际上就是摄像机能看到的空间范围，一共分为6个裁剪平面。在Unity中，我们可以通过调节Near与Far裁剪平面与摄像机视口的距离，来决定裁剪空间的大小。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117115043.png" alt="image.png"><br>  <code>5.3.4 unity中的摄像机组件</code></li><li>我们之前的工作，实际上就是将场景中的物体，通过一系列缩放，平移变换，映射到这个裁剪空间之中，何为裁剪？相信之前认真观察的同学能够留意到我们的第四维变量W，该变量实际上就是一个判断区间的范围。</li><li>如果物体顶点在这个裁剪范围，则会被保留，而若在这个裁剪范围外，则将会被剔除。我们来看一下详细的过程</li></ul><hr><ul><li>首先，不同空间对应的裁剪坐标范围不同，Unity使用的OPenGL裁剪空间的范围是【-z，z]。如果超出这个范围则将被剔除，这事就会有疑问，如何剔除呢？</li><li>我们会将物体分为几种类型，完全在裁剪空间内的，一半在裁剪空间内的，以及完全在裁剪空间外的。</li><li>接着我们会对其进行裁剪，对于一半处在裁剪空间内的边缘情况，我们将进行进一步的操作，划分三角形，对于三角形，我们根据其每个顶点与平面的位置关系来判断是否要裁剪它，若需要裁剪，则我们将边界作为一条新的边，与在边界内的三角形部分形成一个新的几何体。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117122542.png" alt="image.png"><br>  <code>5.3.4.1 裁切三角形</code></li></ul><hr><h2 id="5-3-5-其次除法与视口坐标映射"><a href="#5-3-5-其次除法与视口坐标映射" class="headerlink" title="5.3.5 其次除法与视口坐标映射"></a>5.3.5 其次除法与视口坐标映射</h2><ul><li>在完成上述的MVP变换后，我们就需要将图像呈现在屏幕上，在此之前，为了方便计算，我们会将XYZ三个量全部除以W，将其归一化到归一设备坐标（NDC）下。这样便于计算，接着，我们将单独提取这个立方体内的物体的x，y坐标，并将其变化到屏幕上，这个过程被称为视口坐标映射，同样也是利用矩阵操作完成的。我们对物体映射在屏幕上的像素坐标位置，是这么计算的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117123246.png" alt="image.png"><br>  <code>5.3.5 其次除法与视口坐标映射</code></li><li>至此，我们就可以得到物体在屏幕像素上的位置了。不过就像我们在一开始所说的那样，这个映射方式在不同的API中定义并不相同，OPenGL直中与DX中是相反的，需要我们留意。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学4——变换1</title>
      <link href="/2024/12/04/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A64%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A21/"/>
      <url>/2024/12/04/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A64%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A21/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-变换的定义与作用"><a href="#4-1-变换的定义与作用" class="headerlink" title="4.1 变换的定义与作用"></a>4.1 变换的定义与作用</h1><h2 id="4-1-1-什么是变换"><a href="#4-1-1-什么是变换" class="headerlink" title="4.1.1 什么是变换"></a>4.1.1 什么是变换</h2><ul><li>变换也称<strong>仿射变换或仿射映射</strong> ，是利用矩阵在空间中使物体发生<strong>运动</strong>的操作的总称。</li><li>包括诸如：平移，旋转，缩放，错切等。</li></ul><hr><h2 id="4-1-2-变换的种类与操作"><a href="#4-1-2-变换的种类与操作" class="headerlink" title="4.1.2 变换的种类与操作"></a>4.1.2 变换的种类与操作</h2><ul><li>变换大致分为<strong>模型变换和视图变换</strong>，前者是不改变坐标系，变换模型本身，而后者是变换坐标系。这一点孰优孰劣需要具体分析，但绝大多数场景下，我们使用变换坐标系的变换，因为这样可以忽略很多细节，提高性能。</li><li>而物体变换某个量相当于坐标系变换相反的量，这也不难理解，比如想要某个物体缩放0.5倍，其实就是将坐标系变大2倍，自然原本的物体尺寸就变为了原来的0.5倍：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027094935.png" alt="image.png"><br>                          <code>4.1.2  缩放变换</code></li></ul><hr><h1 id="4-2-二维的变换"><a href="#4-2-二维的变换" class="headerlink" title="4.2 二维的变换"></a>4.2 二维的变换</h1><h2 id="4-2-1-二维缩放"><a href="#4-2-1-二维缩放" class="headerlink" title="4.2.1 二维缩放"></a>4.2.1 二维缩放</h2><ul><li>首先我们来看一个最简单的变化也就是我们前文提到的<strong>二维缩放变化</strong>，基于之前我所学的矩阵乘法，我们很容易就可以得到以下结果</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191106.png" alt="Pasted image 20240524191106.png"><br>  <code>4.2.1  二维缩放矩阵</code></li><li>最后我们可以发现，结果就是 x‘ &#x3D; Sx * x ， y’ &#x3D; Sy * y</li></ul><hr><h2 id="4-2-2-二维反转"><a href="#4-2-2-二维反转" class="headerlink" title="4.2.2 二维反转"></a>4.2.2 二维反转</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191220.png" alt="image.png"><br>  <code>4.2.2 二维翻转矩阵</code></li><li>如上是一个二维翻转矩阵，我们可以很快判断出，实际上它是将x进行取反操作，y保持不变。</li><li>那么我们就可以得出来一个结论，谁乘1保持不变，谁就是旋转轴，因此，该矩阵实际上是按y轴进行翻转，那么你能给出一个绕x轴翻转的矩阵吗？相信很简单，只需要调换一下正负号就好了。</li></ul><hr><h2 id="4-2-3-二维切变"><a href="#4-2-3-二维切变" class="headerlink" title="4.2.3 二维切变"></a>4.2.3 二维切变</h2><ul><li>接下来我们看一个稍微复杂一点的变换，二维切变，这种变换方式比上述两种变换方式都要更难理解，但我们同样可以通过分析得出其操作方式。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027100428.png" alt="image.png"><br>                       <code>4.2.3 二维切变</code></li></ul><hr><ul><li>观察这个变化，你发现了什么呢？有如下几点：<ul><li>1.首先，这张图片的y坐标并没有任何变化</li><li>2.这张图片的底部x坐标也没发生变换</li><li>3.这张图片的顶部x坐标向x正方向移动了a个单位距离</li></ul></li><li>因此根据以上这些判断，我们可以得出，实际上x坐标变化了ay个单位，最大时y &#x3D; 1，因此最大变化a，实际上这是一条斜率为a的斜线。因此我们可以得出以下的矩阵：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191506.png" alt="Pasted image 20240524191506.png"><br>                       <code>4.2.4 二维切变矩阵</code></li></ul><hr><h2 id="4-2-4-二维旋转"><a href="#4-2-4-二维旋转" class="headerlink" title="4.2.4 二维旋转"></a>4.2.4 二维旋转</h2><ul><li>接下来我们来看一个更困难一点的操作——旋转，这里需要唤醒各位一点关于三角函数的知识，但放心，并不难，只需要细心观察，认真计算即可。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027101603.png" alt="image.png"><br>                       <code>4.2.4 二维旋转</code></li></ul><hr><ul><li>我们来一起推导一下这些个值都是如何得到的</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/4ba5a85a671b3d41773d3cd75137e8b.jpg" alt="4ba5a85a671b3d41773d3cd75137e8b.jpg"><br>                      <code>4.2.4.1 二维旋转矩阵的推导</code></li></ul><hr><ul><li>最后，我们就可以得到我们想要的二维旋转矩阵了，旋转值由我们来定，当然这是一个只限于原点的旋转，后续我们会继续扩充，使其可以绕任意轴向旋转。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191724.png" alt="Pasted image 20240524191724.png"><br>                      <code>4.2.4.2 二维旋转矩阵</code></li></ul><hr><h2 id="4-2-5-线性变换"><a href="#4-2-5-线性变换" class="headerlink" title="4.2.5 线性变换"></a>4.2.5 线性变换</h2><ul><li>通过观察上述这几个变换，我们可以总结出一下规律</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524192227.png" alt="Pasted image 20240524192227.png"><br>                       <code>4.2.5 变换规律</code></li><li>我们称这种变换方式叫做线性变换。</li></ul><hr><h1 id="4-3-平移矩阵与其次坐标"><a href="#4-3-平移矩阵与其次坐标" class="headerlink" title="4.3 平移矩阵与其次坐标"></a>4.3 平移矩阵与其次坐标</h1><h2 id="4-3-1-为什么没有平移？"><a href="#4-3-1-为什么没有平移？" class="headerlink" title="4.3.1 为什么没有平移？"></a>4.3.1 为什么没有平移？</h2><ul><li>细心的同学肯定发现了，我们介绍了这些线性变换之中，竟然没有我们最常用也应该是最基础的变换，那就是平移变换，为什么没有呢？这是因为平移这个操作，很特殊。</li></ul><hr><h2 id="4-3-2-特殊的平移变换"><a href="#4-3-2-特殊的平移变换" class="headerlink" title="4.3.2 特殊的平移变换"></a>4.3.2 特殊的平移变换</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027104422.png" alt="image.png"><br>                      <code>4.3.2 二维平移操作</code></li><li>同样，我们试着去描述它，我们能否将其写作如上文所述的线性表达形式呢，尝试一下？可能很快就会给出结果了吧，答案是不行，我们只能用额外的矩阵操作表述这个平移变换</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027104607.png" alt="image.png"><br>              <code>4.3.2.1 引入平移变换的二维线性变换矩阵</code></li><li>这样虽然表示出来了，但并不美好，它是一个特殊的操作，计算机中我们不喜欢这样的特例，你需要花费更多的时间去记忆这些特例，太麻烦了，那么如何解决呢？数学家们为我们给出了答案那就是——其次坐标！</li></ul><hr><h2 id="4-3-3-其次坐标"><a href="#4-3-3-其次坐标" class="headerlink" title="4.3.3 其次坐标"></a>4.3.3 其次坐标</h2><ul><li>首先再次强调一下为何我们要引入其次坐标：<br>  Translation特殊，无法用线性变换完成，那么就要引入&#x3D;&#x3D;其次坐标&#x3D;&#x3D;</li><li>接下来介绍其次坐标，实际上其次坐标就做了一下的操作：<ul><li>通过增加维度来统一，&#x3D;&#x3D;点增加一个维度为1，向量为0&#x3D;&#x3D;</li><li>因为我们要通过原点坐标来描述向量或点在空间中的位置，而这个位置是固定不变的因此我们需要一个&#x3D;&#x3D;记录坐标信息的额外维度来扩充原有的矩阵&#x3D;&#x3D;</li></ul></li><li>我们来看一下其次坐标的推导过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/389cac6f69e60c21f265cd47f399d23.jpg" alt="389cac6f69e60c21f265cd47f399d23.jpg"></li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027105203.png" alt="image.png"><br>                      <code>4.3.3 其次坐标矩阵</code></li><li>铛铛！一个完美的描述矩阵完成了！它看起来很美好，不是吗？但我们也会发现增加了很多东西，正所谓 NO FREE LUNCH ! 因此我们也需要注意引入其次坐标带来的麻烦。</li></ul><hr><h2 id="4-3-4-个人思考"><a href="#4-3-4-个人思考" class="headerlink" title="4.3.4 个人思考"></a>4.3.4 个人思考</h2><ul><li>Q：为什么点是1而向量为0？</li><li>A：首先，这是一个区分向量和点的方式，这是他们不同的原因。向量之所以为0，是因为其有平移不变性，我们不希望对其进行平移操作时破坏这种不变性，因此为0。而点平移是会发生改变的，自然需要一个还原其本身意义的操作也就是将对点的操作×1，来保持这种操作的有效性。</li><li>同样，我们还可以利用这个特性，实现点与向量运算的性质，如下图，可以发现，实际上引入0,1能恰好使得运算得到的结果保持正确性：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027110952.png" alt="image.png"><br>                  <code>个人思考——为何其次坐标是这样的？</code></li></ul><hr><ul><li>而最后一项，点与点的加和，最后得到的其实是它们的中点，因为在二维变换中，实际上我们最后得到的应该是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027111135.png" alt="image.png"><br>                  <code>个人思考——二维点的表述</code></li><li>1+1&#x3D;2 因此我们需要将这个点转换为一个标准的点，也就是将其额外的维度归为1，所以都除去w，最后发现实际上得到的就是这两个点的中点。</li></ul><hr><h2 id="4-3-5-其次矩阵"><a href="#4-3-5-其次矩阵" class="headerlink" title="4.3.5 其次矩阵"></a>4.3.5 其次矩阵</h2><ul><li>前文我们介绍了其次坐标，接下来我们就可以将矩阵改写为其次坐标的形式，也就是其次矩阵。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028082530.png" alt="image.png"><br>              <code>4.3.5 其次坐标下的其次矩阵</code></li><li>我们可以观察到他们有一些特点，比如最后一行都是001，比如变换都发生在右上角的位置。</li></ul><hr><h2 id="4-3-6-逆变换"><a href="#4-3-6-逆变换" class="headerlink" title="4.3.6 逆变换"></a>4.3.6 逆变换</h2><ul><li>逆矩阵就是逆变换</li><li>逆变换其实就是乘以一个逆矩阵来取消操作</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028083652.png" alt="image.png"><br>              <code>4.3.6 逆变换</code></li></ul><hr><h2 id="在Processing中实践"><a href="#在Processing中实践" class="headerlink" title="在Processing中实践"></a>在Processing中实践</h2><p>我们通过Processing来实践这个变换，为了实现旋转缩放平移的统一，我们引入了其次坐标这个概念。 ^f256dd</p><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526162215.png" alt="Pasted image 20240526162215.png"></p><ul><li>在以上代码中，我们通过Processing内部封装的translate函数，通过改变变化基准坐标也就是改变坐标系的值，让方块进行运动，但实际上我们并没有改变方块本身的值：</li><li>如果左乘变换矩阵（算子），那么我们就在改变物体自身的值，而没有改变坐标，而如果我们右乘，就是上图的translate函数所做的，那就是改变坐标（坐标原点）。可在给出的源码中查看动态效果，这个方块在做循环往复的周期平移！</li></ul><hr><p>Scale矩阵如下</p><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524194857.png" alt="Pasted image 20240524194857.png"></li></ul><hr><h2 id="在Processing中实践-1"><a href="#在Processing中实践-1" class="headerlink" title="在Processing中实践"></a>在Processing中实践</h2><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526170525.png" alt="Pasted image 20240526170525.png"></p><ul><li>在以上代码中，我们通过Processing内置的Scale函数，对图形进行缩放。你可以找到对应的源码来观看实际的缩放动画，它是一组连续缩放的画面。</li></ul><hr><ul><li>Rotation矩阵如下</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524194915.png" alt="Pasted image 20240524194915.png"><br> ^165e7f</li></ul><hr><ul><li>效果图展示：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526204919.png" alt="Pasted image 20240526204919.png"></li></ul><hr><ul><li>源码展示：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526204941.png" alt="Pasted image 20240526204941.png"></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学3——变化的基础</title>
      <link href="/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1矩阵"><a href="#3-1矩阵" class="headerlink" title="3.1矩阵"></a>3.1矩阵</h1><h2 id="3-1-1-矩阵的定义"><a href="#3-1-1-矩阵的定义" class="headerlink" title="3.1.1 矩阵的定义"></a>3.1.1 矩阵的定义</h2><ul><li>矩阵就是二维的向量数组。</li><li>矩阵是由c列维度为R的向量组成的，我们标记一个矩阵的方法是标记它的行与列也就是Mr×c。</li><li>如下这是一个二行三列的矩阵：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026103749.png" alt="image.png"><br>          <code>3.1.1 一个二行三列矩阵</code></li><li>在计算机图形学中，我们经常利用矩阵来进行空间的变换，通过其与向量进行计算来变化空间。</li></ul><h2 id="3-1-2-方阵与对角单位阵"><a href="#3-1-2-方阵与对角单位阵" class="headerlink" title="3.1.2 方阵与对角单位阵"></a>3.1.2 方阵与对角单位阵</h2><ul><li>当矩阵的行与列相同时，我们称其为方阵，可用n来直接代表其维数，一个方阵也就是n×n维的矩阵。</li><li>更特殊一点，如果一个方阵的其他非对角元素均为0，对角元素为1，那么我们就称其为单位阵，单位阵在矩阵运算中充当着与实数运算中1相当的地位，也就是<strong>任何矩阵乘以单位阵</strong>得到的还是原矩阵（前提是它们能相乘）。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104332.png" alt="image.png"><br>          <code>3.1.2 一个单位阵</code></li></ul><h2 id="3-1-3-相等矩阵与转置矩阵"><a href="#3-1-3-相等矩阵与转置矩阵" class="headerlink" title="3.1.3 相等矩阵与转置矩阵"></a>3.1.3 相等矩阵与转置矩阵</h2><ul><li>判断一个矩阵相等的前提是，首先它们的维数相同，其次，它们逐行逐列对应的元素均相同，由此我们判断两个矩阵相等。</li><li>转置是一个操作，简单来说就是将矩阵的行与列交换，也就是第一行元素变成第一列元素，第一列元素反之变为第一行元素。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104648.png" alt="image.png"><br>          <code>3.1.3 矩阵的转置</code></li><li>转置我们用上标T来表示，一个矩阵转置的转置就等于其本身，单位阵的转置也等于其本身。</li></ul><h1 id="3-2-矩阵的运算"><a href="#3-2-矩阵的运算" class="headerlink" title="3.2 矩阵的运算"></a>3.2 矩阵的运算</h1><h2 id="3-2-1-矩阵的数乘与加法"><a href="#3-2-1-矩阵的数乘与加法" class="headerlink" title="3.2.1 矩阵的数乘与加法"></a>3.2.1 矩阵的数乘与加法</h2><ul><li>矩阵的数乘很简单，因为矩阵某些性质与向量类似，因此矩阵的数乘实际上就是每一行每一列都乘上这个数。</li><li>矩阵的加法就是每一行每一列对应的元素相加，而其前提是它们的维数相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026110956.png" alt="image.png"><br>          &#96;3.2.1 矩阵的加法</li></ul><h2 id="3-2-2-矩阵的乘法"><a href="#3-2-2-矩阵的乘法" class="headerlink" title="3.2.2 矩阵的乘法"></a>3.2.2 矩阵的乘法</h2><ul><li>矩阵乘法的前提是两个矩阵的行列对应相等，也就是Ac &#x3D; Bc &amp;&amp; Ar &#x3D; Br</li><li>其方法就是第一个矩阵的行乘以第二个矩阵的列，然后将其对应元素相加作为新矩阵的元素</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026111922.png" alt="image.png"><br>          <code>3.2.2 矩阵的乘法</code></li><li>如下面这个例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112057.png" alt="image.png"><br>          <code>3.2.2.1 矩阵乘法实例</code></li><li>因此作为矩阵乘法，其并不满足乘法的交换律，因为如果交换就会发生行列不相等的情况<ul><li>AB !&#x3D; BA</li></ul></li><li>同样的如果AB &#x3D; AC 不意味着 B &#x3D;C，但矩阵满足乘法结合律，如下</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112751.png" alt="image.png"><br>      <code>3.2.2.2 矩阵满足乘法结合律</code></li></ul><h2 id="3-2-3-行列式与逆阵"><a href="#3-2-3-行列式与逆阵" class="headerlink" title="3.2.3 行列式与逆阵"></a>3.2.3 行列式与逆阵</h2><ul><li>行列式的定义<ul><li>行列式是方阵M对应的一个标量，记作|M|</li><li>行列式的计算：<ul><li>余子式与代数余子式<ul><li>我们通过观察行列式的求解可发现，实际上它是由一个个代数余子式相加得来的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026114721.png" alt="image.png"><br>     <code>3.2.3 矩阵的余子式求解</code></li><li>观察上图，实际上我们会发现余子式就是该元素乘上去除掉该元素所在的那一行和那一列后组合而成的矩阵。</li></ul></li></ul></li><li>矩阵转置的行列式等于原矩阵的行列式</li></ul></li><li>行列式的几何意义<ul><li>二维行列式的几何意义代表以基向量为两边构造的平行四边形的有符号面积</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026121109.png" alt="image.png"><br>          <code>3.2.4行列式的几何意义</code></li><li>在三维中，行列式的几何意义是以基向量为三边的平行六面体的有符号面积。</li></ul></li><li>逆矩阵<ul><li>逆矩阵是只有方阵才具备的性质，它本质上是说明一个方阵与另一个方阵的乘积为1，这两个方阵互为逆阵。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123201.png" alt="image.png"><br>                  <code>3.2.3.1 逆矩阵计算的举例</code></li></ul></li><li>判断是否可逆<ul><li>判断一个矩阵是否可逆需要检测矩阵行列式的值，一个具有逆矩阵的矩阵其行列式不为0，反之则为0。</li></ul></li><li>求解逆阵<ul><li>这里就需要利用我们之前学习到的求矩阵代数余子式的方式，先求出矩阵的代数余子式，并用其组成一个新的矩阵，我们称其为伴随阵，随后将伴随阵除以行列式的值即可得到矩阵的逆阵</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123823.png" alt="image.png"><br>                  <code>3.2.3.2 求解一个矩阵的逆阵</code></li></ul></li><li>逆阵的应用<ul><li>逆阵往往被用于执行反向操作上，因为它可以将其逆阵转化为单位阵，也就是最后得到1，可视为取消操作。</li></ul></li></ul><h2 id="3-2-4-正交阵"><a href="#3-2-4-正交阵" class="headerlink" title="3.2.4 正交阵"></a>3.2.4 正交阵</h2><ul><li>定义：如果一个矩阵的转置（MT） 等于这个矩阵的逆，那么我们就称其为正交阵。</li><li>这个性质在以后得求矩阵逆的应用上非常方便，因为矩阵逆很难求，就像上面说的那样，因此如果知道该矩阵是个正交阵，那么我们可以直接求其转置，转置开销很小，所以就进一步优化了性能，简化了计算！</li></ul><hr><h1 id="3-3向量与矩阵"><a href="#3-3向量与矩阵" class="headerlink" title="3.3向量与矩阵"></a>3.3向量与矩阵</h1><h2 id="3-3-1-行向量与列向量"><a href="#3-3-1-行向量与列向量" class="headerlink" title="3.3.1 行向量与列向量"></a>3.3.1 行向量与列向量</h2><ul><li>向量其实就是单维度的矩阵，比如一个行向量其实就一个1×n的矩阵，一个列向量实际上就是n×1的矩阵。它们是可以与矩阵进行运算的，但为了使其运算有意义，矩阵的位置很重要，比如行向量只能在矩阵的左侧，而列向量则只能在矩阵的右侧</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026130105.png" alt="image.png"><br>                   <code>3.2.3.3 两个向量相乘为矩阵</code></li><li>所以实际上，结果向量的每一个元素，都是元向量与矩阵中单独行列的点积。</li><li>行向量左乘矩阵必为行向量，而列向量右乘矩阵必为列向量</li></ul><h2 id="3-3-2-矩阵的几何意义"><a href="#3-3-2-矩阵的几何意义" class="headerlink" title="3.3.2 矩阵的几何意义"></a>3.3.2 矩阵的几何意义</h2><ul><li><p>我们前文提到了基向量这个概念，其实坐标系就是用基向量来进行表示的，我们已经强调过了矩阵实际上最大的作用就是改变空间坐标，那么究竟是如何改变的呢？</p></li><li><p>实际上每个向量都可以写作基向量的形式，而不同空间的基向量组成不同，但它们都有一个特点，那就是它们之间线性无关（也就是不在一个平面上）</p></li><li><p>矩阵乘以向量，实际上就是对这个向量的基向量进行的点乘变化</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026131455.png" alt="image.png"><br>                  <code>3.3.2 一个缩放矩阵</code></p></li><li><p>所以综上所述，矩阵与向量相乘，实际上就是对向量的基向量进行变化，又因为向量的基向量决定一个空间，因此实际上就是将一个向量，从一个空间变换到了另一个空间。</p></li><li><p>至此，我们完成了基本上所有的线性代数方面的学习，接下来就是去实际应用了，我们将会看到矩阵的实际作用，包括但不限于上述的例子。</p></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学2——位置与方向</title>
      <link href="/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/"/>
      <url>/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-点"><a href="#2-1-点" class="headerlink" title="2.1 点"></a>2.1 点</h1><ul><li>在上一节我们讲到，<strong>坐标系</strong>是图形学以及数学物理学等等学科中非常重要而基本的概念</li><li>坐标系又是有一系列<strong>离散</strong>的点（离散就是分散开的不连续的）组成的。</li><li>那么在这里我们就可以很简单的定义点：</li></ul><h2 id="2-1-1-点的定义"><a href="#2-1-1-点的定义" class="headerlink" title="2.1.1 点的定义"></a>2.1.1 点的定义</h2><ul><li>图形学中<strong>点</strong> 是坐标系中的一个<strong>位置，同时也是一个数组，记录这这个点所代表的值</strong>我们称为<strong>坐标</strong></li><li>点具有数值，维度这两个特征，并且是唯一的。</li></ul><hr><h1 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h1><h2 id="2-2-1-物理学家眼里的向量"><a href="#2-2-1-物理学家眼里的向量" class="headerlink" title="2.2.1 物理学家眼里的向量"></a>2.2.1 物理学家眼里的向量</h2><ul><li>在物理学中，向量也被称为矢量，它更多是描述一种<strong>运动</strong>，包含了运动的<strong>速度和方向</strong>，它的位置是没有意义的，可以在任何位置出现，下面是一个简单的例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113238.png" alt="image.png"><br>                      <code>2.2.1物理学家眼中的向量</code></li><li>这是一个三维空间里的向量分布，可以看出它们仅仅代表着不同的方向以及长度大小，它们的颜色值是根据数值对应的RGB颜色计算出来的（就像我们上节课所了解到的）</li><li>这是一种理解方式，但计算机学家眼中，还有另一种理解。</li></ul><h2 id="2-2-2-计算机学家眼里的向量"><a href="#2-2-2-计算机学家眼里的向量" class="headerlink" title="2.2.2 计算机学家眼里的向量"></a>2.2.2 计算机学家眼里的向量</h2><ul><li>计算机学家眼中，向量与物理学家眼中的不太相同，我们更多只在意它的<strong>数值特征</strong>，毕竟计算机的根本就是一组一组的数据运算（详细可在计算机基础入门中了解）</li><li>因此在他们眼里，向量也许是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113747.png" alt="image.png"><br>                   <code>2.2.2 计算机学家眼中的向量</code></li><li>在这个例子中，我们记录的两个数本身有自身所代表的含义，而我们却忽略了其位置，毕竟一个房屋的售价和平米而言，位置信息对他们是无效的。</li><li>而数学家却尽力概括这两个观点，他们就提出了我们所学习到的数学上对向量的定义</li></ul><h2 id="2-2-3-向量的定义"><a href="#2-2-3-向量的定义" class="headerlink" title="2.2.3 向量的定义"></a>2.2.3 向量的定义</h2><ul><li><strong>向量是在坐标系下，以原点为起点的有一定距离的有向线段。</strong></li><li>本质上它们表示的是两点之间的<strong>差异，或者说是一个点如何变化到另一个点的指示。</strong></li><li>向量与点类似，同样具备两个特征，那就是<strong>方向（所指的角度）以及大小（它的长度）</strong></li><li>在计算机中，向量往往作为变化的一种手段，我们可以利用它进行物体或者数值的变换，这种变换是对于坐标系而言的。</li></ul><h2 id="2-2-4-基本的向量的运算"><a href="#2-2-4-基本的向量的运算" class="headerlink" title="2.2.4 基本的向量的运算"></a>2.2.4 基本的向量的运算</h2><ul><li><strong>点与向量的运算</strong><ul><li>点的减法运算<ul><li>向量是两点只差，有了这个根据我们就可以通过两点位置的计算来表示一个向量，比如从P点到O点的运动方式，我们就可以理解为一个向量，让我们表示它！</li><li>O(Ox，Oy) - P(Px，Py) &#x3D; Vpo</li><li>我们一定要从几何直观上理解它，就像这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023115903.png" alt="image.png"><br>                   <code>2.2.4 点与向量的运算</code></li></ul></li><li>点的加法运算<ul><li>实际上我们已经可以描述点的加法运算了，它本质上只是减法的逆运算，因此我们可以描述P到O的运算，就像这样：</li><li>P(Px，Py) + Vop &#x3D; (Ox，Oy) </li><li>描述的实际上还是这个过程，很容易理解。</li></ul></li></ul></li></ul><hr><ul><li><strong>向量之间的运算</strong><ul><li>向量与向量的<strong>加法</strong><ul><li>向量之间的加法本质上也可以用过<strong>点</strong>来定义，因为前文告诉我们实际上向量也是由点来表述的，因此我们可在二维坐标系下，定义一个向量的加减法，就像我们定义点与向量的运算一样</li><li>点P(Px，Py) ，(Ox，Oy) ，Q(Qx,Qy) </li><li>向量：O(Ox，Oy) - P(Px，Py) &#x3D; Vpo，Q(Qx，Qy) - P(Px，Py) &#x3D; Vpq</li><li>所以<ul><li>Vpo + Vpq &#x3D; O(Ox，Oy) - P(Px，Py) +Q(Qx，Qy) - P(Px，Py)<br>  &#x3D; (Ox+Qx - 2Px,Oy + Qy - 2Py)</li></ul></li><li>计算很简单，但我们如何去描述它呢，实际上它让我们做了什么？</li><li>前文提到，计算机中向量的运算实际上就是改变一个数的值，我们完成的实际上是一个全局尺度的变换。</li><li>从P出发我们先到了O，此时如果用我们上面的值来表示（Px + Ox - Px，Py+ Oy - Py）最后运算得到的就是O点，而后我们再向着Vpq所代表的方向运动那就是（Ox + Qx -Px，Oy + Qy - Py)。为何与上面的结果有所不同？</li><li>细心地同学会马上指出，你求得的结果是个点啊！</li><li>没错，我们上面推导的实际上是对于一个点而言的变化，而前面所推的则是向量的加减法。他们有什么区别？没错，因为向量是忽略位置而只是一个操作，所以我们没有加上最开始的点坐标。而他们之间其实就是这个差别。</li><li>由此我们系统的论证了为何向量是指示一个点到另一个点的变化。这种加法法则也被称为向量的四边形法则：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023131800.png" alt="image.png"><br>                 <code>2.2.4.1向量的四边形法则</code></li></ul></li></ul></li></ul><hr><ul><li><strong>向量的数乘</strong><ul><li>向量的数乘实际上并不难理解，数乘可以看做一个缩放操作，是只对于向量的数值大小进行的变化</li><li>但同样会有一个例外：如果乘数是个负数，那么就会导致向量变化为反方向的一个新向量，相当于向反方向进行缩放。</li></ul></li><li><strong>向量的模</strong><ul><li>向量的模|a|其实就是描述向量长度的方式，这个需要运用一定的勾股定理去理解，实际上我们是将向量的分量作为描述模的方式也就是<ul><li>|a|  &#x3D; √ Ax^2 + Ay^2</li></ul></li></ul></li><li><strong>向量的归一化</strong><ul><li>向量的归一化是保留向量方向信息而忽略其长度信息的一种操作。比如在计算光线与法线的过程中，我们只需要知道方向信息就可以了，而过多的信息会造成数据存储的浪费，而如何进行这个操作呢</li><li>我们观察模的定义，会发现，如果我们想让模为1，实际上只需要将一个向量的每一个值除以他们的模，这是个很巧妙的数学方法</li></ul></li><li><strong>基向量</strong><ul><li>现在，我们终于可以介绍这个概念了，基向量是我们描述一个坐标系的方式，往往一对或几对相互垂直的基向量使我们定义一个基本的坐标系空间的方式，他们的特点是：模长为1，方向相互垂直，本质上是便于我们通过这个向量，来描述其他向量。如我们之前的Vpo向量就可以写成：<ul><li>Vx &#x3D; （Ox - Px）* Xi ， Vy &#x3D; （Oy - Py ）* Yi</li></ul></li><li>这样做什么好处，好像根本没有什么变化啊！？毕竟模长是1乘上去压根不会有什么变化</li><li>实际上，这就是我们本次课或者说图形学最终的运行逻辑。就是通过变换基向量来进行空间的变换。试想一下，如果变换每一个向量每一个点来转换一个模型是不是会很麻烦？</li><li>那么如果我们变换基向量本身呢？没错，这样的话我们就可以很简单的将一个空间理所应当的改变为另一个空间了，而不用变换里面的每一个点。因为点本身就是这些基向量形成的，本质只是数乘而已。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023144002.png" alt="image.png"><br>              <code>2.2.4.2 三个基向量张成一个向量空间</code></li></ul></li><li><strong>向量的乘法</strong><ul><li>点积<ul><li>点积是向量与向量相乘的结果，它最后得到的是一个数，公式如下<ul><li>a·b  &#x3D; axbx + ayby</li></ul></li><li>点积不但可以描述角度信息也可以描述一个向量再另一个向量方向上的投影长度<ul><li>a·b &#x3D; |a||b|cos&lt;a,b&gt;</li></ul></li><li>通过这个公式我们可以快速得出a，b之间夹角值，以及ab的大致方向判断。</li></ul></li><li>点积的特性使我们可以利用它将一个向量分为水平方向和垂直方向的分向量，为我们后期描述向量之间的关系提供了一个有力手段。</li><li>点积的实际应用：<ul><li>比如在计算光线与物体法线的关系中，我们就可以通过点积运算快速得出一个物体的受光信息：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"><br>                  <code>2.2.4.3 点积的应用——判断着色</code></li></ul></li><li>叉积<ul><li>叉积是向量之间的另一种运算，不同的是，它只适用于3维计算，它得到的不是一个数而是一个向量。<ul><li>a×b &#x3D; 【aybz - azby，axbz - azbx，axby - aybx】</li><li>axb &#x3D; （aybz - azby）x +（axbz - azbx）y +（axby - aybx）z</li></ul></li><li>叉积描述的是一个垂直于相乘的两个向量所构成平面的向量，因此往往应用于求解法向量。</li><li>叉积同样可以描述两个向量之间的角度关系<ul><li>a×b &#x3D; |a||b|sin&lt;a,b&gt;</li></ul></li><li>但需要注意的是，叉积可能会存在两个不同结果，这显而易见，因为垂直于ab平面的向量有两个，如何去判别他们呢？</li><li>我们可以通过平移向量使他们首尾相连，并判断是顺时针还是逆时针方向，通过左右手坐标系来判别他们的方向</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104047.png" alt="image.png"><br>                  <code>2.2.4.4 叉积存在两个方向 </code></li></ul></li><li>叉积的应用<ul><li>判定左右</li><li>前文我们提到，叉积有两个方向，并且我们可以根据方向的不同判定原始向量的旋向性，那么由此，我们就可以判断这两个向量之间的左右关系了，比如顺时针的方向排布，b在a的左边</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025115422.png" alt="image.png"><br>                  <code>2.2.4.5 插件的应用——判断左右</code></li><li>判断内外</li><li>这是一个很重要的应用那就是判断一个点是否在三角形内，这会在我们后续的<strong>光栅化</strong>阶段应用。我们可以依次连接一点与一个三角形顶点，并将其作为一个向量与三角形顶点组成的向量做叉积，如果三个顶点判断都为同一侧(左侧或者右侧)我们就将其判定为在三角形内，并渲染这个点到屏幕上。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025120903.png" alt="image.png"><br>                  <code>2.2.4.6叉积的应用——判断内外</code></li></ul></li></ul></li></ul><hr><h2 id="进阶2-3-在Processing中实践"><a href="#进阶2-3-在Processing中实践" class="headerlink" title="进阶2.3 在Processing中实践"></a>进阶2.3 在Processing中实践</h2><h2 id="2-3-1-向量加减法的直观实现"><a href="#2-3-1-向量加减法的直观实现" class="headerlink" title="2.3.1 向量加减法的直观实现"></a>2.3.1 向量加减法的直观实现</h2><p>我们通过Processing来定义两个向量构造函数，在Processing中我们进行如下定义，首先我们需要定义一个Pvector基类来实现向量，如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162520.png" alt="Pasted image 20240524162520.png"></p><p>在这些代码中，我们分别创建了三个向量对象，并且为他们赋值，让他们分别在xy上有了对应的值，因此我们可以在ellipse这个函数之中传入我们创建的对象的值，这样，我们就可以在想对应的坐标处为中心，创建圆形，add参数本质上就是将向量的对应坐标相加，得到v3的值。</p><hr><p>效果如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162856.png" alt="Pasted image 20240524162856.png"></p><hr><h2 id="2-3-2-点乘的直观实现"><a href="#2-3-2-点乘的直观实现" class="headerlink" title="2.3.2 点乘的直观实现"></a>2.3.2 点乘的直观实现</h2><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164159.png" alt="Pasted image 20240524164159.png"></p><hr><p>同样，我们在其中使用dot函数，就可以进行点乘。我们还是定义两个向量，并且传入两个向量的位置，调用line绘制两条线段，而后，我们将v2标准化，也就是作为1，并且我们将标准化后的v2，作为值与v1进行点积，实际上我们得到的就是v1在v2上的投影，而后我们将v2乘上这个投影，并且绘制，就可以得到如下图形：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164140.png" alt="Pasted image 20240524164140.png"></p><hr><h2 id="2-3-3向量叉乘的直观实现："><a href="#2-3-3向量叉乘的直观实现：" class="headerlink" title="2.3.3向量叉乘的直观实现："></a>2.3.3向量叉乘的直观实现：</h2><p>叉乘本质上就是先进行两个向量的标准化，也就是与基向量点乘，而后，将它们赋值给一个新的向量。这个新的向量就是标准化之后的向量。</p><p>我们来看一下它的实现<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524183848.png" alt="Pasted image 20240524183848.png"></p><p>首先我们新建两个变量，然后在中心位置新建一个点，我们在这个点为基准，绘制两条支线，然后以这两条支线为基准，使用叉乘函数生成我们的第三条线段，它是垂直于另外两条线段的，然后我们将它标准化，也就是除以模长，之后，绘制：效果如下图：</p><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524184007.png" alt="Pasted image 20240524184007.png"></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——8</title>
      <link href="/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/"/>
      <url>/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/</url>
      
        <content type="html"><![CDATA[<h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>数据逻辑节点：Ue中常用的数据选择节点有：switch，if节点等，我们可以简单利用这些节点对数据进行简单的判断。</li></ul><h1 id="switch节点"><a href="#switch节点" class="headerlink" title="switch节点"></a>switch节点</h1><ul><li>我们可以利用ue中的switch节点进行一些数据运算的判断，可以输入两个数据以及一个判断数据，来在外部创建选项进行数据的切换。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017131843.png" alt="image.png"></li></ul></li></ul><h1 id="if-节点"><a href="#if-节点" class="headerlink" title="if 节点"></a>if 节点</h1><ul><li>我们可以使用if节点进行一些简单的逻辑判断，比如a是否大于b或相反，这些在进行一些需要判断范围或者蒙版遮罩比较适用。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132235.png" alt="image.png"></li></ul><hr><h1 id="常用的数学运算节点"><a href="#常用的数学运算节点" class="headerlink" title="常用的数学运算节点"></a>常用的数学运算节点</h1><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132429.png" alt="image.png"></p><ul><li>以上是Ue中常用的三个数学计算节点，分别为点积，叉积，以及归一化运算，其相关的数学基础比较容易，在此就不赘述，各位谨记，实际上颜色也是数据，是向量组成的矩阵，对其进行操作就是进行向量的运算。</li></ul><h2 id="点积运算"><a href="#点积运算" class="headerlink" title="点积运算"></a>点积运算</h2><ul><li>点积运算本质是判断两个向量的方向关系，方向不同点积的结果也不同。这里给出基本的点积运算逻辑：<br>               A · B &#x3D; |A|B|cos(a,b)  </li><li>从公式可以看出，得到的结果存在一个ab的夹角的余弦值，我们可以利用这个值进行一些条件判断或者效果制作。</li></ul><h2 id="叉积运算"><a href="#叉积运算" class="headerlink" title="叉积运算"></a>叉积运算</h2><ul><li>差集运算本质是已知两个向量求第三个与这两个向量所在平面垂直的向量方向，因此我们可以利用这两个向量得出第三个向量的方向，在判断一点与三角形位置关系的时候经常使用，以下是叉积的运算逻辑：<br>               A×B &#x3D; |A||B|sin(a,b)</li><li>从公式可以看出实际上与它们垂直的第三个向量的长度在数值上等于以a，b，夹角为θ组成的平行四边形的面积。<br>               |c|&#x3D;|a×b|&#x3D;|a||b|sin&lt;a，b&gt;</li></ul><h2 id="归一化运算"><a href="#归一化运算" class="headerlink" title="归一化运算"></a>归一化运算</h2><ul><li>归一化往往是在简化运算方面进行的，有些时候我们只需要向量的方向信息而忽略它的位置信息，这时候我们就可以使用归一化操作，忽略它的具体位置信息而保留它的方向，让其模长为1。以下是归一化运算逻辑<br>                     B&#x2F;|B|</li><li>去除其长度信息，只保留其方向信息</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学1——基本概念</title>
      <link href="/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1画布与坐标系"><a href="#1-1画布与坐标系" class="headerlink" title="1.1画布与坐标系"></a>1.1画布与坐标系</h1><h2 id="1-1-1画布的定义"><a href="#1-1-1画布的定义" class="headerlink" title="1.1.1画布的定义"></a>1.1.1画布的定义</h2><ul><li>画布实际上可以理解为显示到屏幕上的画面，是一个像素矩阵，无论是3D场景抑或是2D场景，最后都要通过画布来呈现</li><li>画布可以使用一个函数（会在编写着色器时遇到它）它接受一个坐标值，并绘制一个颜色。</li></ul><hr><h2 id="1-1-2-坐标系"><a href="#1-1-2-坐标系" class="headerlink" title="1.1.2 坐标系"></a>1.1.2 坐标系</h2><ul><li>坐标系量化排布数值的方式。我们这里讨论的主要是屏幕坐标系，在不同的平台坐标系的定义不一样，但它们都应该具备几个基本特征：<ul><li>坐标轴</li><li>原点</li><li>轴距</li></ul></li><li>比如在OpenGL中坐标是这样的，y轴正方向向上</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145259.png" alt="image.png"><br>                      <code>1.1.2.1 OpenGL坐标系</code></li></ul><hr><ul><li>而在DirectX中，坐标轴是这样的：<br>*<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145422.png" alt="image.png"><br>                      <code>1.1.2.2 DirectX坐标系</code></li><li>我们可以通过变化轴来进行坐标系的变化。</li></ul><hr><h2 id="1-1-3-左右手坐标系"><a href="#1-1-3-左右手坐标系" class="headerlink" title="1.1.3 左右手坐标系"></a>1.1.3 左右手坐标系</h2><ul><li>在计算机软件中，我们常常会接触到判断物体坐标系的情况，最常用的两个坐标系分别是左手坐标系和右手坐标系，它们最大的不同就是它们所对应的x轴方向不同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104607.png" alt="image.png"><br>          <code>1.1.2.3 左右手坐标系</code></li></ul><hr><ul><li>区别两个坐标系的方式是考虑他们的旋向性，两个坐标系无法通过旋转重合。</li><li>如Unity使用的就是左手坐标系，它的特点是x轴向右。我们可以通过左右手法则来判断左右手坐标系</li><li>左手坐标系下旋转方向是顺时针的，而右手法则下旋转方向是逆时针的，对应的大拇指的方向也是垂直方向同样是不一样的</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104937.png" alt="image.png"><br>          <code>1.1.2.4 左右手法则</code></li></ul><hr><h1 id="1-2-色彩与色彩空间"><a href="#1-2-色彩与色彩空间" class="headerlink" title="1.2 色彩与色彩空间"></a>1.2 色彩与色彩空间</h1><h2 id="1-2-1色彩的感性理解"><a href="#1-2-1色彩的感性理解" class="headerlink" title="1.2.1色彩的感性理解"></a>1.2.1色彩的感性理解</h2><ul><li>色彩的<strong>冷暖，色彩的对比度，色彩的饱和度，色彩的色相</strong></li></ul><h2 id="1-2-2色彩的理性理解"><a href="#1-2-2色彩的理性理解" class="headerlink" title="1.2.2色彩的理性理解"></a>1.2.2色彩的理性理解</h2><ul><li>由<strong>光源产生的光线</strong>，进入人眼，在人眼细胞产生一系列化学反应，信号传入大脑，最终形成感知</li></ul><hr><h2 id="1-2-3光源的定义"><a href="#1-2-3光源的定义" class="headerlink" title="1.2.3光源的定义"></a>1.2.3光源的定义</h2><ul><li>**发出光线的物体</li><li>光的波长：<ul><li>理论上是无穷大的，人眼的<strong>可见光范围</strong>决定了我们对其颜色的定义。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120443.png" alt="image.png"><br>                       <code> 1.2.3.1 光波总览</code></li></ul></li></ul><hr><ul><li>如何去<strong>定量</strong>描述光？<ul><li>光实际上是<strong>波</strong>，波形可以叠加，我们通过<strong>功率单位</strong>（流明，瓦数等）描述。</li><li>分光光度计：通过分光后对波长进行感知，最终得知光能量集中在550nm区域（图中绿色区域）</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120750.png" alt="image.png"><br>                      <code>1.2.3.2 人眼可见光范围</code></li></ul></li></ul><hr><h2 id="1-2-4-光传播的方式"><a href="#1-2-4-光传播的方式" class="headerlink" title="1.2.4 光传播的方式"></a>1.2.4 光传播的方式</h2><ul><li>基本的传播方式：<ul><li><strong>直射，折射，反射，</strong> 光线追踪方式</li></ul></li><li>反射过程中，光的<strong>能量会减少，因为材质吸收了一定能量的光</strong>而吸收了某种颜色的光就代表人眼<strong>无法再看到这部分光。</strong><br>因此我们能看到的就是它们<strong>补集</strong>，也就是反射出的光</li></ul><hr><h2 id="1-2-5-光源的接受者"><a href="#1-2-5-光源的接受者" class="headerlink" title="1.2.5 光源的接受者"></a>1.2.5 光源的接受者</h2><ul><li>光源的接受者实际上是摄像机视图，但最终呈现给的是人眼</li><li>关于人眼的HDR：人眼可以调节自动曝光，分辨出高亮度的区域中不同亮度层次的区域。</li><li>人眼感知色彩的细胞主要分为杆状细胞和锥状细胞<ul><li>前者主要负责对亮度的感知</li><li>后者负责感知色彩</li></ul></li><li>我们主要关注感知色彩的锥状细胞，它又能分为分别感知红绿蓝三种颜色的SML三种细胞</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122148.png" alt="image.png"><br>                      <code>1.2.5 锥状细胞感受管线波长图</code></li><li>很明显他们感知的光线光波长度不一样。</li></ul><hr><h2 id="1-2-6-色彩的猜想"><a href="#1-2-6-色彩的猜想" class="headerlink" title="1.2.6 色彩的猜想"></a>1.2.6 色彩的猜想</h2><ul><li><p>人们猜想人的眼睛有数百种感光细胞感受不同颜色</p></li><li><p>人们猜想人有三种细胞分别感受红绿蓝三种颜色</p></li><li><p>人们猜想人分别有感知黑白，红绿，黄蓝这几种细胞</p></li><li><p>后来第二种和第三种分别演变为了两种色彩模型</p></li></ul><hr><h2 id="1-2-7-艺术家们的Munsell色彩系统"><a href="#1-2-7-艺术家们的Munsell色彩系统" class="headerlink" title="1.2.7 艺术家们的Munsell色彩系统"></a>1.2.7 艺术家们的Munsell色彩系统</h2><ul><li>来自于美国艺术家AlbertHenryMunsell</li><li>是通过色卡描述色彩，旋转轴是色相，垂直是亮度，由内到外是饱和度</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122917.png" alt="image.png"><br>                      <code>1.2.7 Munsell 颜色描述系统</code></li></ul><hr><ul><li>更多是<strong>基于经验而不是物理</strong>，不过这种HSL（色相饱和亮度）的色彩方法仍然被大多数艺术家所接受，至今活跃于各大DCC软件平台中。（如Photoshop）</li></ul><hr><h2 id="1-2-8-科学家们的-RGB-CSS系统"><a href="#1-2-8-科学家们的-RGB-CSS系统" class="headerlink" title="1.2.8 科学家们的 RGB CSS系统"></a>1.2.8 科学家们的 RGB CSS系统</h2><ul><li>即RGB Color Specification System（RGB色彩规格系统）</li><li>来自于CIE在1931年建立的色彩系统，从物理的方式客观描述量化色彩 </li><li>通过三原色打光进行观察对比，对于不同的光得到不同的参数值，最后的的结果如下：</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022133857.png" alt="image.png"><br>                      <code>1.2.8 RGB CSS 描述系统波形图</code></li></ul><hr><ul><li>图中表示方式并不规范，因此科学家又对其进行了归一化操作。这个操作在图形学中很常见，主要是为了更加规范的量化数值，便于表述和调节，这里我们使用将rgb三个量相加并且分别被rgb的量所除去的方式建立这个归一化算式：<ul><li><code>R&#39; = R/RGB,   G&#39;= G/RGB,   B&#39; = B/RGB</code></li></ul></li><li>至此，利用此算式和其变式，我们就可以用其中两个已知数计算另外一个数的值。</li></ul><hr><h2 id="1-2-9-基础的色域概念"><a href="#1-2-9-基础的色域概念" class="headerlink" title="1.2.9 基础的色域概念"></a>1.2.9 基础的色域概念</h2><ul><li>在此基础上，我们将r与g分别作为xy轴，就可以创建一个二维色彩空间，来描述一个颜色r与g部分的组成，前文我们可知，任何一个颜色都是可以由两个参数得出的，因此b就可以通过r与g计算得到。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022134614.png" alt="image.png"></li></ul></li></ul><hr><ul><li>XYZ色彩空间<ul><li>在上述二维色彩空间或称色域的基础上，为了避免出现负数，科学家又进行了一次迭代，这是用数学的方式做的一次更新，避免了<strong>负数的产生</strong>，但本身目的就是为了<strong>简化计算</strong></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135023.png" alt="image.png"></li></ul></li></ul><hr><ul><li>转换的方式：<ul><li>XYZ转换使用了矩阵进行转化计算，矩阵相关运算我们在下一节进行，这里只需要知道，矩阵起到了转换空间坐标的作用：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135351.png" alt="image.png"></li></ul></li></ul><hr><ul><li>为了便于计算，人们同样对该矩阵进行了归一化操作：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135429.png" alt="image.png"><br>          <code>XYZ转换矩阵进行归一化操作</code></li></ul><hr><h2 id="1-2-10-色域与Yxy色彩空间"><a href="#1-2-10-色域与Yxy色彩空间" class="headerlink" title="1.2.10 色域与Yxy色彩空间"></a>1.2.10 色域与Yxy色彩空间</h2><ul><li>经过1.2.9的演变最终形成了色域马蹄图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135719.png" alt="image.png"><br>               <code>色域马蹄图</code></li></ul><hr><ul><li>但这只是一张二维图片，虽然是人眼可见的色域范围，但并没有亮度表示，因此又将Y轴单独拿出来与xy组成了Yxy色彩空间，这个色彩空间中的Y轴是亮度：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140002.png" alt="image.png"><br>                  <code>Yxy色彩空间</code></li></ul><hr><h2 id="1-2-11-色彩空间的定义"><a href="#1-2-11-色彩空间的定义" class="headerlink" title="1.2.11 色彩空间的定义"></a>1.2.11 色彩空间的定义</h2><ul><li>一个色彩空间所具备的基础<ul><li>色域（三个基色坐标，由此形成三角形）</li><li>伽马（对三角形进行切分,一种采样方式）</li><li>白点（色彩中心）</li></ul></li><li>Gamma值<ul><li>简单来说就是色域切分片段的比例，主要分为<ul><li>均匀切割（Gamma &#x3D; 1）便于计算</li><li>非均匀切割（Gamma !&#x3D; 1）</li></ul></li></ul></li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140752.png" alt="image.png"></li><li>对暗部描述更多，对亮部描述更少。</li></ul><hr><h2 id="1-2-12-sRGB空间"><a href="#1-2-12-sRGB空间" class="headerlink" title="1.2.12 sRGB空间"></a>1.2.12 sRGB空间</h2><ul><li>sRGB空间是一种常用的色彩空间，它的gamma值为2.2，由内而外切线越来越粗</li><li>为何要用gamma？<ul><li>便于储存（远古）</li><li>人对亮部信息感受少对暗部感受多</li></ul></li><li>目前大部分游戏都会使用线性空间。任何色彩空间都可以是线性的linear，但linear本身不是一个色彩空间，它只是一个伽马值。</li></ul><hr><h2 id="1-2-13-颜色的表示以及处理法"><a href="#1-2-13-颜色的表示以及处理法" class="headerlink" title="1.2.13 颜色的表示以及处理法"></a>1.2.13 颜色的表示以及处理法</h2><ul><li>我们来看在计算机中如何表示一个颜色</li><li>颜色通道<ul><li>我们通过八位二进制数来对颜色进行表示，八位二进制数最多能表示255个数值，一共三个通道24位二进制数，总共为1670万种。</li><li>这种格式也被称为R8G8B8格式</li></ul></li><li>颜色深度<ul><li>颜色深度就是二进制数的总位数，如上述这种格式的颜色深度为24位</li></ul></li><li>对于颜色的处理<ul><li>我们可以对颜色进行一些处理，比如对颜色值乘以一个数值，或者对两个颜色值进行加减法运算，这些都是常见的处理方式。但我们限制单个颜色通道的范围为0~255之间。大于或小于这个数值都会被归为最大或最小值。</li></ul></li></ul><hr><h2 id="进阶-1-2-14-色彩空间的转换"><a href="#进阶-1-2-14-色彩空间的转换" class="headerlink" title="进阶 1.2.14 色彩空间的转换"></a>进阶 1.2.14 色彩空间的转换</h2><ul><li>我们已经初步了解了色彩空间的概念，色彩空间有很多，我们可以通过程序方式，对色彩空间进行转换。各位可以运用自己的编程能力，完成一个RGB2HSV的转化运算。欢迎大家给出自己的解决方案！下面是提示：</li></ul><hr><ul><li>RGB2HSV</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141834.png" alt="image.png"></li><li>HSV2RGB<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141903.png" alt="image.png"></li><li>作为本章的小作业，我会在文末给出我的源码供大家参考！<br>  小提示：mod为取模运算，即取余数</li></ul><hr><h1 id="1-3-颜色模型"><a href="#1-3-颜色模型" class="headerlink" title="1.3 颜色模型"></a>1.3 颜色模型</h1><h2 id="1-3-1-什么是颜色模型"><a href="#1-3-1-什么是颜色模型" class="headerlink" title="1.3.1 什么是颜色模型"></a>1.3.1 什么是颜色模型</h2><ul><li>前文我们提到了色彩空间，其中简单介绍了两种颜色模型，颜色模型有很多，但它们可以大体上分为两类：加色法模型和减色法模型</li></ul><hr><h2 id="1-3-2-减色法模型（色料）"><a href="#1-3-2-减色法模型（色料）" class="headerlink" title="1.3.2 减色法模型（色料）"></a>1.3.2 减色法模型（色料）</h2><ul><li>减色法模型主要模拟现实中调颜料的过程，打印机的原理就是这样，我们之前讲过，颜色实际上是其材料发射出的颜色，而其余颜色都被吸收了，如果你去调一盘颜料，会发现最后混合在一起就会变为黑色(美术同学应该深有体会)</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144121.png" alt="image.png"></li></ul><hr><ul><li>但不管我们用什么颜料去调色也不应该会出现纯黑色，因此这个稍暗的颜色被称为黑色（K）</li><li>而它对应的三原色是品红M青色C和黄色Y因此也被称作CMYK模型。</li></ul><hr><h2 id="1-3-3-加色法模型（色光）"><a href="#1-3-3-加色法模型（色光）" class="headerlink" title="1.3.3 加色法模型（色光）"></a>1.3.3 加色法模型（色光）</h2><ul><li>与前文减色法相对，在计算机以及物理中，我们会用加色来模拟真正的光线，从纯黑一步步添加颜色，最后叠加在一起被称为白色，而构成它的三原色也就是我们熟悉的RGB三种颜色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144414.png" alt="image.png"></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>介绍了计算机图形学中图形渲染的基本概念，从画布和坐标系的基本定义入手，到光源、色彩及色彩空间的深入解析，再到颜色模型的区分。最终提供了一个基础的RGB转HSV的算法实现</li></ul><hr><h1 id="进阶作业案例"><a href="#进阶作业案例" class="headerlink" title="进阶作业案例"></a>进阶作业案例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HSV</span> &#123;</span><br><span class="line">    <span class="type">float</span> h; <span class="comment">// 色相</span></span><br><span class="line">    <span class="type">float</span> s; <span class="comment">// 饱和度</span></span><br><span class="line">    <span class="type">float</span> v; <span class="comment">// 价值 (亮度)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HSV <span class="title">rgbToHsv</span><span class="params">(<span class="type">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class="line">    HSV hsv;</span><br><span class="line">    <span class="type">float</span> r = rgb.r / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> g = rgb.g / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> b = rgb.b / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> maxVal = std::<span class="built_in">max</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> minVal = std::<span class="built_in">min</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> delta = maxVal - minVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算亮度</span></span><br><span class="line">    hsv.v = maxVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算饱和度</span></span><br><span class="line">    <span class="keyword">if</span> (maxVal != <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.s = delta / maxVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里如果 maxVal 是 0，说明 RGB 都是 0</span></span><br><span class="line">        hsv.s = <span class="number">0</span>;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 设定为 0</span></span><br><span class="line">        <span class="keyword">return</span> hsv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算色相</span></span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 如果没有颜色，则色相为 0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal == r) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * <span class="built_in">fmod</span>((g - b) / delta, <span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == g) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((b - r) / delta + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == b) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((r - g) / delta + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hsv.h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hsv.h += <span class="number">360</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hsv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RGB rgb;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 RGB 值 (r, g, b) 范围在 [0, 255] 之间: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; rgb.r &gt;&gt; rgb.g &gt;&gt; rgb.b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> (rgb.r &lt; <span class="number">0</span> || rgb.r &gt; <span class="number">255</span> || rgb.g &lt; <span class="number">0</span> || rgb.g &gt; <span class="number">255</span> || rgb.b &lt; <span class="number">0</span> || rgb.b &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RGB 值必须在 [0, 255] 之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HSV hsv = <span class="built_in">rgbToHsv</span>(rgb);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对应的 HSV 值为: &quot;</span> &lt;&lt; <span class="string">&quot;H: &quot;</span> &lt;&lt; hsv.h &lt;&lt; <span class="string">&quot;, S: &quot;</span> &lt;&lt; hsv.s &lt;&lt; <span class="string">&quot;, V: &quot;</span> &lt;&lt; hsv.v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>欢迎批评指正！</li></ul><hr><h2 id="参考资料以及链接"><a href="#参考资料以及链接" class="headerlink" title="参考资料以及链接"></a>参考资料以及链接</h2><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学0——图形学引入</title>
      <link href="/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/"/>
      <url>/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1-图形学能做些什么？"><a href="#0-1-图形学能做些什么？" class="headerlink" title="0.1 图形学能做些什么？"></a>0.1 图形学能做些什么？</h1><ul><li><strong>游戏方面</strong>：<ul><li><p>真实的渲染画面</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Forza%20Horizon%204%20Screenshot%202024.10.11%20-%2017.41.24.95.png" alt="Forza Horizon 4 Screenshot 2024.10.11 - 17.41.24.95.png"><br>                      <code>游戏：极限竞速：地平线四</code></p></li><li><p>风格化的渲染模式</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101238.png" alt="image.png"><br>                      <code>游戏：无主之地3</code></p></li></ul></li></ul><hr><ul><li><strong>特效电影方面</strong>：<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101412.png" alt="image.png"><br>                     <code>电影：黑客帝国</code></li></ul></li><li><strong>动画方面</strong>：<ul><li>真实系动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101636.png" alt="image.png"><br>                      <code>动画电影：疯狂动物城</code></li><li>三渲二风格动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101847.png" alt="image.png"><br>                      <code>动画短片：星穹铁道角色PV——飞霄【君莫笑】</code></li></ul></li></ul><hr><ul><li>设计与效果模拟<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022102238.png" alt="image.png"><br>                     <code>地形编辑软件：GeoGen</code></li></ul></li></ul><hr><ul><li>综上所属，实际上图形学本质上是属于人机交互与视觉传达的基础学科，它是<strong>物理与数学</strong>相结合的产物，用于描绘出现实世界的光影变化外貌轮廓。</li></ul><hr><h1 id="0-2-什么是渲染"><a href="#0-2-什么是渲染" class="headerlink" title="0.2 什么是渲染"></a>0.2 什么是渲染</h1><ul><li>渲染是将场景信息通过一系列操作（渲染流程）作为帧或者图像呈现在屏幕上的过程。</li><li>负责渲染帧或图像的部分被称为渲染引擎，渲染引擎如Unity，Ue等将场景的数据通过渲染流程呈现在屏幕上。</li></ul><hr><ul><li>学习图形学需要具备什么？<ul><li>需要具备一颗会<strong>观察生活，追求美好画面</strong>的审美的心</li><li>需要具备一个<strong>严谨分析，善于思考剖析原理</strong>的脑</li></ul></li></ul><hr><h1 id="0-3-究竟学习什么？"><a href="#0-3-究竟学习什么？" class="headerlink" title="0.3 究竟学习什么？"></a>0.3 究竟学习什么？</h1><ul><li>总体而言：学习基础，学习方法，学习思维模式，主要入门的是离线渲染中的光栅化部分</li><li>总体时间段：<ul><li><strong>基础课和入门课结束之后：11月中旬到春节前</strong></li><li>2025年寒假以前（除考试周外）：每周六下午一节</li><li>2025年寒假到春节前一周：每周两到三节</li></ul></li><li>分享形式：每周由部长与副部长轮流交替直播分享，有录屏文件</li><li>课程所需：电脑（不要求配置），Processing，VisualStudio，Photoshop<ul><li>提供课程录播文件（上传部长Bilibili），提供原版教案（上传部长博客网站），提供课程所需素材（包括但不限于代码，资产，软件等）</li></ul></li></ul><h1 id="0-4-具体阶段："><a href="#0-4-具体阶段：" class="headerlink" title="0.4 具体阶段："></a>0.4 具体阶段：</h1><ul><li>1.<strong>基础入门概念</strong>：<ul><li>画布，颜色模型，颜色深度和颜色表示等</li><li>数学：线性代数</li><li>计算机硬件</li><li>课程安排：两到三节课</li></ul></li><li>2.<strong>渲染管线综述</strong>：<ul><li>渲染管线的大致划分</li><li>各个阶段的详解</li><li>课程安排：一到两节课</li></ul></li><li>3.<strong>光栅化阶段1：变换与几何部分</strong><ul><li>聚焦单个片元： </li><li>如何绘制直线，三角形——配合代码编写程序</li><li>如何填充一个三角形？——配合代码编写程序</li><li>三角形的变换与着色</li><li>课程安排：四到五节课</li></ul></li><li><strong>4.光栅化阶段2：着色与处理</strong>  配合DCC软件<ul><li>介绍基础概念如着色模型处理技术等</li><li>介绍材质</li><li>介绍UV贴图等概念</li><li>课程安排：三到四节课</li></ul></li><li>综上，入门图形学课程深入浅出，为各位进行日后的创作与研究奠定理论基础，正所谓千里之行始于足下，我们一起进步！</li></ul><hr><p><strong>深入学习，找到自己感兴趣的方向!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——7</title>
      <link href="/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/"/>
      <url>/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/</url>
      
        <content type="html"><![CDATA[<h1 id="法线底层原理"><a href="#法线底层原理" class="headerlink" title="法线底层原理"></a>法线底层原理</h1><ul><li>法线是赋予模型材质凹凸感的工具，其本身实际上是一组组的向量数据，通过光线与这些向量数据做矩阵运算，来得到凹凸效果</li><li>Bump贴图和Normal贴图：<ul><li>两者都可以用于实现法线所能够实现的凹凸效果，但Bump只有单一的凹陷凸起变化，而法线则是可以向四面八方进行变化，因此它们视觉上的颜色也是不一样的</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015153242.png" alt="image.png"></li><li>不同的颜色代表不同的方向，这一点前文我们已经了解过了，其本质是对颜色通道的映射，因为颜色通道RGB本身也可以视作一种向量（颜色向量）</li></ul></li><li>面法线与顶点法线：<ul><li>每个顶点自然都有自己的法线方向，而面法线是通过对一个面片上的顶点法线（通常为3个）进行插值得到的。</li></ul></li></ul><hr><h1 id="法线与光照运算"><a href="#法线与光照运算" class="headerlink" title="法线与光照运算"></a>法线与光照运算</h1><ul><li>在图形学的学习过程中我们了解到，很多光照模型都加入了法线来进行不同着色程度的运算，这里我们可以简单抽象为：<ul><li>若法线方向与光照方向相反则为-1(注意计算中光线方向是由物体指向光源)</li><li>若法线方向与光照方向垂直则为0</li><li>若法线方向与光照方向相同则为1</li></ul></li><li>以上，我们可以简单得出一个拥有明暗交界面的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"></li></ul><hr><h2 id="Ue中的实现"><a href="#Ue中的实现" class="headerlink" title="Ue中的实现"></a>Ue中的实现</h2><ul><li>我们通过调取光源方向节点SkyAtomsphereLightDirection，用Dot节将其与VertexNormal节点做点积运算，最后得到一个上述效果的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154449.png" alt="image.png"></li></ul><hr><h1 id="法线贴图的数据原理"><a href="#法线贴图的数据原理" class="headerlink" title="法线贴图的数据原理"></a>法线贴图的数据原理</h1><ul><li><p>法线贴图是在切线空间的，而切线空间中的x，y轴分别为tan与bitan也就是切线与副切线，而与他们垂直的就是法线：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154804.png" alt="image.png"></p></li><li><p>根据这个原理，我们就可以进行一定的数据运算，来实现法线凸起的效果，因此我们可以分析出一张法线贴图实际上是分别具有三个颜色通道的值，分别代表tan，bitan方向上凸起程度，加在一起便成为了一张法线贴图，因此使用法线时需要使用RGB通道：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015155058.png" alt="image.png"></p></li><li><p>根据上面的原理，我们可以自行验证一下，三个方向是不是具备相互垂直的关系，我们利用dot节点和Append节点来用GB两个通道的值来代替R通道的值：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015160239.png" alt="image.png"></p><ul><li>R点积G得到的是除B通道外的值，因为这两个方向是互相垂直的，点积为0，取反之后得到的就是B通道的值了。不要想复杂哦！</li></ul><h1 id="不同的法线贴图"><a href="#不同的法线贴图" class="headerlink" title="不同的法线贴图"></a>不同的法线贴图</h1></li></ul><hr><ul><li>OpenGL法线与DirectX法线：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015165216.png" alt="image.png"></li><li>他们的最大区别是轴向不同，导致的结果就是代表的方向不同，会导致模型表面突出方向倒置，区别方法就是看符合左手坐标系还是右手坐标系，OpenGl右手DirectX左手，分别对应逆时针和顺时针</li><li>我们可以对其进行简单的取反操作来让轴向改变，由此来转换不同的贴图。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——6</title>
      <link href="/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/"/>
      <url>/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/</url>
      
        <content type="html"><![CDATA[<h1 id="棋盘格"><a href="#棋盘格" class="headerlink" title="棋盘格"></a>棋盘格</h1><ul><li><p>我们来看一个有趣的效果，顺便介绍UE中常用的三角函数节点。</p></li><li><p>上一节我们已经初步认识了三角函数的威力，学习并分析了arctan节点</p></li><li><p>今天，我们从最基本的sine和cosine节点来认识Ue中的三角函数节点以及作用。</p></li><li><p>效果分析：我们需要实现黑白相间的棋盘格，本质上就是黑白的重复，我们可以用PS简单实现一下，供我们分析！</p></li></ul><h2 id="PS中的实现"><a href="#PS中的实现" class="headerlink" title="PS中的实现"></a>PS中的实现</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%A3%8B%E7%9B%98%E6%A0%BC.png" alt="imag.png"></li><li>我们可以观察到，这个图形是由黑色（0）以及白色（1）区域构成的，那么我们需要考虑如何实现这个排序，黑色可以通过乘法得出，我们可以利用Mask节点，将这张图横竖分开，并进行操作，让它变为横竖都是黑白相间的纹理，这就要隆重介绍我们今天的主角——sine节点。</li></ul><h2 id="SIne节点"><a href="#SIne节点" class="headerlink" title="SIne节点"></a>SIne节点</h2><ul><li>SIne节点作为一个三角函数节点，它模拟的就是三角函数的数值，它有一个周期参数，并且拥有三角函数的最大值最小值，它接受一个标量并将其进行三角函数运算，会出现波峰和波谷，波峰为正值而波谷为负值</li><li>在Ue中就会显示为黑白相间的条纹颜色！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241014094712.png" alt="image.png"></li><li>如上图所示，这样我们就可以利用它来创建网格了！</li></ul><h1 id="网格的实现"><a href="#网格的实现" class="headerlink" title="网格的实现"></a>网格的实现</h1><ul><li><p>网格需要横向和竖向的排列，因此我们需要将原有的纹理坐标节点使用mask节点拆分为R通道与G通道，分别对其进行计算</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150346.png" alt="image.png"></p></li><li><p>随后，为了控制纹理细分数量，我们为两个拆分后的节点分别添加Multipl乘法节点，并且新建一个常量数值接入他们，我们通过控制常量的大小来控制网格的数量，实际上是控制uv的缩放</p></li><li><p>随后我们分别为这两个节点添加SINE节点，这样，我们就可以在SINE节点的预览窗口中观察到条纹状的纹理了</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150409.png" alt="image.png"></p></li><li><p>而后，我们需要考虑如何混合这两个结果，我们需要让黑的部分叠加白的部分，并保留下来，因此我们使用Multipl节点将两个结果值相乘，这样黑色（&lt;0）的部分就会被保留，因为0乘以任何数仍为0，于是我们就得到了一张有些模糊的网格图。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150436.png" alt="image.png"></p></li><li><p>这看起来还有些不对，因为sine得出的有很多非整数结果，它们导致我们的边缘值比较模糊（再次记忆我们的颜色值始终置于0,1之间）</p></li><li><p>因此我们需要将它们取整，我们使用Ceil节点，将其取整，这个函数我们高中就学习过，大于0的值会变为1,1-2则变为2，因此他们会取整为1，这样我们的边缘值就正常了！</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150455.png" alt="image.png"></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——5</title>
      <link href="/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/"/>
      <url>/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/</url>
      
        <content type="html"><![CDATA[<h1 id="材质中的渐变"><a href="#材质中的渐变" class="headerlink" title="材质中的渐变"></a>材质中的渐变</h1><ul><li>常用的渐变的分类<ul><li>方形渐变</li><li>中心渐变</li><li>角度渐变</li></ul></li><li>渐变与UV坐标的关系<ul><li>在Ue以及其它三维软件中，UV坐标的直观显示是一个由白到黑的颜色渐变，随着数值变化而渐变，因此这种显示方式决定了，我们可以利用它来进行渐变效果的模拟</li></ul></li></ul><h1 id="方形渐变"><a href="#方形渐变" class="headerlink" title="方形渐变"></a>方形渐变</h1><ul><li><p>方形渐变的拆解：</p><ul><li>方形渐变本质上，通过观察我们可以发现，实际上它就是两个方向渐变的叠加：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png" alt="未标题-1.png"></li><li>实际上我们可以通过从水平方向和竖直方向分别拆解这个渐变，它是由白（1）到黑（0）再到白（1）的过程，那么我们只需要让它的数值变化符合这个规律，并且在最后取其中的最小值即可完成上图效果的实现：</li></ul></li><li><p>详细实现过程（UE）</p></li><li><p>首先，我们需要进行的是第一部，UV坐标的分解和处理，当然，我们同样可以对二维数据同时处理，我们先考虑第二种：</p></li><li><p>创建UV节点（U+左键）并且创建一个Mask掩码节点，用于分离UV常量：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008100813.png" alt="image.png"></p></li><li><p>随后，我们根据拆解的分析，利用subtract节点，将数值范围调整为：-0.5,0,0.5，之后，我们利用绝对值节点ABS将数值取正，调整为0.5,0,0.5,再乘2，即可达成1,0,1的数值变化：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101232.png" alt="image.png"></p></li><li><p>但这时你若直接输出，则会发现它与我们的期待正好相反，我们所需要的是0，1，0，但现在是1,0,1，不用担心，我们只需将其取反，利用取反节点onesubx（1-x）即可将数值变化变为0,1,0：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101422.png" alt="image.png"></p></li><li><p>数值满足了，但此时若直接输出会发现，依然不是我们所需要的效果，这是为何呢？</p></li><li><p>原来实际上我们同时处理UV的代价就是它们是混合进行的，所以若想达到效果，就需要将混合去除，</p></li><li><p>我们同样利用掩码Mask节点，分离UV方向，然后做最后一步，那么就是按我们的需求混合，我们希望保留下黑色部分，黑色部分是0，也就是最小值min，因此我们需要利用最小值节点min，以此来获得最终图像的效果：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101750.png" alt="image.png"></p></li><li><p>这样我们的方形渐变就大功告成了！</p></li><li><p><strong>一些思考</strong>：</p><ul><li>既然它是一个效果材质，那么我们理应提供调节效果的手段，我们在目前先提供一个控制范围的参数，若想控制渐变的区域，我们可以利用之前学过的Power节点，让整体数值趋于0，这样我们就可以将渐变范围调整了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102405.png" alt="image.png"></li><li>其他的调整方式，也欢迎大家实践！</li></ul></li></ul><h1 id="中心渐变"><a href="#中心渐变" class="headerlink" title="中心渐变"></a>中心渐变</h1><ul><li>下面我们再来看一个类型，中心渐变</li><li>中心渐变的拆解：<ul><li>中心渐变是一个圆形，从中心向外变化，内部为0，最外部为1，常常用来作为相机晕影的效果出现</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102703.png" alt="image.png"></li><li>实际上，它是一个特殊的方形渐变，它是365°的方向上变化的方形渐变，正如圆本身是一个很多边的多边形一样。因此，我们可以用类似的思考方式去模拟：</li></ul></li><li>详细实现过程（UE）：</li><li>首先，同样我们需要创建一个UV节点，但与上面条件不同的是，我们需要利用另一个节点来完成对全部方向上渐变的计算，我们使用Distance节点，它可以测量输入值与一个接收的数值的距离，我们将其设定为0.5,0.5,也就是正中心的UV坐标，我们就可以的到一个很棒的效果，一个看起来不错的圆形渐变：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103405.png" alt="image.png"></li><li>但仔细观察你会发现，它有些暗，是的，它的变化范围并不是0-1而是0-0.75，这是为什么呢，根据简单的勾股定理计算，实际上斜边并没有到1，因此为了让它的范围正确，我们需要进行一系列调整，首先，利用乘法节点，将其范围增大到1以上，接着在利用subtract节点规范它的范围到0-1之间：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103621.png" alt="image.png"></li><li>我们可以肉眼直观地看到它的变化，接下来，我们依然要解决它数值相反的问题，所以使用1-x节点，调整它的数值范围，最后得到正确的效果。</li><li>我们可以利用我们得到的效果，制作一个晕影图片！</li><li>导入一张外部贴图，连接到一个新建的乘法节点上，并将1-x节点的输出连到这个乘法节点上：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104047.png" alt="image.png"></li><li><strong>同样的</strong>，我们也可以对其增加一些外部数据调整的节点，让这个材质更加具备一个材质应该有的属性！</li></ul><h1 id="角度渐变"><a href="#角度渐变" class="headerlink" title="角度渐变"></a>角度渐变</h1><ul><li>接下来是一个小难点，角度渐变</li><li>角度渐变的分析拆解：<ul><li>角度渐变实际上是根据角度的变化，渐变的颜色逐渐变化，也就是在一个圆（2π）的变化范围内，数据从0-1变化的过程，本质上与前两个渐变没有区别，难点在于它涉及到了一定的三角函数运算：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104626.png" alt="image.png"></li><li>不过我们依然可以对其进行分析，只要细心拆解，就不会有无法实现的效果，本篇略长，希望大家耐心学习，争取有所收获</li></ul></li><li>角度渐变的实现(UE):</li><li>首先，万变不离其宗，我们依然创建UV节点，同时分离UV方向，当然你也可以尝试不分离，并思考其中的关系，我们这里使用掩码Mask节点来分离UV：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105251.png" alt="image.png"></li><li>不同的是，我们需要对UV坐标进行数值上的调整，之前的调整方式有些麻烦了，我们可以通过一个高级节点来简化这个过程，但本质依旧还是一样的，只不过是一个上层的封装罢了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105422.png" alt="image.png"></li><li>这个节点可以接受四个数值，分别是原始的minMax值，和想要转换的max和min值，就可以将其变为对应数值范围的数据，随后，我们将其分别输出到一个关键节点arctan节点，它是我们实现这个效果的关键，从数学角度分析如下图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008115714.png" alt="image.png"></li><li>因此，我们得到的范围为从-π&#x2F;4到π&#x2F;4，也就是能看到的变化范围为45°,但实际上，ue中颜色变化范围是0-1，而45°还未达到上限，因此实际上我们看见的结果并非45度，而我们可以通过除法变化该图像范围</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008141113.png" alt="image.png"></li><li>该图实际显示的其实是-π到π，但实际上是0到2π所以如果我们将整个结果同时除以2π，最后我们将得到一个0-1范围的变化，而如果我们除以π，则是-1到0，0到1的变化，这里ue改变了原本数学的值域范围将它变为了-π到π的显示，而实际数值计算中却有所不同</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——4</title>
      <link href="/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/"/>
      <url>/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/</url>
      
        <content type="html"><![CDATA[<h1 id="数据维度的控制"><a href="#数据维度的控制" class="headerlink" title="数据维度的控制"></a>数据维度的控制</h1><ul><li>在UE中，我们可以利用一些节点来进行数据的拆分与提升，例如在UV方向上，我们就可以利用掩码节点Mask来进行通道的拆分，如下图所示，我们将原本的UV节点拆分为R(U)通道以及G(V)通道：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184403.png" alt="image.png"></li><li>同样，我们也可以利用节点将他们合并起来，对于合并输出节点Ue提供了基础的Append节点以及封装多个Append节点从而实现多个输入的MakeFloat系列节点，他们都可以接受两个以上的参数并将他们合并输出：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184606.png" alt="image.png"></li></ul><h1 id="色彩维度的控制"><a href="#色彩维度的控制" class="headerlink" title="色彩维度的控制"></a>色彩维度的控制</h1><ul><li>UE中图片的色彩控制有以下几种：<ul><li>Add节点的加法调节</li><li>Multiply节点的乘法调节</li><li>Power节点的乘方调节</li><li>CheapContrast与CheapContrastRGB的灰度和对比度调节</li><li>以及1-x节点的取反调节<br>  我们逐一进行介绍</li></ul></li></ul><hr><h2 id="ADD节点"><a href="#ADD节点" class="headerlink" title="ADD节点"></a>ADD节点</h2><ul><li>首先是Add节点，这一节点主要功能就是为原图像加上一个常量，因为图像输入的是RGBA通道值，就会为这些值加上一个量，如果大于1，则会为白色，这与我们之前了解的相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001194813.png" alt="image.png"></li></ul><hr><h2 id="Multiply节点"><a href="#Multiply节点" class="headerlink" title="Multiply节点"></a>Multiply节点</h2><ul><li>随后是Multiple节点，这一节点可以在原有通道的基础上，乘上一个常量，如果常量小于1，则会让整体变暗，大于一则变亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203147.png" alt="image.png"></li></ul><hr><h2 id="Power结点"><a href="#Power结点" class="headerlink" title="Power结点"></a>Power结点</h2><ul><li>再之后是Power节点，POW节点是指数节点，可以让原来的值乘以n次方，会让暗的地方更暗，亮的地方更亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203430.png" alt="image.png"></li></ul><hr><h1 id="CheapContrast以及RGB"><a href="#CheapContrast以及RGB" class="headerlink" title="CheapContrast以及RGB"></a>CheapContrast以及RGB</h1><ul><li>这两个节点分别是针对单通道的灰度调节节点以及针对三通道的对比度节点，实际区别就是接受的数据不一样，本身都是调节黑白灰关系的节点，为了让图片对比度更加明显：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203647.png" alt="image.png"></li></ul><hr><h2 id="1-x节点"><a href="#1-x节点" class="headerlink" title="1-x节点"></a>1-x节点</h2><ul><li>这个节点是为了取反操作而诞生的，本质上就是统一进行一个偏移，也就是减去1，这样图片的整体输出就截然相反了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204112.png" alt="image.png"></li></ul><hr><h1 id="一些额外的注意点"><a href="#一些额外的注意点" class="headerlink" title="一些额外的注意点"></a>一些额外的注意点</h1><ul><li>在上文提到POWER节点与CheapContrast节点都能让暗部更暗亮部更亮，而它们之间有什么区别呢？</li><li>答案是，他们的作用区间不一样，前者是在0-1之间，而后者则是以0.5为中间值进行变换，我们实践就会发现，结果就是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204718.png" alt="image.png"></li></ul><hr><h1 id="UV的运算"><a href="#UV的运算" class="headerlink" title="UV的运算"></a>UV的运算</h1><ul><li>UV节点可以控制一个纹理的缩放，本质是调整一个纹理的坐标位置，而模型的UV则与之无关，就好比UV是皮肤而纹理坐标是衣服，UV节点调整的是怎么穿这件衣服。</li><li>UV节点有几个重要参数：<ul><li>U方向偏移量</li><li>V方向偏移量</li><li>解除镜像U</li><li>解除镜像V</li></ul></li></ul><h2 id="U，V方向偏移量"><a href="#U，V方向偏移量" class="headerlink" title="U，V方向偏移量"></a>U，V方向偏移量</h2><ul><li>这两个参数控制的实际上是UV数值的大小，视觉上的效果就是UV相较于模型坐标的缩放大小，比如若增大UV的坐标，那么多出来的部分（因为UV本是0-1）就会平铺填充同样的图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214316.png" alt="image.png"></li><li>我们可以用ADD节点或Multiply节点来控制这个过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214413.png" alt="image.png"></li></ul><h2 id="U-V方向镜像解除"><a href="#U-V方向镜像解除" class="headerlink" title="U,V方向镜像解除"></a>U,V方向镜像解除</h2><ul><li>本质上，我们通过UV节点调节的纹理，是以0.5为中心调节的，若解除这一镜像，我们就会得到从0.5开始的纹理图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214651.png" alt="image.png"></li><li>上面的图像就是画面的下四分之一，也就是上端为0.5，左端为0.5的方式，这可以帮助我们进行一些的运算</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——3</title>
      <link href="/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/"/>
      <url>/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/</url>
      
        <content type="html"><![CDATA[<h1 id="数据是基础"><a href="#数据是基础" class="headerlink" title="数据是基础"></a>数据是基础</h1><ul><li>在Ue中，一切引擎中，一切都是由数据构成的。</li><li>Ue中最上层数据为四通道数据，即RGBA</li><li>数据代表颜色一样可以代表法线方向等等其他含义</li></ul><h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>本质都是向量的运算</li><li>一位数据因为是一个常量因此是可以与任意数据进行乘除法运算的</li></ul><hr><h1 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h1><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><ul><li>在Ue中基础颜色的色彩范围是0-1，它是根据输入值计算的，如果大于1则为1，小于0则为0.</li><li>而自发光颜色是可以无限增加的，直到照亮整个场景（配合虚幻五特有的Luman全局光照系统）</li></ul><hr><h2 id="色彩运算"><a href="#色彩运算" class="headerlink" title="色彩运算"></a>色彩运算</h2><h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><ul><li>前文提到，一切颜色依然是由数据组成的，因此我们同样可以通过向量运算来计算颜色：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090525.png" alt="image.png"></li><li>Ue中的颜色计算使用了与现实世界颜料不同的减色法，即模拟自然光是由白光分出的红绿蓝三色光。</li><li>上图的运算我们可知，白色对应RGB通道值为（1,1,1）,这也对应了前文提到色彩范围是0-1</li><li>除法运算同理</li></ul><hr><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><ul><li>乘法运算是根据向量基础进行的运算，如果将上图中的红色通道与绿色通道相乘，那么结果为0，自然会显示黑色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090932.png" alt="image.png"></li><li>而白色为（1,1,1）,那么它与任何颜色相乘，仍为该颜色</li></ul><hr><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><ul><li>在除法运算之中，如果除数为0，则会保存一个有效值，若全为0 则会不进行这个运算，同样返回原有值，但不建议这样做！任何情况下！</li></ul><hr><h1 id="纹理图像的运算"><a href="#纹理图像的运算" class="headerlink" title="纹理图像的运算"></a>纹理图像的运算</h1><ul><li>纹理图像是一个一个数组，它们同样可以进行加减法运算，因为本质都是向量组成的，这也被称为矩阵。</li></ul><h2 id="图像的加减法运算"><a href="#图像的加减法运算" class="headerlink" title="图像的加减法运算"></a>图像的加减法运算</h2><ul><li>这里我们通过PS来进行观察：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092206.png" alt="image.png"></li><li>这里我们设置了线性减淡添加，这本事就是一种相加算法，它会让图片越来越亮</li><li>反之如果我们使用相减运算，那么就会让图片越来越暗</li></ul><hr><h2 id="图像的乘除法"><a href="#图像的乘除法" class="headerlink" title="图像的乘除法"></a>图像的乘除法</h2><ul><li>在Ps中，乘法被称为正片叠底，因为是乘法，如果黑色部位乘上一个不为黑色的部位，那么就会让图片变暗，并且保留黑色部分。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092704.png" alt="image.png"></li><li>PS中，除法运算的方式叫做划分，它会根据图像的乘除关系，让图片变亮抑或是变暗，取决于除数与被除数的大小关系</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093000.png" alt="image.png"></li></ul><hr><h2 id="偏差比例运算"><a href="#偏差比例运算" class="headerlink" title="偏差比例运算"></a>偏差比例运算</h2><ul><li>这是一种组合运算，先加上一个值再乘上一个值，相当于先进行加法运算，再进行乘法运算</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093835.png" alt="image.png"></li></ul><hr><h2 id="线性插值运算"><a href="#线性插值运算" class="headerlink" title="线性插值运算"></a>线性插值运算</h2><ul><li>本质上是一种混合运算，可以通过调节Alpha输入的值来控制线性插值的结果。我们同样可以通过输入某一个纹理的Alpha值来控制。</li><li>一般Alpha通道值需要一个一维向量为参数，我们可以通过Clamp或saturate节点来限制范围，后者在UnityShader中就很常见，它的系统损耗最低，我们一般倾向于使用它作为限制数值范围的工具，但它的范围只有0-1这一个固定参数范围，而前者clamp可以接受我们自主定义：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930094924.png" alt="image.png"></li><li>混合节点最好使用Saturate节点控制，这样可以减少性能损耗！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——2</title>
      <link href="/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
      <url>/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h1><ul><li>长宽必须是2的幂数，并且上线不超过8192，当然也可以导入不符合该标准的纹理，但这样Ue就无法为我们生成MIPMAP了。</li><li>简单来说，MIPMAP就是为我们生成一系列的图片，让我们在场景中根据距离远近智能调节纹理质量，以此来降低性能开销的一种手段，同样的手段为LOD，只不过后者是只能调节物体面数的，在UE中更为强大的Nanite系统将同时为我们做到以上两点。</li></ul><h1 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h1><ul><li><p>Ue支持很多纹理格式，例如psd，tga等，这两者也是最常用的无损格式之一</p></li><li><p>Ue支持一种叫做3Dtexture的贴图，它可以通过直接在内容窗口中创建得到，下面是它的原理图：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240929200955.png" alt="image.png"></p></li><li><p>一般用于特效制作</p></li><li><p>虚拟纹理：虚拟纹理是Ue所具有的一种动态加载纹理的功能，同样可以减少性能开销，它可以智能加载所需要的贴图，不加载看不见的贴图，从而减少开销。</p></li><li><p>虚幻同样支持由SD导入纹理材质球</p></li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>默认导入状态下，纹理会被压缩为DXTC或BC格式，而B8G8R8A8或G8表示未压缩，HDR格式纹理的FloatRGBA也不会压缩纹理。</li><li>Ue具备一种特有的纹理压缩模式，称为Oodle，是一种高效快捷的纹理编码，它有多层线性级别，通过控制<code>Lambda</code>值来调节压缩级别，一般<code>Lambda</code> &#x3D; 1为最优秀</li><li>详细可以参考Ue官方文档：</li><li><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/">https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/</a></li><li>请注意在移动端中暂时无法使用该选项</li></ul><h1 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h1><ul><li>创建材质实例可以帮助我们快速的调整场景中已有材质物体的材质属性，类似于类的对象这一概念</li><li>我们可以通过将纹理贴图等节点暴露为参数，从而在实例化的材质中自定义调节，它不会影响我们父材质的效果</li><li>SwitchParam节点可以帮助我们设置默认参数与自定义参数，如果打开实例节点中的对应选项就可以调节输入，并且取代我们的默认参数值，关闭则可恢复默认</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——1</title>
      <link href="/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/"/>
      <url>/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="材质编辑器"><a href="#材质编辑器" class="headerlink" title="材质编辑器"></a>材质编辑器</h1><ul><li>材质编辑界面主要由几部分组成，分别是材质图标，节点表，材质属性表，和各类操作面板：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220416.png" alt="image.png"></li><li>类似于Blender的原理化BSDF节点，一开始就会存在的是右侧的输出节点</li><li>我们需要通过连线的方式，将节点连接到对应的输出端口上</li><li>在操作完成后，我们需要进行保存和应用，这些操作全部在上方的材质编辑器的操作面板上完成</li></ul><hr><h1 id="一些常用的材质节点"><a href="#一些常用的材质节点" class="headerlink" title="一些常用的材质节点"></a>一些常用的材质节点</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220757.png" alt="image.png"></li><li>以上是一些常用的基础材质节点，分别是：<ul><li>1+左键： 常量节点，用于输入一个常量</li><li>2+左键： 一个二维向量节点，用于输入一个二维向量</li><li>3+左键：一个三维向量节点，可以看到对应的RGB值，输入一个三维向量</li><li>M+左键：乘法，接受两个常量输入，输出他们相乘的结果</li><li>T+左键：输入一个材质，可以选择一个图像，输出RGB或其他选项</li></ul></li><li>还有更多的节点可以通过右键呼出搜索面板来进行搜索，与blender shift+a类似</li></ul><hr><h1 id="常用的输出端简介"><a href="#常用的输出端简介" class="headerlink" title="常用的输出端简介"></a>常用的输出端简介</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928221546.png" alt="image.png"></li><li>根据我们选择着色模型的不同，也会有对应的不同的输出端口，但常用的基本一致，比如作为颜色信息的基础颜色，控制粗糙度的粗糙度端口。以下是逐项的介绍</li></ul><h2 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h2><ul><li>类似于UnityShader中的Color Tint，是作为基本的输出颜色存在的，决定了材质视觉上的呈现，往往直接可以连接一张Texture</li></ul><h2 id="金属感"><a href="#金属感" class="headerlink" title="金属感"></a>金属感</h2><ul><li>取值为0-1，所有的导电物体都应该具备的属性，可以让视觉上材质呈现出金属质感，类似于哑光质感。</li></ul><h2 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h2><ul><li>取值为0-1，类似于UnityShader中的_Gloss属性，用于控制高光的大小</li></ul><h2 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h2><ul><li>取值为0-1，用于控制物体的粗糙程度，可以接受Texture输入，类似于diffuse与Specular的混合程度，0即为100%Specular，1即为100%diffuse</li></ul><h2 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h2><ul><li>用于控制高光反射的形状，底层逻辑是一张采样的贴图</li></ul><h2 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h2><ul><li>用于控制物体自发光强度，数值越大发光强度越高，在UE中可以照亮周围的物体</li></ul><h2 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h2><ul><li>取值为0-1，用于控制物体可见性的数值，本质依然是不透明度混合的结果，这个数值就是可以对其的范围进行调节。可参考UnityShader中不透明效果的代码实现</li></ul><h2 id="不透明蒙版"><a href="#不透明蒙版" class="headerlink" title="不透明蒙版"></a>不透明蒙版</h2><ul><li>不透明蒙版可以做出类似PS中剪贴蒙版的作用，可以对有A通道的照片素材进行裁切，并且让场景中的面片跟随变化轮廓</li></ul><h2 id="法线与切线"><a href="#法线与切线" class="headerlink" title="法线与切线"></a>法线与切线</h2><ul><li>经常用作制作物体表面凹凸质感，在UnityShader中，可以在切线空间下计算法线贴图也可以在世界空间计算，美术更喜欢前者，因为可以清晰判别模型的各个视觉方向。</li></ul><h2 id="全局位置偏移"><a href="#全局位置偏移" class="headerlink" title="全局位置偏移"></a>全局位置偏移</h2><ul><li>移动模型位置，更多用于动态效果的创建</li></ul><h2 id="次表面颜色"><a href="#次表面颜色" class="headerlink" title="次表面颜色"></a>次表面颜色</h2><ul><li>需要配合次表面着色模型开启，开启后可以实现透光效果</li></ul><h2 id="折射与像素深度偏移"><a href="#折射与像素深度偏移" class="headerlink" title="折射与像素深度偏移"></a>折射与像素深度偏移</h2><ul><li>前者多为玻璃材质所需，后者则是软化模型交界处质感</li></ul><hr><h1 id="渲染模式与着色模型"><a href="#渲染模式与着色模型" class="headerlink" title="渲染模式与着色模型"></a>渲染模式与着色模型</h1><ul><li><p>在UE中一共有六种材质域，数种着色模型：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928223722.png" alt="image.png"></p></li><li><p>许多与Unity共同的特点，只不过有更好的封装进而有更便捷的实现。例如混合模式就是UnityShader中的Blend关键字，可以很容易的进行混合模式的开启，从而渲染半透明等材质</p></li><li><p>同样，着色模型也为我们提供了实现某些渲染效果更轻松的实现，这些都是UE为我们进行的优化。</p></li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>这一节，我们初步认识了UE的材质编辑界面，简单来说，就是利用可视化节点的方式代替code编辑从而便捷的实现效果，但请记住，本身仍然是一个个函数实现，因此结合Shader代码的学习必不可少！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——2</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的语言—二进制"><a href="#计算机的语言—二进制" class="headerlink" title="计算机的语言—二进制"></a>计算机的语言—二进制</h1><ul><li>计算机内部都是由IC（集成电路）组成的，它们只具有两种状态，&#x3D;&#x3D;高电平和低电平&#x3D;&#x3D;，这个特性决定了计算机的数据只能以二进制来处理。</li><li>计算机处理的最小单位：位，就相当于二进制中的一位，也叫做bit。</li><li>八位二进制数被称为一个字节，字节(byte)是基本信息计量单位，是基本单位。</li><li>再用字节处理数据时，&#x3D;&#x3D;如果数字小于存储的字节数&#x3D;&#x3D;，那么高位就用0占位填补。</li><li>&#x3D;&#x3D;二进制数可以表示文字&#x3D;&#x3D;，&#x3D;&#x3D;图像等&#x3D;&#x3D;，其表示的内容取决于程序的编写方式。</li></ul><h1 id="二进制数的计算"><a href="#二进制数的计算" class="headerlink" title="二进制数的计算"></a>二进制数的计算</h1><ul><li>二进制数的本质就是逢二进位，那么它与十进制的转化就是用每一位的数字乘以它的位权。位权的意思就是基数的对应位数指数。  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417094555.png">  指数由第一位开始向左累加。</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>移位运算是指将二进制数值个数为进行左右的移位。&#x3D;&#x3D;移位有左移&#x3D;&#x3D;，&#x3D;&#x3D;右移两种&#x3D;&#x3D;。 <ul><li>运算符：&lt;&lt;被称为左移运算符，&gt;&gt;被称为右移运算符，两者的左侧是被移位值，右侧是要移位的位数。</li><li>左移：左移空出的低位要进行补0操作。<br>  移位可以重来充当乘除法运算，左移两位数值会变为原来的4倍。</li><li>右移：二进制中表示负数值时，&#x3D;&#x3D;会将最高位当作符号位来使用&#x3D;&#x3D;，如果最高位为0则为正数，反之为1则为负数。<br>  这就区分了有符号数和无符号数，有符号数就是有符号位的数</li><li>补数：因为计算机实际上是在做加法运算来进行减法。![[计算机底层结构——1#^3cacdc]]<br>  获得补数的方式就是将全部数位取反再加1，补数与原来的数字之和为0，这很像是相反数。</li></ul></li><li>计算机中，0包含在正数范围内，所以负数要比真正的正数多一个。</li></ul><h2 id="逻辑右移与算术右移"><a href="#逻辑右移与算术右移" class="headerlink" title="逻辑右移与算术右移"></a>逻辑右移与算术右移</h2><ul><li>逻辑右移： 当二进制数的值表示图形模式而非数值时，移位后就需要在最高位前补0</li><li>算术右移：移位后需要在最高位前填充移位前的符号位的值，比如若为0，则需要填充1，反之亦然。</li></ul><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><ul><li>在保持值不变的情况下，将原有的低位数转化为高位数，直接用符号位填充前面的所有位数。</li></ul><h2 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h2><ul><li>逻辑非：1变0,0变1的取反操作</li><li>逻辑与：两者同时为1时，结果为1</li><li>逻辑或：至少一方为1时，结果为1。</li><li>逻辑异或：排斥相同，相同为0不相同为1</li></ul><h1 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h1><ul><li>在使用二进制存储数据时，我们往往会出现大量的数据，而如何简化其表示，以便操作，就是我们要考虑的问题，因此，&#x3D;&#x3D;我们出现了将二进制转化为8进制甚至16进制的操作&#x3D;&#x3D;。</li></ul><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><ul><li>八进制是二进制的简化表示，每位八进制数对应三位二进制数<br>  <code>二进制 001 = 八进制 1  </code>二进制010  &#x3D;  八进制2</li></ul><h2 id="二进制转化为八进制"><a href="#二进制转化为八进制" class="headerlink" title="二进制转化为八进制"></a>二进制转化为八进制</h2><ul><li>将二进制三位一组分开，每三位表示八进制数一位</li><li>如1011101 按三位一组分组 001，011，101(注意，高位是00可以直接省略)</li><li>对应八进制数135</li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><ul><li>16进制数分为0，T，2，3，4，5，6，7，8，9，A，B，C，D，E，F</li><li>每位十六进制数对应四位二进制数</li><li><code>二进制0000 = 十六进制0</code><br>  <code>二进制0001 = 十六进制1</code><br>  <code>二进制1111 = 十六进制F</code></li></ul><h2 id="二进制转化为十六进制"><a href="#二进制转化为十六进制" class="headerlink" title="二进制转化为十六进制"></a>二进制转化为十六进制</h2><ul><li>将二进制数每四位一组进行分割，每组对应一位十六进制数</li><li>如二进制数11011010四位一组为1101,1010<br>  对应十六位数DA</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——1</title>
      <link href="/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/"/>
      <url>/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul><li><p>CPU是集成了&#x3D;&#x3D;控制器，运算器，寄存器，时钟&#x3D;&#x3D;的终端，它负责将我们的&#x3D;&#x3D;汇编语言&#x3D;&#x3D;解释为&#x3D;&#x3D;机器语言&#x3D;&#x3D;，从而供底层微处理器执行。他们通过&#x3D;&#x3D;总线&#x3D;&#x3D;相互连接，传递数据和指令。</p><ul><li><strong>寄存器</strong>：用于&#x3D;&#x3D;暂存指令&#x3D;&#x3D;，&#x3D;&#x3D;等对象&#x3D;&#x3D;。是内存的一种</li><li><strong>控制器</strong>：负责将内存上的指令数据&#x3D;&#x3D;读入寄存器&#x3D;&#x3D;并依据结果&#x3D;&#x3D;控制整个计算机&#x3D;&#x3D;，主要是输入输出时间的控制。</li><li><strong>运算器</strong>：负责运算寄存器中的数据，并把结果输出。</li><li><strong>时钟</strong>：发出CPU开始计时的时钟信号。（&#x3D;&#x3D;信号频率越高，CPU运行越快&#x3D;&#x3D;）</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><strong>内存</strong>指的是计算机的主存储器，负责存储指令和数据。&#x3D;&#x3D;每个字节都有一个地址编号&#x3D;&#x3D;，cpu通过它来读取指令与数据。</li></ul><h1 id="CPU与寄存器"><a href="#CPU与寄存器" class="headerlink" title="CPU与寄存器"></a>CPU与寄存器</h1><ul><li>CPU是寄存器的集合体，程序将寄存器作为对象来描述。</li><li><strong>汇编</strong>：指的是将汇编语言转化为机器语言。</li><li>寄存器种类多样：比如有&#x3D;&#x3D;程序计数器&#x3D;&#x3D;，&#x3D;&#x3D;标志寄存器&#x3D;&#x3D;，累加寄存器，&#x3D;&#x3D;基址寄存器&#x3D;&#x3D;，&#x3D;&#x3D;变址寄存器&#x3D;&#x3D;等。</li></ul><h1 id="寄存器与程序执行"><a href="#寄存器与程序执行" class="headerlink" title="寄存器与程序执行"></a>寄存器与程序执行</h1><ul><li><strong>寄存器</strong>中的<strong>程序计数器</strong>被赋予了分配程序执行顺序的能力。当硬盘中的文件被复制到内存后，程计会被&#x3D;&#x3D;设定为初始值0100&#x3D;&#x3D;，然后开始运行，&#x3D;&#x3D;每当&#x3D;&#x3D;CPU执行完一个指令，程计中的数值都会进行&#x3D;&#x3D;累加&#x3D;&#x3D;操作。CPU会按照程计的数值，从内存中读取命令并执行。</li><li><strong>循环，顺序，条件分支</strong>：这三种执行方式组成了程序的流程。<ul><li><strong>条件分支</strong>：如果在程序执行的过程中，需要有条件分支语句，那么在程计中，遇到这个语句，&#x3D;&#x3D;会将程计的数值设置为对应的地址数值&#x3D;&#x3D;，这个操作被称为&#x3D;&#x3D;jump&#x3D;&#x3D;。</li></ul></li></ul><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417091436.png" alt="Pasted image 20240417091436"></p><ul><li><p><strong>&#x3D;&#x3D;标志&#x3D;&#x3D;寄存器</strong>：标志寄存器主要的作用为将累加寄存器中的结果&#x3D;&#x3D;状态&#x3D;&#x3D;进行记录，比如正负奇偶都会将其进行保存。所以在条件分支前，由其判断是否进行jump。标志寄存器&#x3D;&#x3D;前三个字节分别表示正0负三种状态&#x3D;&#x3D;。</p></li><li><p>标志寄存器的判断，实际上是对数值进行&#x3D;&#x3D;减法&#x3D;&#x3D;运算，通过结果设定状态。 ^3cacdc</p></li><li><p><strong>函数的调用</strong></p><ul><li>函数在调用时，在程计中会存在一个&#x3D;&#x3D;函数调用点&#x3D;&#x3D;。</li><li>call，return指令：call指令在函数入口地址设定到程计前，会把&#x3D;&#x3D;函数调用后&#x3D;&#x3D;要执行的地址存储在栈中。<br>  栈相关：[[内存与数据类型#栈]]<br>  函数处理完后，在通过函数出口来执行&#x3D;&#x3D;return&#x3D;&#x3D;指令，将栈中的地址设定到程计中。</li></ul></li><li><p>基址寄存器与变址寄存器：通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似数组的操作。数组相关：[[数组部分]] </p><ul><li>CPU会将基址寄存器和变址寄存器中的&#x3D;&#x3D;值之和&#x3D;&#x3D;视作实际要去查看的内存地址。变址寄存器相当于&#x3D;&#x3D;数组索引功能！&#x3D;&#x3D;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——0</title>
      <link href="/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/"/>
      <url>/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><ul><li><p>何为计算机？</p><ul><li>计算机是执行输入，计算，输出的机器</li></ul></li><li><p>何为程序？</p><ul><li>程序是指令与数据的集合</li></ul></li><li><p>何为计算机的处理方式？</p><ul><li>计算机的处理方式与人类习惯不同</li></ul></li><li><p>计算机由软硬件共同组成</p></li></ul><h2 id="输入，运算与输出是硬件基础"><a href="#输入，运算与输出是硬件基础" class="headerlink" title="输入，运算与输出是硬件基础"></a>输入，运算与输出是硬件基础</h2><ul><li>计算机硬件由大量IC（集成电路）组成</li><li>IC上有很多引脚，有的用于输入有的用于输出，IC会在内部运算输入的信息，并把结果输出。</li><li>所有的计算机操作都归于输入计算与输出缺一不可</li></ul><h2 id="软件是指令与数据的集合"><a href="#软件是指令与数据的集合" class="headerlink" title="软件是指令与数据的集合"></a>软件是指令与数据的集合</h2><ul><li>所有的操作都是基于一条一条指令</li><li>一组指令可以成为<strong>函数，方法，语句</strong>等等。程序中的数据分为两类，一类作为指令执行对象的输入数据，另一类是输出数据。</li><li>我们将数据称为<strong>变量</strong> 。</li><li>正如数学中的函数概念一样，往往我们都将程序中的方法写作：<br>  <code>y = f(x)</code></li><li>其中x为输入数据，这表示将x输入到函数y中</li><li>在程序中可能是这个样子的：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> answer = a+b+c/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序会通过编译（见1）将我们所写的高级语言代码转换成机器能看懂的机器语言代码。这会是一系列数值，它们既包含指令同样也包含数据。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240914112937.png" alt="image.png"></li></ul><h2 id="对于计算机来说什么都是数字"><a href="#对于计算机来说什么都是数字" class="headerlink" title="对于计算机来说什么都是数字"></a>对于计算机来说什么都是数字</h2><ul><li>计算机将一切都当作数字对待，最基础的可能是单纯的数字加减，但同样也可以是图片，音乐等等。</li></ul><h1 id="计算机组成简介"><a href="#计算机组成简介" class="headerlink" title="计算机组成简介"></a>计算机组成简介</h1><ul><li>计算机主要有CPU，内存和I&#x2F;O组成</li><li>CPU负责对数据运算和控制内存I&#x2F;O</li><li>内存负责存储CPU需要的指令与数据</li><li>I&#x2F;O则负责把键盘鼠标显示器等与主机连接实现数据的输入与输出</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>作为向美术等非专业人员介绍计算机相关内容的第一篇，诚惶诚恐，但愿能解答一些大家的疑惑，帮助大家更好的工作，本文会在后续持续跟进更改！感谢大家</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ul><li>计算机是怎样跑起来的（矢泽久雄）</li><li>程序是怎样跑起来的(矢泽久雄)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学7——光栅化1</title>
      <link href="/2024/01/12/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A67%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%961/"/>
      <url>/2024/01/12/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A67%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%961/</url>
      
        <content type="html"><![CDATA[<h1 id="7-0-前言"><a href="#7-0-前言" class="headerlink" title="7.0 前言"></a>7.0 前言</h1><ul><li>从本节开始，将开始真正结合编程知识开始大量实践，本课讲单独开设一个分专题来进行专门的编程实践部分分享，每节课都会有对应代码部分的章节，跟随实践的同学可以参考代码。</li></ul><hr><h1 id="7-1-相关基本概念"><a href="#7-1-相关基本概念" class="headerlink" title="7.1 相关基本概念"></a>7.1 相关基本概念</h1><h2 id="7-1-1-屏幕"><a href="#7-1-1-屏幕" class="headerlink" title="7.1.1 屏幕"></a>7.1.1 屏幕</h2><ul><li>关于屏幕，其具备基本的基础属性，如：长，宽，亮度，色彩范围等。</li><li>我们主要关注的是屏幕的长宽。</li><li>屏幕可以视为一个二维数组，其位置坐标可以表示为屏幕长宽中任意两个数字组合。</li><li>我们通过设置每一个数组元素的值来定义如何呈现需要呈现的点。</li></ul><hr><h2 id="7-1-2-像素"><a href="#7-1-2-像素" class="headerlink" title="7.1.2 像素"></a>7.1.2 像素</h2><ul><li>像素是屏幕的基本单位，也就是上述单个数组的具体实现方式。</li><li>我们目前阶段可以简单的认为像素是一个具有基本位置信息，由红绿蓝三个颜色通道值来定义的对象。</li></ul><hr><h2 id="7-1-3-光栅化"><a href="#7-1-3-光栅化" class="headerlink" title="7.1.3 光栅化"></a>7.1.3 光栅化</h2><ul><li>光栅化实际上就是我们设置屏幕像素的过程</li><li>光栅（Raster）在德语中的意思就是屏幕。</li></ul><hr><h1 id="7-2-屏幕视口坐标及其转化"><a href="#7-2-屏幕视口坐标及其转化" class="headerlink" title="7.2 屏幕视口坐标及其转化"></a>7.2 屏幕视口坐标及其转化</h1><h2 id="7-2-1-什么是屏幕视口坐标"><a href="#7-2-1-什么是屏幕视口坐标" class="headerlink" title="7.2.1 什么是屏幕视口坐标"></a>7.2.1 什么是屏幕视口坐标</h2><ul><li>屏幕视口坐标就是真正呈现在平面上的二维坐标系。</li><li>在先前我们通过矩阵变换将三维信息变换到裁剪空间之后，需要进行屏幕视口坐标的映射，这一步并不困难，实际上就是将对象的坐标位置变换到视口坐标原点，这一般是图像正中，但就像我们之前所提到的，根据不同的图形API规定，视口坐标也并不相同。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103153610.png" alt="image.png"><br>                      <code>7.2.1 屏幕视口坐标系</code></li></ul><hr><h2 id="7-2-2-屏幕视口坐标变换"><a href="#7-2-2-屏幕视口坐标变换" class="headerlink" title="7.2.2 屏幕视口坐标变换"></a>7.2.2 屏幕视口坐标变换</h2><ul><li>我们只需要使用一个很简单的矩阵变换就可以搞定了。</li><li>如下图，先将原本的（-1，1）的图像缩放至屏幕大小，对于单独的一个坐标应该是先将原本的宽高绝对值为2的NDC（设备归一化坐标）下的图形划归为1，随后再缩放到（w，h）大小，再将将元素的中心（原本是(0,0)）移动到屏幕中心(w&#x2F;2,H&#x2F;2)，将左下角作为（0,0）点。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103154056.png" alt="image.png"><br>                          <code>7.2.2 屏幕视口变换矩阵</code></li><li>到此为止我们就完成了将顶点从模型空间变换到在屏幕空间上的完整过程。</li></ul><hr><h1 id="7-2-3-将顶点映射到像素"><a href="#7-2-3-将顶点映射到像素" class="headerlink" title="7.2.3 将顶点映射到像素"></a>7.2.3 将顶点映射到像素</h1><ul><li>现在，我们具备了顶点信息，下一步我们需要以一定图元的方式呈现顶点，这样做的好处有：<ul><li>方便后续进行插值计算</li><li>方便更好的判断顶点位置</li><li>方便渲染减少开销</li></ul></li><li>一般使用三角形作为图元，那么我我们如何判断三角形对于像素的影响呢？</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103175601.png" alt="image.png"><br>                      <code>7.2.3 如何将三角形图元映射到像素上？</code></li><li>我们通过<strong>采样</strong>的方式来进行线性的图元到离散像素的变换。</li></ul><hr><ul><li>采样实际上就是用一个函数描述逐个像素点上对应的值的变化，我们可以写一个伪代码来描述它，实际上我很不喜欢伪代码，但如果作为表达方法实现的思路，倒是也有可取之处。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x =<span class="number">0</span>;x&lt;xmax;++x)</span><br><span class="line">output[x] = <span class="built_in">f</span>(x);</span><br></pre></td></tr></table></figure><ul><li>你可以看到实际上它就是对逐个离散化的x变量用一个函数输出到一个数组中。不理解数组没关系，你可以理解为就是输出到了屏幕上。</li></ul><hr><ul><li>理解了这个过程，我们就可以进行下一步的判断了，我们要去判断一个像素点是否在这个映射的范围内，如果在，则输出1否则输出0，像素中心可以理解为像素的x，y坐标分别+0.5个单位值对应的点，如图</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103180835.png" alt="image.png"><br>                          <code>7.2.3.1 离散后的像素中心点坐标</code></li></ul><hr><ul><li>所以它对应的伪代码应该是这样的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x =<span class="number">0</span>;x&lt;xmax;++x)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;max;++y)</span><br><span class="line"><span class="built_in">inside</span>(tri,x<span class="number">+0.5</span>,y<span class="number">+0.5</span>);</span><br><span class="line"><span class="built_in">inside</span>(triangle,<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">point newpoint = <span class="built_in">point</span>(x,y);</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">crows</span>(triangle.t1- newpoint,triangle.t1 - triangle.t2);</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">crows</span>(triangle.t2- newpoint,triangle.t2 - triangle.t3);</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">crows</span>(triangle.t3- newpoint,triangle.t1 - triangle.t3);</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>&amp;&amp;c&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此处对应的判断方法在之前的线代基础中已经提到过了，实际上就是用叉积检测点是否同时在三角形的同一边，如果是，则说明该点在三角形内。数学过程就不再赘述，欢迎大家回顾之前的内容。</li></ul><hr><h2 id="7-2-4-光栅化加速方法"><a href="#7-2-4-光栅化加速方法" class="headerlink" title="7.2.4 光栅化加速方法"></a>7.2.4 光栅化加速方法</h2><ul><li>AABB包围盒：<ul><li>现在如果我们按以上方法判断三角形与映射像素的关系，我们会发现，它太耗时间了！如果要遍历全部像素的话，的确是如此，但是我们可以只关注我们需要关注的部分，那就是三角形本身，我们可以只遍历三角形而不关注其他部分。</li><li>这种覆盖三角形的部分就叫做包围盒，类似于Unity等引擎中的碰撞箱。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104145440.png" alt="image.png"><br>                    <code>7.2.4 AABB包围盒</code></li></ul></li></ul><hr><ul><li>针对特殊三角形的特殊遍历</li><li>上面这样的三角形虽然很方便，但却太理想了，有可能会出现那种又窄又长的三角形，这时候再用包围盒，加速效果就远没有那么明显了，因此此时我们会使用针对这种三角形的遍历方式，那就是从左到右遍历，实际上在实现中我们也将使用这种方式，它将先查找三角形最左段然后逐一向右遍历，依次绘制：</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104150626.png" alt="image.png"><br>                      <code>7.2.4.1 特殊三角形的由左至右的遍历</code></li></ul><hr><h1 id="7-3-拓展"><a href="#7-3-拓展" class="headerlink" title="7.3 拓展"></a>7.3 拓展</h1><h2 id="7-3-1-真实的屏幕像素"><a href="#7-3-1-真实的屏幕像素" class="headerlink" title="7.3.1 真实的屏幕像素"></a>7.3.1 真实的屏幕像素</h2><ul><li>在现实中像素会像是我们上述所讲的样子吗？显然不会，实际上受击屏幕上的像素其实是由红绿蓝三原色像素条所组成的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104151013.png" alt="image.png"><br>                      <code>7.3.1 真实的像素屏幕</code></li><li>如果仔细观察会发现，实际上像素的绿色部分会更多，这是因为人眼对绿色光更为敏感，因此绿色部分占屏幕比例自然会更多。</li></ul><hr><h1 id="7-3-2-一些问题"><a href="#7-3-2-一些问题" class="headerlink" title="7.3.2 一些问题"></a>7.3.2 一些问题</h1><ul><li>现在，我们已经可以去实现将三角形填充在像素上了，但这个结果并不完美，因为填充的部分是均匀的，如果像素中心点不在三角形内，填充的结果就是空白，所以我们会得到下面这个结果，如何去优化它呢？等到下一节我们在去分析，在同期的程序部分，你将可以渲染出一个这样一个红色片元，我们模拟了这个过程。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104151449.png" alt="image.png"><br>                          <code>7.3.2 初步的光栅化结果</code></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li><li>Games101计算机图形学入门——闫令琪</li><li>计算机图形学入门——3D渲染指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
