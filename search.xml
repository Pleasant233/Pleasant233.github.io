<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客搭建感想</title>
      <link href="/2025/10/04/hello-template/"/>
      <url>/2025/10/04/hello-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><ul><li>本地化部署流程</li><li>线上发布流程</li></ul><hr><h2 id="本地化部署"><a href="#本地化部署" class="headerlink" title="本地化部署"></a>本地化部署</h2><ul><li>前期准备<ul><li>首先，本地化部署需要提前安装好两个东西，<br>可参考hexo框架官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>需要下载node.js，同时下载npm，也就是版本管理器，这些可以帮助我们管理博客版本内容。<ul><li>node.js 官网：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>你可以直接在官网复制它的代码并且打开本地自带的Windows命令窗口：powershell，粘贴你复制的代码</li><li>等待安装完成就可以了</li></ul></li><li>下载git，git主要作用是建立起云端和本地之间的桥梁，让我们能够从云端拉取数据。<ul><li>同样可以在官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a> </li><li>git安装相对简单，你可以直接全部选择next就自动安装完成了，很无脑！</li></ul></li><li>在安装完成后，本地的环境就基本上搭建完成了。</li></ul></li></ul><h2 id="线上发布："><a href="#线上发布：" class="headerlink" title="线上发布："></a>线上发布：</h2><ul><li>首先访问：<a href="https://github.com/mmdjiji/hexo-template">https://github.com/mmdjiji/hexo-template</a> 获取该库的代码，并且由此新建一个库，<br>详细教程可参考：<a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&vd_source=a506bd54314456e886d3818e488bb1c8">https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&amp;vd_source=a506bd54314456e886d3818e488bb1c8</a></li><li>断点发生在使用spacecode编辑处，因为该方法是完全基于云端的部署，所以完全依赖虚拟机的网速<br>然而经过多方验证，虚拟机网速堪忧，因此在此我们选择在本地部署！</li></ul><h2 id="独家揭秘！"><a href="#独家揭秘！" class="headerlink" title="独家揭秘！"></a>独家揭秘！</h2><ul><li>本地化部署就是本教程独一无二之处，大部分教程都会将两者割裂，但本教程才是最无脑的过程，<br>前文我们已经提到，云端部署十分缓慢，那有没有办法加快这个速度呢？</li><li>答案当然是有的！我们可以利用githubdesktop更快捷的进行上传与下载，避免云端网速的问题！</li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><ul><li>首先，下载githubdesktop，这个在你的库里local选项就能下载，为了方便起见，本文还是给大家配图</li><li>配图使用PicGo，同样也会给大家介绍，并且介绍obsidian中的PicGo联动小功能！</li></ul>  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20111142.png">   * 下载安装完成后，我们就可以将线上的库克隆到本地了，这里各位自行摸索即可，很简单，就不再赘述  ### 在bush窗口中完成部署    * 克隆完成后，我们需要再本地进行编辑，首先，找到克隆库所在本地文件夹，在文件夹中右键   * 打开选项栏，选择open git bush here   * 然后我们就嫩得到一个这样的窗口，很好，你已经几乎要完成它了！  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912111820.png">   * 随后，我们需要先安装hexo框架，在对话框中输入：   `$ npm install -g hexo-cli `   * 等待安装完成，在这里你可以加速这个过程，可将上述代码替换为：   `$ cnpm install -g hexo-cli`   * 这是一个国内镜像，但前提是你需要下载它，你可以通过powershell输入：   `npm install -g cnpm --registry=https://registry.npmmirror.com `   下载完成后，之后的所有需要npm的代码就都可以用cnpm替换了   * 之后我们继续键入`cnpm install`来安装依赖，请确保你进行了上一步！   * 在此之后，我们就完成了全部部署，你可以输入`hexo g`来检测部署结果   * 注意！按此方式部署的hexo是局部的，所以需要输入`npx+hexo...`命令！注意区分   * 若如图所示，则说明部署完成：  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912112800.png">   * 请注意，上图中，butterfly字样是主题，若未安装是不会显示的，这无伤大雅。  ### 配合github上传   * 第一阶段我们的githubdesktop就排上用场了，你只需要在面板中点击commit，   * 随后点击push origin 上传到云端即可了，返回到github库主页面，点击setting，查看page页面更新消息，你可以按F5刷新页面，不过多久，一个网站就搭建好了，并且你可以在本地完全控制它！---# 结尾   * 这是我的第一篇真正的博客，讲解了如何优雅而简便的搭建一个你的博客，接下来我会更新后续的内容，包括技术美术全部相关学习心得，笔记，随笔，图形学系列课程，希望能共同学习交流，那么最后一步！   * push to origin！---# 参考链接与项目 * 1.hexo官网：https://hexo.io/zh-cn/ * 2.b站up主：方欲遣兵北逐胡的视频：【基于Hexo搭建本地博客并部署到云服务器教程】 https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4 * 3.b站up主：吉吉学长的视频：【【Hexo | 03】创建属于你的追番列表】 https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4 * 全部为开源项目，不承担任何责任！！]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader基础篇5——透明效果</title>
      <link href="/2025/04/20/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%875%20%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/"/>
      <url>/2025/04/20/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%875%20%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-透明测试与透明混合"><a href="#5-1-透明测试与透明混合" class="headerlink" title="5.1 透明测试与透明混合"></a>5.1 透明测试与透明混合</h1><ul><li>我们之前在Untiy中实现的效果，都是不透明的，所以他们的渲染逻辑就是，启用深度缓冲（z-Buffer）以及深度测试（depthTest），如果片元深度比上一个片元在帧缓冲中的深度更近，则覆盖帧缓冲，呈现在我们眼前的永远是距离摄像机最近的片元。</li><li>想要实现透明效果，我们需要修改这个过程。而要想修改这个过程，我们就需要认识一个新的测试方式，那就是透明度测试（Alpha-test）以及真正实现半透明效果的透明度混合（Alpha-Blend）。</li></ul><hr><h2 id="5-1-1-透明度测试"><a href="#5-1-1-透明度测试" class="headerlink" title="5.1.1 透明度测试"></a>5.1.1 透明度测试</h2><ul><li>透明度测试简单而直接，如果一个片元的透明度不满足设定条件（比如一个具体的数值）那么久直接舍弃</li><li>这一步通常发生在vertex2Fragment之间</li><li>否则就会按照<strong>不透明</strong>的方式来处理。就会使用不透明流程中的深度测试，写入等。</li><li>因此透明度测试是不需要关闭深度写入的。</li><li>而这也决定了它只能做到剔除效果，比如一个透明背景的美术素材，用其处理就可以保留主体。</li><li>但如果想实现半透明效果，就需要进行更为复杂的透明度混合操作。</li></ul><hr><h2 id="5-1-2-透明度混合"><a href="#5-1-2-透明度混合" class="headerlink" title="5.1.2 透明度混合"></a>5.1.2 透明度混合</h2><ul><li>透明度混合实际上就是将透明物体与不透明物体按照一定比例进行颜色混合，最后得到半透明效果的过程。这个过程我们可以分为几个步骤来进行。</li><li>首先，我们需要正确处理不透明物体与透明物体的前后关系。</li><li>为了正确渲染场景，Untiy会先渲染所有不透明物体，在渲染队列中的标识为<code>Opaque</code></li><li>然后再渲染半透明物体<code>Transparent</code></li><li>如果物体属于半透明范畴，我们需要在标签中进行声明。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401110657.png" alt="image.png"><br><code>5.1.2 半透明物体渲染流程</code></li></ul><hr><ul><li>如果半透明物体在透明物体前，并且我们遵循从进到远绘制的不透明流程，我们首先需要<strong>关闭深度写入</strong>，但开启深度测试，这样透明物体就可以在一定范围内被选中，并且还可以不影响后方不透明物体的渲染。</li><li>而且对于多个半透明物体叠加的情况，在半透明队列中，渲染的方式也是从后向前进行的，这样就可以保证前面的半透明物体是叠加在后面的半透明物体上的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250401104738.png" alt="image.png"><br>  <code>5.1.2.1 透明度混合示意</code></li></ul><hr><h2 id="5-1-3-渲染顺序"><a href="#5-1-3-渲染顺序" class="headerlink" title="5.1.3 渲染顺序"></a>5.1.3 渲染顺序</h2><ul><li>那么我们该如何设置对应物体的渲染顺序呢，我们可以参考下表，这个表中标明了所有队列的用途和渲染顺序。</li><li>数字越大越靠后渲染。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-01%20110929.png" alt="image.png"><br><code>5.1.3 渲染队列</code></li><li>因此，对于透明度测试物体，我们就需要将其渲染队列设置为<code>AlphaTest</code></li><li>对于透明度混合物体，我们就要将其设置为<code>Transparent</code></li></ul><hr><h2 id="5-1-4-混合操作（Blend）"><a href="#5-1-4-混合操作（Blend）" class="headerlink" title="5.1.4 混合操作（Blend）"></a>5.1.4 混合操作（Blend）</h2><ul><li>最后，通过测试的片元会和帧缓冲之内的颜色进行<strong>混合</strong>操作。这一操作本质上就是将颜色按照预先设置的比例进行混合。</li><li>我们可以使用Untiy为我们提供的Blend命令，来对颜色进行混合。</li><li>这一阶段我们之前介绍过，是高度可配置的，因此，我们可以使用Untiy为我们提供的各类指令选定混合的函数，混合模式可以在SubShader与Pass中设置。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-01%20111643.png" alt="image.png"><br>  <code>5.1.4 混合模式设置语法</code></li><li>Blend模式有四种，我们一般使用的是第二种，即Blend SrcFactor DstFactor</li><li>我们希望混合的方式是透明度混合，因此我们实际上就是用两个片元的透明度进行插值。插值后的数值作为混合因子混合颜色。</li><li>所以我们使用的语句为<br><code>Blend SrcAlpha OneMinusSrcAlpha</code><br>对应的公式为<br><code>DstColor（new） = SrcAlpha * SrcColor + （1- SrcAlpha）* DstColor（old）</code></li></ul><hr><ul><li>一些常用的混合操作的写法：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/cccecdeeeb8389a74ae4f4e1cceae0a.jpg" alt="cccecdeeeb8389a74ae4f4e1cceae0a"><br>  <code>5.1.4.1 诸多混合操作</code>    </li><li>下面，我们就来实现一个透明度混合的基本效果。</li></ul><hr><h1 id="5-2-半透明混合"><a href="#5-2-半透明混合" class="headerlink" title="5.2 半透明混合"></a>5.2 半透明混合</h1><h2 id="5-2-1-基本的半透明混合"><a href="#5-2-1-基本的半透明混合" class="headerlink" title="5.2.1 基本的半透明混合"></a>5.2.1 基本的半透明混合</h2><ul><li>前文提到了半透明混合的思路，所以我们按图索骥，来实现基本的半透混合效果。</li><li>首先，我们需要保证渲染顺序的正确性，所以我们需要正确设置渲染的Tag，将队列设置为半透明，并开启忽略半透明的阴影（当然后面我们会启用）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>现在我们就可以来正式写我们的代码了，首先我们需要关闭深度写入，这样才能让后面的物体正常渲染，并且我们设置了混合模式，使用了Alpha混合。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZWrite Off  </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure><ul><li>接着，我们按照传统流程实现到片元着色器前的内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM  </span><br><span class="line">  </span><br><span class="line">#pragma vertex vert  </span><br><span class="line">#pragma fragment frag  </span><br><span class="line">  </span><br><span class="line">#include &quot;UnityLightingCommon.cginc&quot;  </span><br><span class="line">#include&quot;UnityCG.cginc&quot;  </span><br><span class="line">fixed4 _Color;  </span><br><span class="line">sampler2D _MainTex;  </span><br><span class="line">float4 _MainTex_ST;  </span><br><span class="line">fixed _AlphaScale;  </span><br><span class="line">  </span><br><span class="line">struct a2v &#123;  </span><br><span class="line">    float4 vertex : POSITION;  </span><br><span class="line">    float3 normal : NORMAL;  </span><br><span class="line">    float4 texcoord : TEXCOORD0;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">struct v2f &#123;  </span><br><span class="line">    float4 pos : SV_POSITION;  </span><br><span class="line">    float3 worldNormal : TEXCOORD0;  </span><br><span class="line">    float3 worldPos : TEXCOORD1;  </span><br><span class="line">    float2 uv : TEXCOORD2;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">v2f vert(a2v v) &#123;  </span><br><span class="line">    v2f o;  </span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">        o.worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">        o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">        o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  </span><br><span class="line">    return o;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接着就是最关键的片元着色器部分，我们正常的计算法线和光照，按照Lambert模型的计算方式，最后在返回颜色值时，将颜色的a通道与我们的参数中的_AlphaScale相乘，这样就可以完成不透明度的控制了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;  </span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);  </span><br><span class="line">    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));  </span><br><span class="line">    fixed4 texColor = tex2D(_MainTex, i.uv);  </span><br><span class="line">    fixed3 albedo = texColor.rgb * _Color.rgb;  </span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;  </span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));  </span><br><span class="line">    return fixed4(ambient + diffuse, texColor.a * _AlphaScale);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250407094635.png" alt="Pasted image 20250407094635"><br>  <code>5.2.1 透明度混合效果</code></li></ul><hr><h2 id="5-2-2-双面半透效果"><a href="#5-2-2-双面半透效果" class="headerlink" title="5.2.2 双面半透效果"></a>5.2.2 双面半透效果</h2><ul><li>现在，透明效果只有一面，我们无法实现拥有体积的半透明效果。所以接下来让我们来看看怎样实现拥有体积的半透，实际上也很简单。</li><li>目前我们讨论的效果，都是基于关闭深度写入从而实现的效果。为何无法实现体积效果呢？其本质实际上就是因为半透明物体自身无法实现混合效果，因此在混合阶段时直接被替换了颜色。因此，我们就需要对前后进行两次混合，这样就可以得到正确的双层半透效果了。</li></ul><hr><ul><li>要想实现两次混合也很简单，我们只需要从后向前渲染目标物体的两个面就好了，因此就要使用一个新的功能，那就是剔除。</li><li>剔除是渲染管线中的一个部分，发生在顶点与片元着色之间。（请注意，这里的剔除与裁剪并不是一个概念）。</li><li>其是可配置的部分，主要包含三种状态：FRONT，BACK，OFF</li><li>我们使用的方式就是，前后分Pass渲染，第一个Pass先剔除前部，让后方片元与物体后半部分进行混合，第二个Pass剔除后半部分，让前半部分与已经在帧缓冲中的后半部分混合结果再次混合，就可以得到双层效果了。</li></ul><hr><ul><li>代码非常简单，这里就不全部复制了，关键部分，就是两个Pass的剔除配置操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pass1</span><br><span class="line">Pass&#123;</span><br><span class="line">Cull Front</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">Pass 2</span><br><span class="line">Pass&#123;</span><br><span class="line">Cull Back</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250407100512.png" alt="Pasted image 20250407100512"><br><code>5.2.2 双层半透明渲染</code></li></ul><hr><h2 id="5-2-3-复杂前后遮挡的半透渲染"><a href="#5-2-3-复杂前后遮挡的半透渲染" class="headerlink" title="5.2.3 复杂前后遮挡的半透渲染"></a>5.2.3 复杂前后遮挡的半透渲染</h2><ul><li>有一些少数情况，部分模型可能存在自身的前后遮挡关系，这时候再使用之前的渲染方式，就会导致深度信息错误（本质就是认为该物体的各位置深度处在同一个值）这就导致会出现这样的错误效果：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250407100829.png" alt="Pasted image 20250407100829"><br><code>5.2.3 错误的半透效果</code></li><li>解决方式其实很简单，我们只需要额外增加一个Pass，该Pass不向帧缓冲写入任何颜色信息，这样就可以避免干扰之前的渲染，而只是写入深度信息，这样在接下来的混合Pass中，深度信息就正常了，我们就可以正常进行混合了。</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pass  </span><br><span class="line">&#123;  </span><br><span class="line">    ZWrite On  </span><br><span class="line">    ColorMask 0  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ColorMask是一个掩码标记，0的意思是全部过滤，也就是不写入任何信息。也可以指定RGBA通道进行过滤。</li><li>这样，我们就能得到一个正确显示的物体模型了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250407101223.png" alt="Pasted image 20250407101223"><br><code>5.2.4 深度正确的复杂半透效果</code></li></ul><hr><h1 id="5-3-透明度测试"><a href="#5-3-透明度测试" class="headerlink" title="5.3 透明度测试"></a>5.3 透明度测试</h1><h2 id="AlphaTest"><a href="#AlphaTest" class="headerlink" title="AlphaTest"></a>AlphaTest</h2><ul><li>透明度测试的本质就是，只要一个片元的透明度不满足条件（阈值），那么它对应的片元就会被舍弃。被舍弃的片元不会再进行任何处理，也不会影响颜色缓冲。</li><li>否则就按不透明物体来处理。</li><li>通常我们会使用clip函数来进行测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void clip(float1-4 x)</span><br></pre></td></tr></table></figure><ul><li>如果给定参数的任何一个分量为负，则舍弃当前像素的输出，等同于</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void clip(float4 x)</span><br><span class="line">&#123;</span><br><span class="line">if(any(x&lt;0))</span><br><span class="line">discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理十分简单，接下来我们就来尝试编写一个透明度测试的Shader。</li></ul><hr><ul><li>首先，在参数栏内，我们需要声明一个用于裁剪的float变量，其作为阈值，若图像纹理的Alpha值与之相减小于0，则省略这个片元。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;  </span><br><span class="line">       _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)  </span><br><span class="line">       _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;  </span><br><span class="line">       _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来，在SubShader的Tag部分，我们需要设定Queue为’AlphaTest”，这样才能正确的使用透明度测试。</li><li>并且我们将渲染类型设置为“TransparentCutout”。同样是为了正常进行裁剪。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>随后就是一系列常规操作，这里不多赘述，主要来看片元着色器部分。</li><li>我们在此处使用纹理自身的Alpha值减去之前在属性栏声明的数值然后传入到clip函数中，这样就能够完成透明度测试了。</li><li>剩下的代码与之前Lambert模型中的一致，这里就不多赘述了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Alpha test  </span><br><span class="line">             clip (texColor.a - _Cutoff);  </span><br><span class="line">             // Equal to //           if ((texColor.a - _Cutoff) &lt; 0.0) &#123;  </span><br><span class="line">//              discard;  </span><br><span class="line">//           &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>我们在使用透明度测试时，可以在Pass中添加 AlphaToMaskOn 这样才进行抗锯齿采样时，引擎会为我们增加边缘的采样次数，以达到抗锯齿的效果。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250408141828.png" alt="Pasted image 20250408141828"><br><code>5.3.1 AlphaTest</code></li></ul><hr><h2 id="5-3-2-模版测试"><a href="#5-3-2-模版测试" class="headerlink" title="5.3.2 模版测试"></a>5.3.2 模版测试</h2><ul><li>模板测试同样可以实现类似于透明的效果，当然模版测试可以实现的效果还有很多，比如传送门等。</li><li>其原理便是，每一个片元所对的像素分配一个模版值，用于控制显示哪个片元。</li><li>之前提到过，模版测试所在的管线位置是逐片元操作阶段，在这一阶段，我们就可以对片元的模版值进行测试，从而过滤掉我们不希望输出到帧缓冲的片元。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250409102628.png" alt="Pasted image 20250409102628"><br><code>5.3.2 模版测试所处阶段</code></li></ul><hr><ul><li>模版测试的逻辑：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if（referenceValue comparisonFunction stencil BufferValue）</span><br><span class="line">pass</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><ul><li>实际上类似于帧缓冲区，渲染管线也会为每个片元提供模版缓冲区，模版缓冲中记录的就是当前帧中所有片元的模版值。</li><li>对于Shader中对应的模版语法大致如下图所示。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250409103232.png" alt="Pasted image 20250409103232"><br><code>5.3.3 模版缓冲语法结构</code></li></ul><hr><ul><li>对于比较的操作而言也有一系列的操作内容，比如Greater大于，GEqual大于等于等。可参考下图</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250409103423.png" alt="Pasted image 20250409103423"><br><code>5.3.4 比较函数概览</code></li></ul><hr><ul><li>对于像素的处理我们也有一系列的方法可供选择，比如Keep保持缓冲中的值不变，Zero将0写入缓冲。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250409103559.png" alt="Pasted image 20250409103559"><br><code>比较后操作</code></li></ul><hr><h2 id="5-3-3-模版测试实践"><a href="#5-3-3-模版测试实践" class="headerlink" title="5.3.3 模版测试实践"></a>5.3.3 模版测试实践</h2><ul><li>我们来实现一个类似于笼中窥梦中的不同方向不同场景的效果。</li><li>我们先来分析如何实现这个效果，首先，我们需要具备两个材质，第一个材质是用于检测的材质我们可以叫它StencilTestMask，也就是作为一个遮罩去检测对应的模版值。另一个则是对应的物体，这种物体上的材质需要具备一个对应的模版缓冲值，如果相同则绘制，否则跳过不绘制。这就是我们的原理。</li><li>现在我们来实现Mask材质。</li></ul><hr><ul><li>Mask材质非常简单，实际上它不需要向帧缓冲输出任何值，这个在之前的半透明渲染中我们也使用过，当时是作为写入深度缓冲Pass的一部分而使用的，在此处则是为了检验模版值而使用的。</li><li>首先我们需要输入一个模版标准值，这个标准值是用来与对应物体模版缓冲中的值做检测用的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties  </span><br><span class="line">&#123;  </span><br><span class="line">    _ID(&quot;Mask ID&quot;, Int) = 1 //设置掩码数值  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着，我们需要正确的渲染该物体，我们需要声明其在渲染队列中的位置，我们希望它在所有不透明物体前渲染，因此我们需要将其声明在Geometry（几何）队列之后一项，我们可以简单的如此声明：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;RenderType&quot; = &quot;Opaque&quot; &quot;Queue&quot; = &quot;Geometry+1&quot;&#125; //设置渲染标签</span><br></pre></td></tr></table></figure><hr><ul><li>随后我们不希望其向帧缓冲中写入任何值，因此我们用掩码过滤掉。同时为了显示后方物体，我们同样不写入深度缓冲值，这样后续物体就能正常经过深度测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColorMask 0  </span><br><span class="line">ZWrite Off //这个材质只作为蒙版值使用因此不向帧缓冲与深度缓冲区输入任何值</span><br></pre></td></tr></table></figure><ul><li>接下来我们需要在SubShader中声明模版值和判断函数以及操作方法。</li><li>我们希望用ID作为参考值，并且默认开启比较，如果通过，则替换帧缓冲的角色。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stencil  </span><br><span class="line">&#123;  </span><br><span class="line">    Ref[_ID] //ID值作为参考值  </span><br><span class="line">    Comp Always //默认开启比较  </span><br><span class="line">    Pass Replace //通过则替换该像素颜色  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来的代码就很简单了，由于我们不需要显示这一层材质我们只需要正常传递参数实现材质就可以了，这里直接粘出来供大家参考。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pass  </span><br><span class="line">        &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            #pragma vertex vert  </span><br><span class="line">            #pragma fragment frag  </span><br><span class="line">            #include &quot;UnityCG.cginc&quot;  </span><br><span class="line">  </span><br><span class="line">            struct v2f  </span><br><span class="line">            &#123;  </span><br><span class="line">                float4 pos : POSITION;     </span><br><span class="line">            &#125;;  </span><br><span class="line">            v2f vert(appdata_base v)  </span><br><span class="line">            &#123;                v2f o;  </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                return o;  </span><br><span class="line">            &#125;            fixed4 frag(v2f i):SV_Target&#123;  </span><br><span class="line">                return fixed4(1,1,1,1);  </span><br><span class="line">            &#125;            ENDCG  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;    FallBack &quot;Diffuse&quot;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来就是需要检测的部分了，需要检测的目标我们也需要设置其模版值。</li><li>为了让其渲染正确，我们需要将其固定在检测器后一个队列位置中渲染，所以我们可以这样声明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot; = &quot;Geometry+2&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>我们可以简单的创建一个默认的表面着色器。然后在参数中同样声明一个ID值，该值作为传入模版缓冲中的值使用，随后，我们写入判断的方法，只有当检测值与模版值相等时才通过，渲染该片元。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stencil  </span><br><span class="line">&#123;  </span><br><span class="line">    Ref[_ID]  </span><br><span class="line">    Comp Equal //如果相等则渲染该片元  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后续代码都不需要更改，这样就完成了笼中窥梦同款效果，十分简单，但也是对于渲染队列以及管线理解的基础检测。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020250410150707.png" alt="Pasted image 20250410150707"><br><code>5.3.3 笼中窥梦效果</code></li></ul><hr><h1 id="结语与参考资料"><a href="#结语与参考资料" class="headerlink" title="结语与参考资料"></a>结语与参考资料</h1><ul><li>本节我们完成了所有基本的透明半透明渲染方式，当然还有很多进阶的内容，比如多层半透明渲染的效率以及前后遮挡的解决方案，基于插孔的半透渲染，以及基于Alpha剔除的半透渲染等，我们会在进阶分享中实现。</li><li>技术美术百人计划——【【技术美术百人计划】图形 3.1 深度与模板测试  传送门效果示例】 <a href="https://www.bilibili.com/video/BV1Tb4y1C7Qa/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Tb4y1C7Qa/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>UnityShader入门精要 冯乐乐著</li><li>UntiyShaderlab 新手宝典 唐福幸著</li></ul>]]></content>
      
      
      <categories>
          
          <category> UntiyShader基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader基础篇4——Untiy中的光照（下）</title>
      <link href="/2025/04/12/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%874%20Unity%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/04/12/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%874%20Unity%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="4-0-引子"><a href="#4-0-引子" class="headerlink" title="4.0 引子"></a>4.0 引子</h1><ul><li>在之前的学习中，我们了解了UntiyShader中材质与光线作用的基本方式与原理，并且实现了一系列基本的主流模型。最后完成了经典的<strong>布林冯模型</strong>。但是先前的学习中，我们只能处理简单的场景（也就是只有一个灯光的场景）。</li><li>那么接下来，我们将继续学习光照相关的内容，实现一个真正可用的模型，它能够处理所有灯光对其的交互。</li></ul><hr><h1 id="4-1-Untiy的渲染路径"><a href="#4-1-Untiy的渲染路径" class="headerlink" title="4.1 Untiy的渲染路径"></a>4.1 Untiy的渲染路径</h1><h2 id="4-1-1-何为-渲染路径（RenderPath）"><a href="#4-1-1-何为-渲染路径（RenderPath）" class="headerlink" title="4.1.1 何为 渲染路径（RenderPath）"></a>4.1.1 何为 渲染路径（RenderPath）</h2><ul><li>在这学期的分享中，我们接触了大量的专业词汇，可能会随时搞混，不过只要记住他们的特征，我们就可以理解他们的作用。</li><li>渲染路径实际上就是指光照<strong>是如何应用到UntiyShader</strong>中的。因此每个Pass都需要我们为其设置渲染路径，我们才能正确的处理光照。</li><li>渲染路径如果不能被显卡支持，则其会选择更低一级的渲染路径。例如如果不支持延迟渲染路径（Deferred Path）那么Untiy就会为我们使用前向渲染路径（ForwardPath）。</li></ul><h2 id="4-1-2-延迟渲染路径（Deferred-Path）"><a href="#4-1-2-延迟渲染路径（Deferred-Path）" class="headerlink" title="4.1.2 延迟渲染路径（Deferred Path）"></a>4.1.2 延迟渲染路径（Deferred Path）</h2><ul><li>延迟渲染路径顾名思义，是将着色阶段推迟的渲染路径，即使场景中有成百上千个灯光，也可以保持流程的渲染帧率，但是需要依赖硬件支持。</li><li>其本质就是对于灯光Pass基于G-Buffer（屏幕空间缓存）和深度信息计算光照，因为是基于屏幕空间，因此并不会因为场景复杂度而增加渲染时间。可以避免计算未通过深度测试的片元，并且每盏灯光都可以进行<strong>逐像素级别的计算</strong>，效果更加逼真。因为可以与法线贴图等进行逐像素的计算。</li><li>但延迟渲染也有其问题，因为着色的推迟，因此延迟渲染无法支持真正的MSAA抗锯齿，但是依然有相关方法可以支持（进阶篇会详细讲到），并且延迟着色无法处理半透明物体，会自动选择<strong>前向渲染进行渲染</strong>。</li></ul><hr><ul><li>延迟渲染对于灯光数量上的消耗并不明暗，主要还是针对灯光照射范围，和是否投射阴影。范围越大，阴影投射都会增加消耗。</li><li>延迟渲染只能在具备多重渲染目标，支持深度渲染贴图的显卡上进行。顾名思义就是可以通过一个DrawCall渲染多张纹理。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250313171255.png" alt="image.png"><br>  <code>4.1.2 多重渲染目标的实际应用</code></li></ul><hr><ul><li>并且延迟着色并不支持正交投影，因此二维游戏很多只能使用前向渲染路径进行渲染。下面我们就会介绍前向渲染路径，这也是目前我们最常用的渲染路径。</li><li>默认会生成数个渲染纹理（RenderTexture）：</li></ul><table><thead><tr><th>渲染图RT</th><th>RGB通道</th><th>A通道</th></tr></thead><tbody><tr><td>RT0</td><td>漫射</td><td>无</td></tr><tr><td>RT1</td><td>高光</td><td>高光指数</td></tr><tr><td>RT2</td><td>法线</td><td>无</td></tr><tr><td>RT3</td><td>自发光+探针</td><td>同左</td></tr><tr><td>深度缓冲和模版缓冲</td><td>……</td><td>……</td></tr></tbody></table><hr><h2 id="4-1-3前向渲染路径（Forward-Rendering）"><a href="#4-1-3前向渲染路径（Forward-Rendering）" class="headerlink" title="4.1.3前向渲染路径（Forward Rendering）"></a>4.1.3前向渲染路径（Forward Rendering）</h2><ul><li>前向渲染路径是传统的渲染路径，支持所有的图形功能。</li><li>前向渲染的目标是渲染该对象的<strong>渲染图元</strong>，并计算两个缓冲区的深度信息，来判断片元是否可见，如果可见则更新颜色缓冲区中的值</li><li>因此其渲染一个物体，往往使用一个或多个Pass，这取决于灯光的数量。因灯光的重要性不同，渲染方式也不同。</li><li>最亮的灯光往往会被用作逐像素的渲染方式，而四个点光源以逐顶点为渲染方式，剩下的灯光则以几乎不消耗性能的SH（Spherical Harmonics）球协函数的方式渲染。</li><li>起决定性作用的设置在于，渲染模式是否为Important，若为important则为逐像素渲染，<strong>最亮的平行光</strong>总是以逐像素方式渲染。</li><li>若设置为Auto，则Untiy会根据灯光的亮度以及距离物体的远近自动选择渲染方式。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250313172733.png" alt="image.png"><br>  <code>4.1.3 Untiy中的灯光重要性设置</code></li></ul><hr><ul><li>基础的Pass会包含一个逐像素的平行光，以及所有逐顶点，SH的光源，并且会包含来自Shader的光照贴图，环境光等，单只有平行光能够投射阴影，光照贴图不会接受SH的照明。</li><li>其余的逐像素光源会逐个增加Pass渲染，但默认不会投射阴影，要想让灯光投射阴影，就需要添加内置的编译指令：multi_compile_fwdadd_fullshadows编译出不同的Shader变体（Variant）。</li></ul><hr><ul><li>下面是前向渲染与延迟渲染的特性对比<br> <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/dc2d6138cec8c5d22b906a574528522.jpg" alt="dc2d6138cec8c5d22b906a574528522.jpg"><br>  <code>4.1.3.1 前向渲染以及延迟渲染对比</code></li></ul><hr><h1 id="4-2-前向渲染下的光照处理"><a href="#4-2-前向渲染下的光照处理" class="headerlink" title="4.2 前向渲染下的光照处理"></a>4.2 前向渲染下的光照处理</h1><h2 id="4-2-1-LightMode"><a href="#4-2-1-LightMode" class="headerlink" title="4.2.1 LightMode"></a>4.2.1 LightMode</h2><ul><li>先前我们提到过。LightMode标签是用作定义Pass在光照流水线中的作用，我们可以为不同的Pass设置不同的渲染标签来规定每个Pass的作用。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250313174440.png" alt="image.png"></li><li><code>4.2.1 不同的LightMode设置</code></li><li>正确的设置渲染标签，可以让引擎为我们提供相应的变量，我们只需要使用内置的光照变量来访问这些值即可，如果我们没有指定任何的渲染路径则可能会出现错误赋值。</li><li>我们可以在Pass的开头处声明该Pass的LightMode标签如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;“LightMode” = “ForwardBase”&#125;</span><br></pre></td></tr></table></figure><ul><li>这样我们就声明了一个在前向渲染路径下的Pass了。</li></ul><h2 id="4-2-2-多光源实现"><a href="#4-2-2-多光源实现" class="headerlink" title="4.2.2 多光源实现"></a>4.2.2 多光源实现</h2><ul><li>现在，我们有了对前向渲染的基本概念，就可以进入到如何实现多光源场景的部分了，首先，我们需要正确的获取光源变量的信息</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-24%20161807.png" alt="image.png"><br>  <code>4.2.2 多光源效果图</code></li></ul><hr><ul><li>对于光照而言，我们需要做的事情实际上就是根据光源的数个特点来对光进行描述和采样。最终作用到我们的渲染结果上。</li><li>光所具备的几个特点分别是：<strong>位置，半径，强度，衰减，方向</strong></li><li>因此我们也将以这几个特点为基础来进行光照的渲染。</li><li>首先，我们借用上节课最后的成果——布林冯模型，来对光照进行加工，先完成一个能够有多光源Pass的Shader，再在之后加入阴影，形成一个完整的标准的Standard Shader！</li></ul><hr><ul><li>首先，对于BasePass我们需要设置它的<strong>光照标签</strong>为Forwardbase,这样Untiy就可以为我们识别并在该Pass渲染最主要的平行光源，接着，我们需要添加<strong>Lighting包含文件以及UntiyCG包含文件，以此来获取正确的变量。</strong></li><li>最关键的部分就是我们需要添加编译指令，让Untiy为我们正确添加诸如_LightColor等值。</li><li>其余代码与上节课所写并无差异，最关键的部分就是，在最后我们需要添加一个atten变量，该变量即为<strong>光源衰减值</strong>，而该Pass所对应的平行光是主光源，无衰减，则值为1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed3 color = unity_AmbientSky + (diffuse + specular) * 1.0;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来就到了最关键的部分，我们需要为其余的光源添加另一个Pass，该Pass的光照标签为<strong>ForwardAdd</strong>表明它是附加的Pass，而因此我们就需要为该Pass设置混合模式，我们知道最后渲染的目标实际上是帧缓冲，因此如何对帧缓冲的值进行替换就是我们需要考虑的问题，在这里，我们就需要在最后的<strong>混合部分，设置混合模式，比如<code>Blend One One</code>的意思就是1:1混合也就是叠加上去。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125; //设置光照标签  </span><br><span class="line">Blend One One //设置混合模式</span><br></pre></td></tr></table></figure><ul><li>随后我们需要为该Pass添加编译指令，该Pass的编译指令与上一个Pass实际上就只差了最后的一串字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma multi_compile_fwdadd</span><br></pre></td></tr></table></figure><ul><li>其余的代码只需要全部复制过来即可，我们在最后的片元着色器中添加条件语句分支，来对不同类型的光源进行不同的设置。</li></ul><hr><ul><li>首先是对于光源类型，若不是平行光，那其就有位置远近的关系，以及光源向量，那么我们就需要来进行判别，获取正确的光源向量信息。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USING_DIRECTIONAL_LIGHT  </span><br><span class="line">    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);  </span><br><span class="line">#else  </span><br><span class="line">    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - mul(unity_ObjectToWorld,i.vertex).xyz);  </span><br><span class="line">    #endif</span><br></pre></td></tr></table></figure><ul><li>对于平行光，我们单纯获取其方向即可，而点光源以及聚光灯都有位置信息，因此，我们就需要去利用向量运算，获得指向物体方向向量的空间位置信息。</li></ul><hr><h2 id="4-2-3-光照衰减"><a href="#4-2-3-光照衰减" class="headerlink" title="4.2.3 光照衰减"></a>4.2.3 光照衰减</h2><ul><li>接下来，我们需要处理光照衰减，光照衰减，是根据灯光与物体距离计算得出的，光源距离物体越远，光照越不明显。</li><li>在Untiy中，有两种方式可以计算光源光照衰减值，一种是对灯光贴图进行采样，另一种是利用数学公式计算采样。</li><li>纹理采样的缺点是，需要预处理该纹理，并且一旦存储数据就无法使用其他公式计算衰减，但是可以提升性能，并且效果良好。</li><li>数学公式的缺点是，无法很好的解决聚光灯等光源形状问题，会在离开瞬间发生突变。因此本章我们主要使用的是灯光贴图采样法。</li></ul><hr><ul><li>灯光衰减是Untiy在内部使用一张贴图<br><code>_LightTexture0</code>来记录的。其中（0,0）点对应了与光源重合位置的衰减值，而（1,1）点则对应了光源空间中能受影响的最远一点的值。</li><li>为了采样该纹理，我们需要首先得到点在光源中的空间位置，这一般是通过_LightMatrix0 变换矩阵来将该点变换到光源空间的位置，然后使用这个坐标的模的平方（也就是距离）来对光照贴图进行采样，最后使用UNITY_ATTEN_CHANNEL来获取衰减纹理中衰减值所在分量，最终获得衰减值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USING_DIRECTIONAL_LIGHT  </span><br><span class="line">   fixed atten = 1.0;  </span><br><span class="line">#else  </span><br><span class="line">  </span><br><span class="line">   fixed3 lightCoord = mul(unity_WorldToLight,float4(mul(mul(unity_ObjectToWorld,i.vertex),1)).xyz);</span><br><span class="line">   fixed atten = tex2D(_LightTexture0,dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20114024.png" alt="image.png"><br><code>4.2.3 对于光源贴图的采样方式理解</code></p><hr><ul><li>对于聚光灯，我们还可以进一步的进行细分，通过添加条件分支，完善对聚光灯的衰减和光照处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#elif defined (SPOT)  </span><br><span class="line">    float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1));  </span><br><span class="line">    fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure><ul><li>实际上我们干的事情分为三部分，首先是进行空间有效性检测，对应<br><code>(lightCoord.z &gt;0)</code> 排除聚光灯背面的像素，因为聚光灯只对正方向的物体有贡献。</li><li>接下来是按形状处理衰减，首先使用光源纹理，通过将光源纹理由3D转化为2D并从【-1，1】映射到【0,1】坐标。用其w分量作为光源形状上的衰减数值与后续距离衰减相乘。</li><li>距离衰减与点光源距离衰减采样模式相同，同样是用点积代替复杂的开方运算节省性能。</li></ul><hr><ul><li>另一种添加多光源的方法：内置的Shade4PointLights()函数，该函数能够为我们添加四个点光源光照相加的结果。</li><li>并且其默认所有输入光源均为点光源，因此判断的结果并不完美。</li><li>但只限于点光源，而且衰减计算可能会出现问题，因为其内部是使用了数学方式运算而不是贴图纹理采样，并且开销也会更大。</li><li>使用该函数的方法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fixed3 color = diffuse;  </span><br><span class="line">  </span><br><span class="line">color.rgb += Shade4PointLights(unity_4LightPosX0,unity_4LightPosY0,unity_4LightPosZ0,unity_LightColor[0].rgb,unity_LightColor[1].rgb,unity_LightColor[2].rgb,  </span><br><span class="line">    unity_LightColor[3].rgb,unity_4LightAtten0,mul(unity_ObjectToWorld,i.vertex).rgb,worldNormal) * _DiffuseColor;  </span><br><span class="line">color += specular + unity_AmbientSky;  </span><br><span class="line">return fixed4(color,1);</span><br></pre></td></tr></table></figure><hr><ul><li>综合而言还是使用光源贴图采样的方式效果更好，性能开销也相对更低。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-25%20123454.png" alt="image.png"><br><code>4.2.3 左图为采样光源贴图，右侧为点光源函数</code></li></ul><hr><h1 id="4-3-Untiy中的阴影实现"><a href="#4-3-Untiy中的阴影实现" class="headerlink" title="4.3 Untiy中的阴影实现"></a>4.3 Untiy中的阴影实现</h1><h2 id="4-3-1-ShadowMap与ScreenShadowMap"><a href="#4-3-1-ShadowMap与ScreenShadowMap" class="headerlink" title="4.3.1 ShadowMap与ScreenShadowMap"></a>4.3.1 ShadowMap与ScreenShadowMap</h2><ul><li>ShadowMap 即阴影图，是在实时渲染中处理阴影映射的方式，其技术原理十分简单，就是将摄像机放在<strong>与光源重合的位置</strong>上，并记录一张纹理，这张纹理实际上是一张<strong>深度纹理</strong>。记录了从光源位置出发的能看到场景中最近的<strong>表面深度值</strong>。</li><li>在Untiy中，会使用一个额外的，LightMode为ShadowCaster的Pass用于专门更新光源的阴影映射纹理。其渲染目标是名为阴影映射纹理或深度纹理的RT。</li><li>如果开启了光源阴影，则渲染引擎会在当前渲染的物体中，寻找ShadowCaster Pass，若没有则回退到FallBack中，直到找到为止。当找到后，则就会用其来更新光源阴影映射纹理。</li><li>传统映射中，我们会在非ShadowCasterPass中将顶点变化到光源空间下，并用xy分量对阴影映射纹理采样。得到其位置的深度信息（阴影纹理中）随后，我们就会比较顶点深度（位于光源空间下的z坐标值）若纹理深度小于顶点深度，则说明该点位于阴影中。这样就完成了阴影的投射过程。</li></ul><hr><ul><li>而基于屏幕空间的处理方式，则是在后续显卡支持MRT即多重渲染目标后才得以支持的。其原本是延迟渲染下的一种阴影投射方式。</li><li>对于屏幕阴影映射而言，其会先调用ShadowCaster的Pass来得到投射阴影光源的阴影映射纹理，以及摄像机深度纹理，而后根据映射纹理和深度纹理来得到屏幕空间的阴影图。</li><li>若相机深度图大于阴影纹理中的深度值则说明可见但在阴影中。通过这样的采样，我们就可以得到包含在屏幕空间下的所有阴影区域，若有物体想要接受阴影，则采样阴影图，通过将该物体的定带你变换到屏幕空间中并采样即可。</li></ul><hr><ul><li>总结：若一个物体想要接受其余物体的投影，就必须在Shader中对阴影映射纹理采样，并将其与光照效果相乘产生阴影效果。</li><li>若一个物体想要投射阴影，则必须将其加入到光源阴影映射纹理中，从而让其余物体能够采样到它。</li><li>下面我们就结合已知进行实践完成阴影的处理。</li></ul><hr><h2 id="4-3-2-阴影投射"><a href="#4-3-2-阴影投射" class="headerlink" title="4.3.2 阴影投射"></a>4.3.2 阴影投射</h2><ul><li>如果要让某个光源投射阴影，首先需要将其允许投射阴影的选项打开，并且确保接受阴影的物体开启了ShadowCaster，如果取消，即使Shader内有相应的Pass也会忽略从而不执行。</li><li>如果我们现在对物体进行投射，我们会发现物体能够正常的显示阴影，这是因为Shader的FallBack中存在ShadowCaster。</li><li>但如果我们将光源原点置于物体之中，会发现阴影出现了残缺</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-26%20150153.png" alt="image.png"><br>  <code>残缺的阴影</code></li><li>这是因为球体本身是单面的，因此如果从光源处检测的话，则会认为光线在球体内，因此则不会投射出阴影。这时如果将Double-Sides打开的话，则会正常投射，因为这时球体则会是双面的。</li><li>接下来，我们来学习如何让物体接受阴影。</li></ul><hr><h2 id="4-3-3-接受阴影"><a href="#4-3-3-接受阴影" class="headerlink" title="4.3.3 接受阴影"></a>4.3.3 接受阴影</h2><ul><li>首先，接受阴影，意味着该物体需要对阴影图进行采样，所以我们需要准备采样的坐标，随后若支持屏幕空间阴影则变换其到屏幕空间下，与深度图进行采样比较，否则就将其变换到光源空间，使用传统的采样方式。</li><li>最后我们就将使用得到的阴影坐标对阴影纹理进行采样。接下来我们就来实现这个过程。</li><li>首先我们需要不包含一个新的内置文件<code>AutoLight.cginc</code>我们将用其中定义的宏来计算阴影。首先，我们添加了一个内置宏变量SHADOW_COORS()，该变量用于声明一个纹理坐标。其输入就是下一个可用的插值寄存器值，也就是TEXCOORDX中X+1的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123;  </span><br><span class="line">    float4 pos : SV_POSITION;  </span><br><span class="line">    float3 worldNormal : TEXCOORD0;  </span><br><span class="line">    float3 worldPos : TEXCOORD1;  </span><br><span class="line">    SHADOW_COORDS(2)  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">v2f vert(a2v v) &#123;  </span><br><span class="line">    v2f o;  </span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">        o.worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">        o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">    TRANSFER_SHADOW(o);  </span><br><span class="line">    return o;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>随后在顶点着色器中，我们就将变换顶点的坐标。使用TRANSFORM_SHADOW(o)宏定义，来对阴影坐标进行转换。这里的内部处理方式可以给大家参考一下。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-30%20124619.png" alt="image.png"></li><li>本质上就是通过一系列宏定义去判断何时需要怎样计算阴影，如何映射。</li><li>当能够运用屏幕坐标下的阴影计算时则执行对应指令。否则按照传统方式解决。</li></ul><hr><ul><li>最后来到片元着色器部分，我们利用之前的阴影纹理对其进行采样，计算阴影衰减，并将所得到的数值与最终的渲染结果颜色相乘，即可得到被其他物体投射阴影的物体。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed Shadow = SHADOW_ATTENUATION(i);  </span><br><span class="line">return fixed4(ambient + (diffuse + specular) * Shadow * atten, 1.0);</span><br></pre></td></tr></table></figure><hr><ul><li>当你的主光源开启阴影投射时，我们就可以注意到，物体上已经可以产生阴影了</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-30%20134912.png" alt="image.png"><br>  <code>4.3.3接受阴影的效果</code></li><li>但值得注意的是，这些宏变量的计算需要使用上下文信息，我们需要确保变量名匹配，a2v 中的顶点坐标变量必须是vertex，v2f中的顶点位置变量必须为pos。</li><li>目前该Shader只能处理平行光，后续我们将使其能够成为一个完整可用的Shader代码框架。</li></ul><hr><h2 id="4-3-4-光源与阴影衰减"><a href="#4-3-4-光源与阴影衰减" class="headerlink" title="4.3.4 光源与阴影衰减"></a>4.3.4 光源与阴影衰减</h2><ul><li>先前我们提到了光源如何进行衰减采样，以及阴影的实现，而阴影同样具备衰减特性，因此，我们就可以针对光源和阴影来实现一个统一的管理效果。</li><li>为此，我们使用Untiy为我们提供的宏来统一管理计算。该宏便是——UNITY_LIGHT_ATTENUATION。</li><li>这个宏定义是定义在AutoLight.cginc之中的，它实际上就是整合了Light的衰减与Shadow的衰减，并输出一个统一的衰减值。</li><li>其接受三个参数，其中，第一个参数atten是Untiy为我们自动创建的，因此我们只需要输入atten即可。而第二个以及第三个参数，则分别为v2f结构体以及其中的世界空间坐标，我们只需传入即可。</li><li>随后，如果我们希望额外的光源也产生衰减和阴影效果，则需要将编译指令 multi_compile_fwdadd 替换为multi_compile_fwdadd_fullshadows</li><li>这样Untiy就会为我们自动添加相关的数值到我们的参数中了。</li><li>最后我们就得到了本节课的最终目标，一个完整可用的布林冯Shader。目前，这个Shader已经可以用在任何场景之中了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-31%20143235.png" alt="image.png"><br>  <code>4.3.4 一个最终可用的完整的支持基本光照的布林冯模型</code></li></ul><hr><h1 id="4-4-结语与参考资料"><a href="#4-4-结语与参考资料" class="headerlink" title="4.4 结语与参考资料"></a>4.4 结语与参考资料</h1><ul><li>本节我们完成了全部的基础光照内容，最终实现了一个可以与任何光源交互的可用的Shader模型。接下来我们将从不透明进阶到透明效果阶段，这也是问题最多的一个阶段，我们将编写各类透明效果。</li><li>UnityShader入门精要 冯乐乐著</li><li>UntiyShaderlab 新手宝典 唐福幸著</li></ul>]]></content>
      
      
      <categories>
          
          <category> UntiyShader基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader基础篇3——Untiy中的光照（上）</title>
      <link href="/2025/03/30/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%873%20Untiy%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/03/30/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%873%20Untiy%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="3-0-前言"><a href="#3-0-前言" class="headerlink" title="3.0 前言"></a>3.0 前言</h1><ul><li>在进入光照篇之前，我们还需要再了解一些关于Shader编程的零碎知识，这些知识对于我们解决Shader的Bug，增进Shader编程能力有很大帮助。</li></ul><h2 id="3-0-1-帧调试器"><a href="#3-0-1-帧调试器" class="headerlink" title="3.0.1 帧调试器"></a>3.0.1 帧调试器</h2><ul><li>对于解决Shader出错的最好方式，就是Untiy为我们提供的辅助工具，帧调试器（FrameDebugger），我们可以在运行游戏后，点击Game视窗上方的小虫子图案启动它。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250224103705.png" alt="image.png"><br>  <code>3.0.1 帧调试器</code></li><li>它实际上就是将渲染中的各个事件（Event）为我们汇总到了一起，形成了树状结构，我们可以去查看每一次提交（DrawCall）的实际结果，帮助我们优化流程。</li><li>我们还可以查看其详细信息，比如该GameObject所应用的Shader信息，如是否开启了各类检测，剔除，ShaderTags or RenderSetup等。</li></ul><hr><h2 id="3-0-2-简化Shader"><a href="#3-0-2-简化Shader" class="headerlink" title="3.0.2 简化Shader"></a>3.0.2 简化Shader</h2><ul><li>对于Shader而言，高效的实现效果使我们需要考虑的前提，因此我们需要了解对于Shader而言的开销分布。</li><li>因为片元着色器的作用是处理插值后的逐像素操作，因此处理的消耗很大，实际上我们是通过GPU的寄存器等进行的数据处理和操作。</li><li>因此不要在片元着色器中进行过量计算。</li><li>ShaderTarget对应了我们能够使用多高级的ShaderModel，在我们先前的基础篇提到过。[[UnityShader基础篇2 初识Shader与Shader语言（下）#^8a5c23]]</li><li>我们可以在编译阶段指定更高的Target等级，运用更多的寄存器来解决这些问题。但请注意，在移动设备上的开销。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250224104617.png" alt="image.png"><br>  <code>3.0.2 指定对应的渲染目标等级</code></li></ul><hr><ul><li>减少使用分支与循环语句。</li><li>分支与循环语句在GPU中的实现与CPU不同，因此如果使用会降低GPU的并行处理操作，尽管现代GPU有所改善，但依然推荐各位慎用！</li><li>如果非要使用，可以借助以下方式优化<ul><li><ol><li>循环条件变量最好为常数</li></ol></li><li><ol start="2"><li>每个循环代码块指令尽可能少</li></ol></li><li><ol start="3"><li>分支嵌套层数尽可能少</li></ol></li></ul></li></ul><hr><ul><li>不要除0，对于这一点而言，数学上我们都能理解，在一般情况下，这是一个无意义的操作。</li><li>对于计算机而言亦然，因此我们可以强制将其截取为非0范围。也可以判断（当然开销略大）。</li></ul><hr><h1 id="3-1-光线基础回顾"><a href="#3-1-光线基础回顾" class="headerlink" title="3.1 光线基础回顾"></a>3.1 光线基础回顾</h1><h2 id="3-1-1-光线的基本定义"><a href="#3-1-1-光线的基本定义" class="headerlink" title="3.1.1 光线的基本定义"></a>3.1.1 光线的基本定义</h2><ul><li>就像我们之前的图形学学习一样，我们知道光是从<strong>光源</strong>发出的，在后期的PBR流程中，我们会更加科学严谨的定义光线。</li><li><strong>辐照度</strong>是指垂直于光线l的单位面积上单位时间内所穿过的能量也就是所谓的IR（可见同期光追分享） [[入门光线追踪2——辐射度量学#^b620d6|什么是IR]]</li><li>而IR与光线与平面法线夹角的<strong>余弦成正比</strong>，因此我们就可以用光线向量l与表面法线n点积来得到cos值。</li></ul><hr><ul><li>光线与物体交互，会产生不同的结果，大致可以分为两种<ul><li><ol><li>散射</li></ol></li><li><ol start="2"><li>吸收</li></ol></li></ul></li><li>前者又分为两种方向，一种会散射到物体内部，称为<strong>折射or透射</strong>。</li><li>而另一种则称为*反射</li><li>不透明的物体，内部的物质会继续与光线作用，一部分被物体吸收，另一部分重新发射出物体表面，这样物体就会发射出了<strong>不同的光线</strong></li><li>我们利用高光反射来表示物体如何发射光线，而漫反射则表示有多少光线会被折射，吸收，散射出表面。</li><li>我们可以计算光线的<strong>出射度</strong>（[[入门光线追踪2——辐射度量学#^8b3c27|ER的定义]]）,他们之间的比值就是漫射与高光反射属性值。</li></ul><hr><h2 id="3-1-2-光照模型"><a href="#3-1-2-光照模型" class="headerlink" title="3.1.2 光照模型"></a>3.1.2 光照模型</h2><ul><li>我们再次定义何为<strong>着色</strong>，这与光线追踪分享中相同，详细的可以参考光线追踪的分享。我们使用材质属性，光源信息，的等式来计算某个观察方向的出射度的过程，就被称为<strong>着色</strong>。</li><li>而不同的<strong>光照模型</strong>。对应了不同的等式。也是我们处理光线的方式。</li><li>我们可以通过一个函数模型去解决如果光线从一个方向照射到一个表面时，多少光线被反射，以及其方向，这就是所谓得到BRDF（双向反射函数），定义依然参考光线追踪部分的分享[[入门光线追踪2——辐射度量学#^525b6a| 何为BRDF]]。</li><li>关于更高级的PBR及其实现我们将在后续提升章节再介绍，我们现在介绍的是一种广泛用于游戏渲染中的经验模型——Blinn-Phong模型。</li><li>实际上我们之前已经在图形学入门中介绍了基本的Blinn-Phong模型概念。如有需要，请回顾[[入门图形学10——着色2#^daa208|BlinnPhong模型]], <a href="https://pleasant233.github.io/2025/01/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A69%E2%80%94%E2%80%94%E7%9D%80%E8%89%B21/">入门图形学10着色2</a></li><li>这里我们只需要回顾模型所包含的四个重要组成项——<ul><li>漫射（diffuse）</li><li>高光（Specular）</li><li>环境光（Ambient）</li></ul></li></ul><hr><ul><li>特别的，一些物理效果无法使用布林冯模型实现，例如菲涅尔反射等，我们会使用特定的着色模型实现。</li><li>并且布林冯模型是各向同性的，意味着反射不会因为我们视角的转变有任何变化，因此对于如金属，毛发等，我们需要学习基于物理的材质PBR。</li><li>接下来我们将正式进入Untiy，实现一系列简单的经验模型，在下一节课的最后给出一个完整可用的模型。</li></ul><hr><h1 id="3-2-Untiy光照与CG函数"><a href="#3-2-Untiy光照与CG函数" class="headerlink" title="3.2 Untiy光照与CG函数"></a>3.2 Untiy光照与CG函数</h1><h2 id="3-2-1-Unity的Lighting面板与渲染路径"><a href="#3-2-1-Unity的Lighting面板与渲染路径" class="headerlink" title="3.2.1 Unity的Lighting面板与渲染路径"></a>3.2.1 Unity的Lighting面板与渲染路径</h2><ul><li>我们可以在Untiy主界面上段选择windows选项框，现在Lighting面板被合并到了Rendering面板内，我们需要打开Rendering面板选择Lighting复选框，就可以看到Lighting面板了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250225094726.png" alt="image.png"><br>  <code>3.2.1 Lighting面板</code></li><li>在这里，我们可以修改天空盒材质，修改环境光照选项，我们可以选择环境光来源，其可以来源于<strong>skybox，gradient，color</strong>三个来源，我们可以设置后两者的颜色，这会对应我们在Shader文件中获取的<strong>Ambient（环境光）的颜色。</strong></li><li>我们一般会使用UNITY_LIGHTMODEL_AMBIENT这个宏来返回环境光照的颜色。</li></ul><hr><ul><li>关于渲染路径，我们将在后续详细提到，现在，我们只需要了解，修改不同的渲染路径，会影响Unity中的光照。我们可以在ProjectSetting中，修改Graphic选项卡中的RenderPath选项来修改渲染路径。一般我们会选择Forward（前向渲染）路径。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250225095535.png" alt="image.png"><br>  <code>3.2.1.1 对于不同的渲染平台我们可以配置不同的渲染策略</code></li><li>还有两种选择，一个是延迟渲染，另一个是顶点光照，前者拥有最高保真的灯光数量，后者则是最低保真的灯光数量，是Forward的子集。</li><li>关于RenderingPath的详细介绍，我们会在实现功能后进行。现在我们只需要了解如何修改它即可。</li></ul><hr><h2 id="3-2-2-Lambert模型"><a href="#3-2-2-Lambert模型" class="headerlink" title="3.2.2 Lambert模型"></a>3.2.2 Lambert模型</h2><ul><li>Lambert模型就是一种最简单的经验模型，其原理就是我们一开始对光线的定义中提到的，<strong>反射光线强度与表面法线和光线向量夹角成正比</strong>，这也是一种只有漫射的经验模型。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250225100329.png" alt="image.png"><br>  <code>3.2.2 Lambert模型公式</code></li><li>其只需要四个参数，即光线颜色，物体颜色，以及法线向量n和光线向量l。</li><li>对于max函数，我们在CG中有一个更加方便的实现。那就是saturate()函数，这个函数可以将输入限制到【0,1】区间内。</li><li>接下来，我们来进入正式的Shader编写，来一起完成一个兰伯特模型。</li></ul><hr><ul><li>首先，我们接着上一节的思路，我们可以迅速新建一个Shader文件，并对其进行改造，保留最关键的部分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/LambertShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于Lambert模型，我们需要一个最基本的漫射颜色，在Properties中输入即可，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DiffuseColor(&quot;Diffuse Color&quot;,Color) = (1,1,1,1)</span><br></pre></td></tr></table></figure><ul><li>随后，我们在SubShader中需要添加Pass代码块，这次，我们需要设置Pass的标签。</li><li>这一行指明了该Pass在光照管线中的角色，只有正确设置了Lightmode，我们才能正确得到一些内置变量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125; //设置光照标签</span><br></pre></td></tr></table></figure><hr><ul><li>同时我们需要添加光照包含文件“Lighting.cginc”，这样我们才能获取一系列的光照变量供我们使用。</li><li>接下来的声明内容就不再赘述，我们主要关注顶点着色器部分。这里放出代码。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125; //设置光照标签</span><br><span class="line">CGPROGRAM</span><br><span class="line">#include &quot;Lighting.cginc&quot;//包含光照包含文件</span><br><span class="line">#include &quot;UnityCG.cginc&quot;</span><br><span class="line">#pragma vertex vert</span><br><span class="line">#pragma fragment frag</span><br><span class="line"></span><br><span class="line">fixed4 _DiffuseColor;//声明材质颜色</span><br><span class="line">struct a2v&#123; // 声明参数结构体，当然可以使用内置的appdata_base进行传递</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    fixed3 color : COLOR;//传递颜色便于对颜色进行操作你也可以使用COLOR0 or TEXCOORD0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来我们关注顶点着色器部分，在这里，我们主要进行的计算就是将顶点信息进行相对应的变换，并利用兰伯特计算法，计算出漫射信息。</li><li>首先，我们需要变换<strong>顶点坐标</strong>，将顶点坐标变换到裁剪空间。</li><li>接着，我们需要变换法线，将法线从模型空间变换到<strong>世界空间</strong>，这样才能保证能够与光线运算。</li><li>在这里，我们也可以使用右乘逆阵的形式来变换法线，这样就可以避免因为不均缩放而导致的法线方向偏移。但在这里不多做赘述。</li><li>我们使用Unity内置的法线变换函数。随后我们将其归一化。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);//将顶点变换到裁剪空间</span><br><span class="line">       </span><br><span class="line">    float3 n = UnityObjectToWorldNormal(v.normal);//将法线变化到世界空间</span><br><span class="line">    //另一种写法：normalize(mul(v.normal,(float3x3)_Word2Object))已不常使用</span><br><span class="line">    n = normalize(n);//归一化法线向量</span><br></pre></td></tr></table></figure><hr><ul><li>接着，我们利用Unity为我们内置的变量_WorldSpaceLightPos0来获取灯光的位置，这个灯光是具备优先级限制的，我们会在下一节进阶篇中详细介绍，目前你可以理解为它会获取场景中自动添加的平行光位置</li><li>随后，利用兰伯特模型计算漫反射，我们就可以得到diffuse项了。</li><li>最后我们利用Unity内置的宏UNITY_LIGHTMODEL_AMBIENT来获取环境光变量，最后赋予v2f结构体中的Color变量，输出即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);//获取灯光方向</span><br><span class="line"></span><br><span class="line">fixed ndotL = dot(n,worldLight);//计算辐射度</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _DiffuseColor.rgb * saturate(ndotL);//利用兰伯特公式完成兰伯特光照计算</span><br><span class="line"></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; //获取环境光变量</span><br><span class="line">o.color = ambient + diffuse;//输出一个具有漫射和环境光的颜色值</span><br><span class="line">return o;</span><br></pre></td></tr></table></figure><hr><ul><li>最后，我们就可以得到一个具有基本的漫射的基于兰伯特模型的材质了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250225113936.png" alt="image.png"><br>  <code>3.2.2 兰伯特模型</code></li><li>我们发现虽然效果不错，但是在过渡阶段会有明显的锯齿，在我们之前的图形学分享中，我们了解到，这主要是因为着色频率较低[[入门图形学10——着色2#^e2c8d3| 着色频率回顾]]</li><li><a href="https://pleasant233.github.io/2025/01/22/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A610%E2%80%94%E2%80%94%E7%9D%80%E8%89%B22/">网页着色频率回顾</a></li><li>于是我们自然想到可以进行更高级的着色，也就是逐像素的着色，发生在片元着色器阶段，这也被称为Phong着色（记住这是着色方式而不是光照模型）。</li><li>接下来我们来看看如何在片元着色器中实现Phong着色。</li></ul><hr><h2 id="3-2-3-Phong着色（逐像素Lambert）"><a href="#3-2-3-Phong着色（逐像素Lambert）" class="headerlink" title="3.2.3 Phong着色（逐像素Lambert）"></a>3.2.3 Phong着色（逐像素Lambert）</h2><ul><li>我们之前提到过，尽量不要在片元着色器中进行大量计算，但为了让我们的效果更好，有时我们可以对不同的硬件平台选择不同的着色模式。</li><li>Phong着色与Lambert着色的其他设置我们可以保留，我们只需要关注顶点与片元着色器中的变化即可。</li><li>在定点着色器中，我们只需要进行顶点着色器所必备的顶点坐标系转换的工作即可，所以，我们的着色器代码就是只保留变换坐标系的功能即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">   // fixed3 color : COLOR;//我们不需要在vert中处理颜色所以不用管</span><br><span class="line">    float3 worldNormal: TEXCOORD0; //在这里我们可以用Tex作为数据类型传递</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>因此我们需要修改顶点着色器传递给片元着色器的信息，我们传递变换后的法线信息即可。</li><li>所有着色计算我们都将在片元着色器中进行，片元着色器是<strong>逐像素计算</strong>的，因此我们会得到更加细腻平滑的颜色变化。在片元着色器中，我们需要获取顶点着色器传递过来的法线信息，随后经过与逐顶点相同的计算就可以得到最后的效果了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">    fixed ndotl = saturate(dot(worldNormal,worldLightDir));</span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _DiffuseColor.rgb * ndotl;</span><br><span class="line">    fixed3 color = ambient + diffuse;</span><br><span class="line">    return fixed4(color,1);//返回颜色值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在的Pc平台基本上不会因为逐像素而牺牲过多性能，手机平台也迭代更新十分迅速，因此可以放心将计算放在片元着色器中。</li></ul><hr><h2 id="3-2-4-半兰伯特模型（HalfLambert）"><a href="#3-2-4-半兰伯特模型（HalfLambert）" class="headerlink" title="3.2.4 半兰伯特模型（HalfLambert）"></a>3.2.4 半兰伯特模型（HalfLambert）</h2><ul><li>半兰伯特模型是由半条命开发时Valve公司提出的。主要的目的就是修改在环境光照下，模型背面的阴影变化一样，僵硬的问题。</li><li>我们之前的做法是将值阶段在0-1区间，这会导致一些映射在0以下的值失去意义。导致背面数值均为0因此一片漆黑。</li><li>所以半兰伯特模型实际上做了一件十分简单的变化，那就是将数值的变化保留，只不过映射到0-1区间，这是一个很简单的数学思想。我们在编写Shader时时常会做这个操作也叫做clamp。</li><li>于是我们就可以简单的修改Phong着色的代码，将saturate部分更改为<ul><li>0.5 * （dot（worldNormal，worldLightDir））+0.5</li></ul></li><li>这样相当于将数值映射在了0-1区间。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">    fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">    fixed ndotl = 0.5*(dot(worldNormal,worldLightDir)) + 0.5;</span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _DiffuseColor.rgb * ndotl;</span><br><span class="line">    fixed3 color = ambient + diffuse;</span><br><span class="line">    return fixed4(color,1);//返回颜色值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250311151142.png" alt="image.png"><br><code>3.2.4 半兰伯特模型效果（右3）</code></p><hr><h2 id="3-2-5-高光反射"><a href="#3-2-5-高光反射" class="headerlink" title="3.2.5 高光反射"></a>3.2.5 高光反射</h2><ul><li>有了之前的学习检验，这里我们就直截了当的介绍基于下面这个公式的高光反射计算方法。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250311151812.png" alt="image.png"></li></ul></li><li>我们可以观察到该公式实际上是一个非线性的公式（因为有指数运算），因此在计算的过程中，我们就需要在插值后再进行该运算，这样就能避免破坏其非线性的性质。所以我们会在片元着色器中对其进行计算。</li><li>在之前的理论部分，我们提到过反射向量的计算方法，但在这里我们可以通过reflect()函数直接获取该值，其原理本质上还是我们之前的向量运算法则。</li><li>该函数需要两个参数，一个是光线入射方向，另一个是法线方向。</li><li>那么我们就直接来实现这个效果。</li><li>首先，我们需要计算每个着色点的情况，因为是光线是世界空间，因此，我们需要在世界空间下完成计算。</li><li>我们在顶点着色器的参数结构体中增加一项vertex，我们可以利用之前提到的使用TEXCOORD类型来进行声明。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">   // fixed3 color : COLOR;//我们不需要在vert中处理颜色所以不用管</span><br><span class="line">    float3 worldNormal: TEXCOORD0; //在这里我们可以用Tex作为数据类型传递</span><br><span class="line">    float4 vertex:TEXCOORD1;//顶点世界空间位置</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li>接着，我们就可以在片元着色器中进行计算了。在片元着色器中，我们按照公式计算即可。首先便是镜面反射向量，这个向量需要我们传入从该着色点到光线的向量因此传入的便是worldLightDir的相反数。接着，我们计算视角向量，直接使用Untiy为我们提供的函数即可，传入我们之前新声明的参数就好了。</li><li>最后就是按照公式将所有参数组合起来，就可以得到我们的镜面反射了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">//计算镜面反射</span><br><span class="line">fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal));//计算反射射线，但这里注意需要获取从着色点到灯光的向量因此取反</span><br><span class="line">fixed3 viewDir = normalize(WorldSpaceViewDir(i.vertex));</span><br><span class="line">fixed3 specular = _LightColor0 * _SpecularColor * pow(saturate(dot(reflectDir,viewDir)),_Glossy);</span><br><span class="line">//计算高光反射项。</span><br><span class="line"></span><br><span class="line">fixed3 color = unity_AmbientSky + diffuse + specular;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250312111158.png" alt="image.png"><br><code>3.2.5 镜面反射效果</code></p><hr><h2 id="3-2-6-BlinnPhong模型"><a href="#3-2-6-BlinnPhong模型" class="headerlink" title="3.2.6 BlinnPhong模型"></a>3.2.6 BlinnPhong模型</h2><ul><li>布林冯模型实际上是两个人的杰作，之前我们已经完成了冯模型，接下来我们来看布林冯模型。</li><li>布林冯模型的关键实际上就是在Phong模型的镜面反射部分做了一定的修改，可以使我们不用再计算较为复杂的反射向量而是使用半程向量的形式来进行模拟计算。 ^07e1f1</li><li>这部分原理在基础篇详细介绍过欢迎回顾<br>![[#^07e1f1| 布林冯模型回顾]]</li><li><a href="https://pleasant233.github.io/2025/01/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A69%E2%80%94%E2%80%94%E7%9D%80%E8%89%B21/#9-2-6-%E5%B8%83%E6%9E%97%E5%86%AF%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E8%AE%A1%E7%AE%97">布林冯模型回顾</a></li><li>于是我们只需要对反射向量部分进行修改即可。我们将反射向量修改为半程向量的计算方式。在远距离上，半程向量可以被看做一个恒定不变的值，因此大大减少了计算量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">fixed3 viewDir = normalize(WorldSpaceViewDir(i.vertex));</span><br><span class="line">fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">fixed3 specular = _LightColor0 * _SpecularColor * pow(saturate(dot(worldNormal,halfDir)),_Glossy);</span><br><span class="line">……</span><br></pre></td></tr></table></figure><hr><ul><li>这种方法计算的光线光圈会更大一些，看起来效果更好一些，BlinnPhong模型并没有正确与否的区别，只需根据需求选择效果即可。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250312114249.png" alt="image.png"><br>  <code>3.2.6 布林冯模型（右）与冯模型（左）对比</code></li></ul><hr><h1 id="结语与参考资料"><a href="#结语与参考资料" class="headerlink" title="结语与参考资料"></a>结语与参考资料</h1><ul><li>本篇我们介绍了Unity中基本的光照模型以及其实现方法，接下来，我们将深入光照部分，开始实现多光源光照以及阴影部分。</li><li>UnityShader入门精要 冯乐乐著</li><li>UntiyShaderlab 新手宝典 唐福幸著</li></ul>]]></content>
      
      
      <categories>
          
          <category> UntiyShader基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader基础篇2——初识Shader与Shader语言（下）</title>
      <link href="/2025/03/22/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%872%20%E5%88%9D%E8%AF%86Shader%E4%B8%8EShader%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/03/22/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%872%20%E5%88%9D%E8%AF%86Shader%E4%B8%8EShader%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-UntiyShader类型"><a href="#2-1-UntiyShader类型" class="headerlink" title="2.1 UntiyShader类型"></a>2.1 UntiyShader类型</h1><ul><li>上一节，我们大致了解了UnityShader的<em>基本概念与Shaderlab的基本语法，</em> 接下来我们将深入UnityShader内部，了解UntiyShader的着色器类型，以及其详细信息。</li></ul><h2 id="2-1-1-表面着色器"><a href="#2-1-1-表面着色器" class="headerlink" title="2.1.1 表面着色器"></a>2.1.1 表面着色器</h2><ul><li>如果我们在Untiy中新建一个着色器文件，那么默认的着色器应该是一个<strong>表面着色器</strong>，它是Unity自己创造的一种着色器类型，代码量少，但是<strong>渲染代价大</strong>，它其实是Untiy对于顶点着色器与片元着色器之上的一层更高的抽象，其为我们处理了很多<strong>光照细节（后续光照篇会详细讲到）</strong> 使我们可以更方便的编辑效果。</li><li>表面着色器的代码在SubShader中间，而没有Pass的概念，这是因为表面着色器<em>不需要我们去定义</em>使用多少个Pass我们只需要将数据传入到我们希望的地方，并告知其如何渲染，剩下的事情Unity都会帮我们完成，实际上最终也是翻译为顶点着色器与片元着色器代码。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250218111519.png" alt="image.png"><br>  <code>2.1.1 表面着色器代码片段</code></li></ul><hr><ul><li>我们可以发现，实际上被封装在代码块中的是CGPROGRAM与ENDCG中的代码片段，这些片段中的代码遵循的语言规范是CG&#x2F;HLSL，我们实际上是将真正的着色语言<strong>嵌套</strong>在Shaderlab语言中，其虽然是Untiy封装过后的，但语法几乎与标准的CG&#x2F;HLSL一样。但有些函数Unity没有提供支持。</li></ul><hr><h2 id="2-1-2-顶点，片元着色器"><a href="#2-1-2-顶点，片元着色器" class="headerlink" title="2.1.2 顶点，片元着色器"></a>2.1.2 顶点，片元着色器</h2><ul><li>对于顶点片元着色器而言，我们同样可以用CG&#x2F;HLSL来编写，其灵活性比表面着色器<strong>更高</strong>，我们可以控制更多的渲染细节，定义每一个<strong>Pass</strong>，虽然这意味着我们需要编写更多的代码。</li><li>以下是一个简单的顶点片元着色器实例</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250218112246.png" alt="image.png"><br>  <code>2.1.2 一个最简单的顶点片元着色器实例</code></li><li>本节最后我们也将完成这个Shader，并理解其每一行代码的逻辑与用途。</li><li>此外，还有一种Shader类型是固定函数Shader，这是在老式的可配置渲染管线中遗留的Shader类型，目前已经不再使用了。</li></ul><hr><h2 id="2-1-3-补充知识"><a href="#2-1-3-补充知识" class="headerlink" title="2.1.3 补充知识"></a>2.1.3 补充知识</h2><ul><li>那么我们该如何选择Shader类型呢？<ul><li>如果是与<strong>多种光源</strong>有关的Shader类型，我们可以直接选择表面着色器，它将为我们省去很多麻烦</li><li>如果是希望控制单Pass细节，自定义效果多，光线效果少，那么请直接选择顶点，片元着色器！</li></ul></li><li>UnityShader并不是真正的Shader文件<ul><li>传统的Shader我们只能分开编写各类着色器，并且无法直接设置一些渲染设置如混合，深度测试等，我们也需要很小心的处理Shader的输入与输出。</li><li>Unity为我们提供了不需要关注底层实现细节而主要关注开发过程的方式，让我们更加方便的处理呈现内容。</li><li>但其也有弊端，它的封装性很高，所以类型语法都被限制了，对于一些特殊的着色器如<strong>几何着色器（GeometryShader）</strong>，<strong>曲面细分着色器</strong>则支持的并不是很好。</li></ul></li><li>UnityShader与HLSL&#x2F;CG<ul><li>UntiyShader实际上与HLSL和CG的关系是独立的，真正的Shader片段均为HLSL&#x2F;CG语法。</li><li>Untiy会为我们智能针对平台编译所需要的中层代码，并提交给GPU，因此我们不需要针对每个平台再去编写对应API的代码，大大减轻了负担。</li></ul></li></ul><hr><h1 id="2-2-CG语法基础"><a href="#2-2-CG语法基础" class="headerlink" title="2.2 CG语法基础"></a>2.2 CG语法基础</h1><ul><li>接下来，我们将正式开始编写着色器，我们将使用Vs作为IDE编辑我们的Shader文件。在编写前，我们需要先来了解一下CG语法的基础。</li></ul><h2 id="2-2-1-基本结构"><a href="#2-2-1-基本结构" class="headerlink" title="2.2.1 基本结构"></a>2.2.1 基本结构</h2><ul><li>前文提到，在每一个Pass中（除表面着色器外），就是我们的CG语言所在的位置，我们需要在Pass代码框中编写CG语言。</li><li>Shaderlab只是起到组织代码结构的作用，真正发挥作用的是Pass框架内的CG语言而我们在编写CG语言时，还需要在头部和尾部添加CGPROGRAM以及ENDCG作为标识，告诉Untiy这一段是我们的CG代码。</li><li>另外我们需要使用对应的编译指令，来编译对应的顶点，片元着色器，以及Shader要编译的目标级别。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma vertex vert  //定义顶点着色器</span><br><span class="line">#pragma fragment frag //定义片元着色器</span><br><span class="line">#pragma target name //定义要编译的目标级别</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译指令用于告诉Untiy哪一个是顶点着色器片段，而哪一个是片元着色器片段。而<strong>编译目标等级</strong>则是因为Unity会将CG代码编译到不同的<strong>ShaderModle</strong>中，往往高级的功能需要在更高的GPU上运行，因此需要小心这个数值，通常默认值为2.5</li><li>另外还可以使用<code>#pragma require feature</code>来指定需要何种功能，比如</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma require Geometry tessellation //需要几何体细分功能</span><br></pre></td></tr></table></figure><ul><li>针对不同平台，还可以使用编译指令，只编译或不编译成特定平台的代码。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma only_renderers d3d11 //只编译 DX3D 11/12平台的底层代码</span><br><span class="line">#pragma exclude_renderers glcore //不编译 OPenGL 3.x / 4.x</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-2-顶点着色器"><a href="#2-2-2-顶点着色器" class="headerlink" title="2.2.2 顶点着色器"></a>2.2.2 顶点着色器</h2><ul><li>这是我们编写Shader所需要的最关键的部分，我们需要利用函数的模式来编写顶点与片元着色器，我们先从渲染管线的思路来认识，从最开始的顶点着色器来逐步认识这段最关键的处理部分。</li><li>这样的着色器有两种编写方式，一种是有<strong>返回值</strong>的模式，另一种是无返回值模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//有返回值</span><br><span class="line">float4 vert(float4 v : POSITION) :SV_POSITION</span><br><span class="line">&#123;</span><br><span class="line">return mul(UNITY_MATRIX_MVP ,v); // 返回一个经过MVP矩阵变换后的顶点值</span><br><span class="line">&#125;</span><br><span class="line">//无返回值</span><br><span class="line">void vert(in float4 v : POSITION,out float4 position : SV_POSITION)</span><br><span class="line">&#123;</span><br><span class="line">position = UnityObjectToClipPos(v); // 使用Unity模型到裁剪空间函数进行变换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顶点着色器计算的对象是顶点，精度较低。</li><li>我们可以观察到，无论是有返回值还是没有，他们的大体结构都类似，首先需要输入和输出，输入v包含了这个顶点的位置，由POSITION语义指定，返回一个float4类型的变量，这就是裁剪空间中的位置。</li></ul><hr><ul><li>UntiyShader的数值类型，主要有fixed1-4，half1-4，float1-4（精度依次提高）以及struct类型。</li><li>对于优化而言。我们需要使用尽可能低的精度来提升Shader性能，我们可以用fixed类型存储<strong>颜色和单位矢量</strong>，更大范围则是half，最差再使用float。</li></ul><hr><ul><li>这些数据从哪里来呢？如果我们需要更多的数据该如何表示呢？学过编程的同学可能会想到<strong>结构体</strong>，没错，我们将用结构体来表示这些从<strong>应用阶段</strong>传来的数据，并将其传入到顶点着色器中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">struct a2v&#123; //代表从应用阶段传递到顶点阶段</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line">float4 vert(a2v v):SV_POSITION&#123;</span><br><span class="line">return mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>我们需要通过<strong>语义</strong>来告诉系统我们输入输出的是何值。</li><li>什么是语义呢？<strong>语义</strong>就是一个赋给Shader输入输出的字符串，定义了数据的类型，至于数据本身Untiy并不关心，它只要将数据合理的进行传输即可。</li><li>Unity支持的常用语义如下：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250219093810.png" alt="image.png"><br>  <code>2.2.2 Untiy支持的a2v语义</code></li><li>其中TEXCOORD n 的数量是与之前所提到的ShaderModle有关，一般在ShaderModle2，3中，n为8，一般所需不超过2，因此绝大多数情况下是够用的。 ^8a5c23</li><li>通常TEXCOORD也就是uv纹理坐标只有两个维度的值，因此若声明为float4变量，后两位会被自动填充，其中w维度变量默认为1，而z维度变量默认为0，代表一个点坐标。</li></ul><hr><h2 id="2-2-3-片元着色器"><a href="#2-2-3-片元着色器" class="headerlink" title="2.2.3 片元着色器"></a>2.2.3 片元着色器</h2><ul><li>片元着色器结构与顶点着色器略有不同，因为往往片元着色器面向的都是最后输出颜色的部分，因此输出的语义标识与数值类型都有限制。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//无返回值版本</span><br><span class="line">void frag(in v2f i, out fixed4 color :SV_Target)&#123;</span><br><span class="line">color = (i.color,1.0);</span><br><span class="line">&#125;</span><br><span class="line">//有返回值版本</span><br><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">return fixed4 (i.color , 1.0)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于顶点着色器与片元着色器的通信，我们就需要使用一个新的结构体用于定义顶点着色器的输出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">fixed3 color: COLOR0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>顶点着色器的输出必须包含<strong>一个语义为SV_POSITION</strong>的变量，这样片元着色器才能得知插值后的顶点位置，Color变量往往存储颜色，但也可以自行定义。</li><li>片元着色器的输入实际上就是顶点着色器输出的<strong>插值</strong>，而对于TEXCOORD语义，其不再特指为uv坐标，实际上可以传递任何值，因此需要依据条件而定。</li><li>片元着色器的输出值是往往需要指定一个渲染目标（RenderTarget）,它是由HLSL中的一个系统语义SV_Target指定的，它的作用是将这张图像渲染到帧缓冲中。</li><li>片元着色器的输出值是一个颜色值，一般为fixed4类型。</li></ul><hr><ul><li>现在，我们可以结合所学大致写出目前我们已知的Shader代码了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Shader “YOURShader”&#123;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Pass&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line">#pragma vertex vert；</span><br><span class="line">#pragma fragment frag；</span><br><span class="line">struct a2v&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal :NORMAL;</span><br><span class="line">float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125; ;</span><br><span class="line">v2f vert(a2v v):SV_POSITION&#123;</span><br><span class="line">v2f o;//实例化一个v2f对象，并修改其中的值传递给片元着色器</span><br><span class="line">o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line">o.color = v.normal * 0.5 + fixed3(0.5,0.5,0,5)；</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos: SV_POSITION;</span><br><span class="line">fixed3 color:COLOR0;</span><br><span class="line">&#125;;</span><br><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">return fixed4(i.color,1.0);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">//FALLBACK Off</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-2-4-CG属性"><a href="#2-2-4-CG属性" class="headerlink" title="2.2.4 CG属性"></a>2.2.4 CG属性</h2><ul><li>在完成了以上的内容之后，我们现在再来看之前一直没有特别关注的<strong>属性</strong>Properties部分，现在如果我们想改变Shader内部的属性值，我们只能修改Shader代码。</li><li>于是我们有了<strong>属性</strong>代码块，它可以让我们能够从软件界面中可视化修改对应的属性变量，只需要我们在代码内部声明该变量即可，其语法为</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type name;</span><br></pre></td></tr></table></figure><ul><li>比如，如果我们要声明一个外部的Float变量，我们需要在代码块中首先添加之前提到过的变量声明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_MyFloat(&quot;Float Properties&quot;,Float) = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随后，在CG代码内部，<strong>再次声明该变量</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line">……</span><br><span class="line">float _MyFloat;</span><br><span class="line">……</span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><ul><li>这样，我们在外部视图面板中的参数条件就能直接传递到代码内部了。</li></ul><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250221093919.png" alt="image.png"><br><code>2.2.4 常用的CG属性</code></p><ul><li>以上是一些比较常用的属性值与其对应的变量类型，包括后续使用纹理时所添加的2D以及Cub等属性，在后续的章节也会进一步介绍。</li></ul><hr><h1 id="2-3-Unity包含文件"><a href="#2-3-Unity包含文件" class="headerlink" title="2.3 Unity包含文件"></a>2.3 Unity包含文件</h1><h2 id="2-3-1-什么是包含文件"><a href="#2-3-1-什么是包含文件" class="headerlink" title="2.3.1 什么是包含文件"></a>2.3.1 什么是包含文件</h2><ul><li>包含文件可以理解为是Untiy为了方便我们进行开发，预先将<strong>一系列函数，变量封装起来</strong>，供我们调用的文件。类似于c++的<strong>头文件</strong>。</li><li>大家可以去Untiy官网选择下载内置着色器来下载这些文件</li><li>我们需要在CG代码框内使用类似于添加c++头文件的方式，添加这些包含文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line">……</span><br><span class="line">#include “UnityCG.cginc”</span><br><span class="line">……</span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><ul><li>UnityCG.cginc是最常用的包含文件，其中包括了很多内置的辅助函数以及结构体，便于我们简化我们的Shader。</li><li>以下是一系列常用的包含文件夹以及其描述。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250221113506.png" alt="image.png"><br>  <code>2.3.1 常用的包含文件</code></li></ul><hr><h2 id="2-3-2-UnityCG-cginc"><a href="#2-3-2-UnityCG-cginc" class="headerlink" title="2.3.2 UnityCG.cginc"></a>2.3.2 UnityCG.cginc</h2><ul><li>该包含文件中包含了很多结构体，我们可以直接使用其作为之前所提到的顶点着色器，以及片元着色器之间的传递数据的结构体。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250221113822.png" alt="image.png"><br>  <code>2.3.2 UnityCG.cginc所包含的常用结构体</code></li><li>另外其也提供了一系列常用的<strong>函数</strong>，比如将顶点进行变换的函数，获取光照和视角变换的函数等，这些我们也完全可以自己实现，但随着代码推进，越来越复杂时，我们就需要通过这些函数来优化我们的代码。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/8b9118bfc35ca2f51b6eed51c3d5a75.jpg" alt="8b9118bfc35ca2f51b6eed51c3d5a75.jpg"><br>  <code>UntiyCG.cginc中包含的顶点转换函数</code></li></ul><hr><h2 id="2-3-3-关于宏"><a href="#2-3-3-关于宏" class="headerlink" title="2.3.3 关于宏"></a>2.3.3 关于宏</h2><ul><li>上图中我们可以发现说明里有等同于mul（UNITY_MATRIX_MVP）的字样，实际上括号内的函数是包含在另一个包含文件中的宏定义，其对应了Unity为我们实现的MVP变化矩阵。</li><li>宏定义在编译是会<strong>自动替换为字符串</strong>，因此我们只需要输入名称即可使用。但这样的效率依旧不高，而且函数对于我们来说认知更为直观，因此我们可以现在搞清楚Shader原理的过程中，随着学习的深入，一步一步用函数替换掉宏定义，使得代码更整洁。</li></ul><hr><h1 id="2-4-让我们来写一个真正的Shader"><a href="#2-4-让我们来写一个真正的Shader" class="headerlink" title="2.4 让我们来写一个真正的Shader"></a>2.4 让我们来写一个真正的Shader</h1><ul><li>说了那么多，百闻不如一见，只有真正实践，我们才会发现问题，以更好的掌握。</li><li>现在，我们将用我们学过的知识，来编写一个简单的Shader，我们可以通过界面上的<strong>一个参数来调整图片与材质颜色的混合程度</strong>。</li><li>首先，我们需要具备三个参数，一个是图像纹理，另一个是一个颜色值，一个是一个Float值用于控制混合程度。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">   _MainTex(&quot;MainTex&quot;,2D) = &quot;white&quot;&#123;&#125; //贴图默认值为“white”&#123;&#125;</span><br><span class="line">   _MainColor(&quot;MainColor&quot;,Color) = (1,1,1,1) //颜色默认值为 （1,1,1,1）为白色</span><br><span class="line">   _LerpV(&quot;LerpValue&quot;,Range(0,1)) = 1 //这里是一种可视化进度条的写法，一个范围值可以拖拽限定最大最小值以及默认值</span><br><span class="line">   //当然你还可以使用_LerpV(&quot;LerpValue&quot;,Float) = 1 的写法。效果是一样的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来我们开始正式编写CG代码片段，我们需要先进行一系列的编译设置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> SubShader</span><br><span class="line"> &#123;</span><br><span class="line">     Pass&#123;</span><br><span class="line">     CGPROGRAM</span><br><span class="line">     </span><br><span class="line">     #pragma vertex vert</span><br><span class="line">     #pragma fragment frag</span><br><span class="line"></span><br><span class="line">     #include &quot;UnityCG.cginc&quot; //包含包含文件（到此处为止都不需要添加分号）</span><br><span class="line">     </span><br><span class="line">     fixed4 _MainColor;</span><br><span class="line">     float _LerpV;</span><br><span class="line">     sampler2D _MainTex;//注意此处需要与之前的属性声明值一致，此处开始需要添加分号，分段执行</span><br><span class="line">     float4 _MainTex_ST;//此处是后续会讲到的，每个贴图所对应的缩放与平移值，用于对纹理进行采样。</span><br><span class="line">……</span><br></pre></td></tr></table></figure><hr><ul><li>接下来，我们分别用基础版本和高级版本来实现。实际上的不同点，就是高级部分非常简略，适合后期进阶使用。普通版本更适合新手入门搞懂Shader代码细节使用。大家各取所需即可</li><li>基础思路，我们在顶点着色器中转换顶点坐标并计算纹理坐标，在片元着色器中利用lerp函数对两个值进行插值，最后输出即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//这里提供两种解决思路，一个是用基础宏定义的基础思路，另一个是用函数解决的进阶思路，在后期可以使用进阶思路</span><br><span class="line"></span><br><span class="line">//基础思路</span><br><span class="line"></span><br><span class="line">//首先声明两个结构体用于传递信息</span><br><span class="line">/*</span><br><span class="line">struct a2v&#123;</span><br><span class="line">    float4 vertex:POSITION; //最基本的顶点位置信息</span><br><span class="line">    float2 texcoord:TEXCOORD0;//最基本的纹理坐标信息</span><br><span class="line">&#125;;</span><br><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos:SV_POSITION;//裁剪空间下的顶点位置信息</span><br><span class="line">    float2 uv:TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = mul(UNITY_MATRIX_MVP,v.vertex)//将顶点变换到裁剪空间下现在编译时会自动替换，这里只是强调概念</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);//利用包含文件中的宏计算纹理坐标</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 frag(v2f i):SV_Target&#123;</span><br><span class="line">    fixed4 color = tex2D(_MainTex,i.uv);//使用tex2D函数用uv坐标采样主纹理</span><br><span class="line">    return lerp(color,_MainColor,_LerpV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>另外一种就是进阶思路，进阶思路其实就是使用<strong>函数以及包含文件内的结构体</strong>代替我们自己编写的结构体以及宏定义，更简单的完成目的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//进阶思路，使用UnityCG.cginc中为我们提供的结构体以及函数</span><br><span class="line">v2f_img vert(appdata_base v)&#123;</span><br><span class="line">    v2f_img o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);//利用函数将顶点变换到裁剪空间下</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);//利用包含文件中的宏计算纹理坐标</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 frag(v2f_img i):SV_Target&#123;</span><br><span class="line">    fixed4 color = tex2D(_MainTex,i.uv);//使用tex2D函数用uv坐标采样主纹理</span><br><span class="line">    return lerp(color,_MainColor,_LerpV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250223144642.png" alt="image.png"><br>  <code>2.4 效果展示</code></li></ul><hr><h1 id="2-5-结语与参考资料"><a href="#2-5-结语与参考资料" class="headerlink" title="2.5 结语与参考资料"></a>2.5 结语与参考资料</h1><ul><li>本节我们完成了真正可以使用的第一个Shader文件，我们了解了Shader的基本概念与基本语法，了解了两个最基本的着色器的作用与写法。</li><li>接下来，我们将进入光照部分，实现一系列光照算法模型，了解Unity中的光照系统。</li><li>所有代码我都将上传到<strong>Github社区进行维护</strong>，欢迎大家一起交流。</li></ul><hr><ul><li>UnityShader入门精要 冯乐乐著</li><li>UntiyShaderlab 新手宝典 唐福幸著</li></ul>]]></content>
      
      
      <categories>
          
          <category> UntiyShader基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnityShader基础篇1——初识Shader与Shader语言（上）</title>
      <link href="/2025/03/14/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%871%20%E5%88%9D%E8%AF%86Shader%E4%B8%8EShader%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/03/14/UnityShader%E5%9F%BA%E7%A1%80%E7%AF%871%20%E5%88%9D%E8%AF%86Shader%E4%B8%8EShader%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-0-概要"><a href="#1-0-概要" class="headerlink" title="1.0 概要"></a>1.0 概要</h1><ul><li>这是一个全新的篇章，经过一学期的图形学基础学习，相信我们已经对画面如何呈现在屏幕上的过程有了一个大概的认识，接下来，我们将对UnityShader进行系统性的学习，我们将实践之前提到的一系列理论知识，并了解其在实际引擎中使用。</li><li>根据上一学期的课程经验，我们将尽可能使用理论化的语言和规范的流程进行讲解，便于大家的学习理解。每节课都将会从理论→实践→思考的形式呈现。</li></ul><hr><h1 id="1-1-初识UntiyShdaer"><a href="#1-1-初识UntiyShdaer" class="headerlink" title="1.1 初识UntiyShdaer"></a>1.1 初识UntiyShdaer</h1><ul><li>在之前的渲染管线学习中，我们了解到，对于目前引擎中的可编程渲染管线（SRP），我们可以编辑的部分主要是顶点着色器（VertexShader），片元着色器（FragmentShader）。</li><li>详情： [[入门图形学6——渲染管线综述]] </li><li><a href="https://pleasant233.github.io/2024/12/21/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A66%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0/">入门图形学6——渲染管线综述</a></li><li>为了便于学习，我们在这里再回顾一下什么是渲染管线而由此推出什么是Shader的定义。</li></ul><hr><h1 id="1-2-渲染流水线"><a href="#1-2-渲染流水线" class="headerlink" title="1.2 渲染流水线"></a>1.2 渲染流水线</h1><ul><li>渲染流水线就是电脑内存中的几何数据经过一系列处理，呈现在屏幕上被我们观察到的过程，大概可以分为三个阶段，分别是：应用阶段，几何阶段，光栅化阶段。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250216101745.png" alt="image.png"><br>  <code>2.1. 渲染流水线</code></li></ul><hr><h2 id="1-2-1-应用阶段"><a href="#1-2-1-应用阶段" class="headerlink" title="1.2.1 应用阶段"></a>1.2.1 应用阶段</h2><ul><li>应用阶段主要是CPU负责的，我们在软件中处理数据时主要发生在这部分，详细的内容我们已经在之前的教程提到过了，欢迎回顾[[入门图形学6——渲染管线综述]]</li><li>我们将需要处理的数据模型准备好，以及将一系列的渲染所需数据，如贴图，灯光，uv等传入显存，便于进入下一个阶段处理，这里的数据便成为渲染图元（rendering primitives）</li><li>渲染状态同样是重要的参数之一，渲染状态就是如何渲染该物体，包括最基本的Color，纹理tex，着色器Shader等。</li></ul><hr><h2 id="1-2-2-几何阶段"><a href="#1-2-2-几何阶段" class="headerlink" title="1.2.2 几何阶段"></a>1.2.2 几何阶段</h2><ul><li>从此处开始，我们便进入了GPU接管的阶段，也是我们编程面向的阶段。在这里我们将应用阶段传入的<strong>几何图元</strong>进行相对应的操作，它可以是逐顶点，逐多边形等等，我们会在后面介绍，这部分所对应的就是我们的VertexShader（顶点着色器）。</li><li>我们在入门图形学中详细介绍了<em>坐标变换</em>的相关知识，这是为了让我们更好的理解顶点着色器所做的事，那就是将顶点坐标变换至屏幕空间，最后输出到屏幕上。</li><li>最后传出到光栅化阶段的是二维坐标，深度值，着色信息等。</li></ul><hr><h2 id="1-2-3-光栅化阶段"><a href="#1-2-3-光栅化阶段" class="headerlink" title="1.2.3 光栅化阶段"></a>1.2.3 光栅化阶段</h2><ul><li>光栅化阶段所进行的操作就是针对每个像素进行插值运算，最后生成屏幕上的图像，这一部分对应的着色器便是FragmentShader（片元着色器）。</li><li>因此我们所做的操作是逐像素的，相对开销比较大，但效果会更好。</li><li>这一阶段往往合并了各类测试，比如<strong>深度测试，模版测试，透明度测试</strong>等，我们会在后续认识这些部分。</li><li>最后是对于呈现本身，我们会将每一次渲染的图像存储在Color-buffer里，这也是所谓的帧缓冲，我们将对其进行混合操作，如覆写，或更复杂的计算。</li><li>在这里我们会应用一种叫做双重缓冲（Double-Buffer），渲染永远发生在后一个Buffer中，等渲染完则会调换两个缓冲的前后顺序保证呈现最连续的画面。</li></ul><hr><h1 id="1-3-图形API与Shader"><a href="#1-3-图形API与Shader" class="headerlink" title="1.3 图形API与Shader"></a>1.3 图形API与Shader</h1><h2 id="1-3-1-图形API"><a href="#1-3-1-图形API" class="headerlink" title="1.3.1 图形API"></a>1.3.1 图形API</h2><ul><li>对于我们而言实际上了解这些知识就是为了编写着色器，所以对于UnityShader而言，我们只需要在Shader文件中设置一些输入和着色器片段内容，就可以呈现大部分效果。</li><li>但实际上Shader本身就是一个文本文件，最后的一切操作，都交给Unity以及图形API来完成。</li><li>我们在之前已经简要了解了诸如OPenGL，DX等API，它们的作用就是更加方便的与GPU沟通，通过调用API，我们可以控制图形驱动调用GPU硬件，从而完成实际的计算。</li><li>CPU到GPU的过程则是从CPU内存中传入GPU显存中的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250216105921.png" alt="image.png"><br>  <code>1.3 API在渲染管线所处的位置</code></li></ul><hr><h2 id="1-3-2-Shader语言"><a href="#1-3-2-Shader语言" class="headerlink" title="1.3.2 Shader语言"></a>1.3.2 Shader语言</h2><ul><li>对于可编程的着色器阶段，我们需要用一系列语言来编写程序，就比如我们在对CPU编程使用的C语言等。</li><li>而对于GPU，不同的API对应了不同的着色语言，最常用的为OPenGL对应的GLSL，DX对应的HLSL，以及NV的CG</li><li>上述语言中，HLSL对于游戏编程更为常用，最值得学习，而Unity使用的则是NV的CG语言，已经很久未更新，但由于其语言风格更类似于C语言，并且针对不同平台可以生成对应的底层代码，因此跨平台性更佳，再加其与HLSL语法几乎一样，因此我们将主要学习CG语言，而在后续进阶内容中我们将利用HLSL实现更加复杂的效果。</li></ul><hr><h2 id="1-3-3-什么是Shader"><a href="#1-3-3-什么是Shader" class="headerlink" title="1.3.3 什么是Shader"></a>1.3.3 什么是Shader</h2><ul><li>现在，我们就可以来总结何为Shader了，Shader就是GPU流水线上一段高度可编程的部分，由GPU执行，本质上就是告诉GPU该如何处理数据。</li><li>主要分为顶点与片元着色器，当然还有特殊的诸如路径追踪着色器，计算着色器等。</li><li>如果将Shader比作加工方式，那贴图数据就是素材，成品就是材质。</li><li>我们主要学习的Shader语言为CG之上封装的Unity的Shaderlab语言，实际上就是有很多宏定义以及函数可供我们调用，便于实现效果。接下来我们就将正式进入着色器实际编写环节，本次以及下次课，我们将完成一个简单的着色器，随后我们就可以正式进入Shader的世界，编写多种多样的效果。</li></ul><hr><h1 id="1-4-ShaderLab语法与概念"><a href="#1-4-ShaderLab语法与概念" class="headerlink" title="1.4 ShaderLab语法与概念"></a>1.4 ShaderLab语法与概念</h1><ul><li>在这一部分，我们将介绍Unity中的着色器相关内容与Shaderlab语法基础，各位可以跟随实践，代码都将附加在文内，方便各位尝试。</li></ul><h2 id="1-4-1-创建Shader文件"><a href="#1-4-1-创建Shader文件" class="headerlink" title="1.4.1 创建Shader文件"></a>1.4.1 创建Shader文件</h2><ul><li>Unity版本：2022.3</li><li>在Unity中，每一个材质都会至少对应一个着色器文件，如果我们创建一个材质，那么它会自动添加一个默认的Shader，它具备基本的光照，颜色等信息。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250216113441.png" alt="image.png"><br>  <code>1.4.1 Material的属性面板</code></li></ul><hr><ul><li>我们可以发现这个材质有一系列的参数可以供我们调节，其中由上自下大致可以分为三个区域，Shader选择框，数据参数面板，以及预览面板。</li><li>我们先来关注Shader选择框，在这里，右侧编辑栏内，我们可以选择特定的Shader，进行处理，点击Editer我们就可以打开Shader面板，最终呈现在我们面前的便是一个Shader文件了。</li><li>当然我们也可以单独创建Shader文件，在主界面下方文件面板中右键创建一个Standard Surface Shader（标准表面着色器并且右键打开它，这时会吊起Vs编辑器，最后呈现在我们眼前的便是实际的Shader文件了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217105653.png" alt="image.png"><br>  <code>1.4.1.1 Shader文件面板</code></li></ul><hr><ul><li>其中我们会注意到一系列参数，后面我们会详细讲解最关键的我们可以注意到最下面一组<em>Properties</em> 参数，这就是我们可以从引擎传入的部分。 </li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250216115552.png" alt="image.png"><br><code>1.4.1.2 Shader文件</code></li><li>表面着色器实际上就是由<em>顶点着色器与片元着色器组合而成的</em>，因此我们仍然可以通过顶点和片元着色器去解构理解。</li><li>如果我们在图1.4.1.1中点击show Code generate我们就可以看到Untiy引擎为我们编译的顶点与片元着色器代码 </li><li>对于compile and show code，在后期，我们可以查看对应不同平台编译出的汇编代码，并对其进行调节和优化</li></ul><hr><h2 id="1-4-2-ShaderLab"><a href="#1-4-2-ShaderLab" class="headerlink" title="1.4.2 ShaderLab"></a>1.4.2 ShaderLab</h2><ul><li><p>ShaderLab实际上是Unity对着色语言的一层上层抽象，它为我们保留了着色语言的基本语法，并封装了许多计算，效果宏函数供我们调用。</p></li><li><p>Shaderlab是一种说明性语言，不论我们写何种语言，Shaderlab都会对其进行包装。它使用了一些嵌套在花括号内的语义来描述一个UntiyShader文件的结构，包括了所需数据，着色器属性，渲染状态设置等。所以其<strong>不仅包含着色器代码</strong>并且还包含了显示一个材质所需的所有东西。<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217095033.png" alt="image.png"></p><p>  <code>1.4.2 UnityShader与Shaderlab的作用</code></p></li></ul><hr><ul><li>通过观察图1.4.1.2我们可以发现，任意一个Shaderlab代码都包含以下内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Shader&quot;Name&quot;//Shader名称与路径</span><br><span class="line">&#123;</span><br><span class="line">Properties&#123;//Shader对应的属性值</span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;//顶点，片元着色器等</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack &quot;Name&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我们可以总结出大概分为四个部分，分别是名称，Properties，SubShader，FallBack。接下来我们一一介绍。</li></ul><hr><h2 id="1-4-3-Shaderlab结构"><a href="#1-4-3-Shaderlab结构" class="headerlink" title="1.4.3 Shaderlab结构"></a>1.4.3 Shaderlab结构</h2><ul><li>Shader所对应的名称就是其路径，比如图1.4.1.2中，该Shader为</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/TestShader&quot;</span><br></pre></td></tr></table></figure><ul><li>那么它就是Custom下的TestShader，每一个Shader都有一个独属于自己的路径。</li></ul><hr><ul><li>Properties是Shaderlab所必备的属性框对应了引擎界面中的属性面板，至少有一个，属性的格式要包含名称，显示名称，类型，和默认值，如果没有指定默认值，Untiy会自动默认一个值，对于数据来说通常为0，其余如字符串则有特定默认值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Name(&quot;displayName&quot;,PropertyType) = DefaultValue;</span><br></pre></td></tr></table></figure><ul><li>以下是常用的数据类型<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217103917.png" alt="image.png"><br><code>1.4.3 Properties常用属性值</code></li><li>如果在着色器中编写就是这样的，随后在面板中我们就可以设置数值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color&quot;, Color) = (1,1,1,1)</span><br><span class="line">    _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5</span><br><span class="line">    _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217104613.png" alt="image.png"><br><code>1.4.3.1 Shader对应着色器面板中的数值效果</code></li></ul><hr><ul><li>Shader代码通常包括至少一个<strong>SubShader</strong>，GPU会顺序检测SubShader是否能执行，假如均无法执行则可以回退到一个能够执行的基本着色器。</li><li>每个SubShader中有若干个Pass，每个Pass都是一次完整的渲染流程，而Pass之间会按照指定的顺序进行混合。最终输出。而每个Pass中就会包含诸如顶点，片元着色器等模块。</li><li>SubShader的大概结构是这样的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">[Tags]//标签</span><br><span class="line">[RenderSetup]//渲染状态</span><br><span class="line">Pass&#123;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>其中Pass是必须的，而RenderSetup是可选的，我们可以设置显卡的各种状态，如剔除，测试选项等，对应渲染管线的不同阶段，这也被成为可配置的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217110356.png" alt="image.png"><br><code>1.4.3.2 渲染设置</code></li><li>如果在SubShader开头设置则默认作用于所有Pass，而若想单独设置，则可以在特定Pass上单独定义。</li></ul><hr><ul><li>而对于标签而言，标签Tags实际上是一个键值对，它的键值均为字符串类型，这些是其与Unity沟通的方式，它们主要定义如何，以及何时渲染这个对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;“TagName1” = “Value1”&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217111202.png" alt="image.png"><br>  <code>1.4.3.2 渲染标签类型</code></li><li>最常用的设置有：渲染队列Queue，渲染类型RenderType等。</li><li>渲染队列主要可分为：Background，Geometry，AlphaTest，Transparent等，它们对应了不同的渲染顺序，我们也可以自行设置物体在渲染队列中的位置比如</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;“Queue” = &quot;Geometry+1&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250217115544.png" alt="image.png"><br><code>1.4.3.3 渲染队列前后顺序</code></li></ul><hr><ul><li>而对于渲染类型RenderType而言，我们可以指定该物体渲染作什么物体用于后期的渲染替换以及使用相机深度纹理。</li><li>常用的渲染类型有：Opaque用于普通Shader，比如不透明，自发光等，Transparent用于半透明Shader。以下是渲染类型的大致表格。<br>  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/89160f4a8d94f8ecc6f8398c8621604.jpg" alt="89160f4a8d94f8ecc6f8398c8621604.jpg"><br>  <code>1.4.3.4 渲染类型概览</code></li></ul><hr><ul><li>此外我们还可以针对是否开启批处理DIsableBatching，是否接受阴影投射IgnoreProjector进行控制，这些都属于Tags的范围，可见Tag标签非常强大。</li></ul><hr><h2 id="1-4-4-Pass部分"><a href="#1-4-4-Pass部分" class="headerlink" title="1.4.4 Pass部分"></a>1.4.4 Pass部分</h2><ul><li>Pass部分就是我们实际编写Shader最主要代码的部分，UnityShader为我们提供了一个很好的框架，在非引擎情境下，我们要编写Shader代码，往往各个着色器需要分开编写，由于Shaderlab是标记性语言的特点，我们实际上只是在<strong>编辑文本</strong>，而Unity在编译时会将制定代码块内的内容，复制编译到对应的着色器部分，这大大减轻了我们的工作量，可以只在一个文档内完成。</li><li>先前提到，Pass是一个渲染流程单位，它代表一个渲染流程循环，结合之前我们所学的知识，渲染管线分为应用（A），几何（G），光栅化（R）三个阶段。</li><li>而自然而然，Pass也可简单看做由三部分组成：<ul><li>应用参数，数据</li><li>几何阶段（顶点着色器）</li><li>光栅化阶段（片元着色器）</li></ul></li><li>因此，我们也将这样来学习最重要的Shader代码核心区域。</li></ul><hr><ul><li>Pass区域的代码大致可以看做是如下的形式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">Name “” //该Pass的名称</span><br><span class="line">Tags //标签</span><br><span class="line">RenderSetup//渲染设置</span><br><span class="line">other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先是名称部分，我们可以给任意Pass命名如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name &quot;myFirstPass&quot;</span><br></pre></td></tr></table></figure><ul><li>这样我们在外部任意一个Shader文件中，只需要使用UsePass制定就可使用，但注意一点，UnityShader引用Pass<strong>只支持全部大写</strong>！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass “MyShader/MyPass”</span><br></pre></td></tr></table></figure><ul><li>此外，Pass同样可以设置标签和渲染设置，只不过与SubShader有所不同的是，标签的作用不同。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250218092802.png" alt="image.png"><br> <code>1.4.4 Pass的标签设置</code></li></ul><hr><ul><li>此外，还有一种特殊的Pass，叫做GrabPass，这个Pass可以抓取屏幕结果并将其储存到一张纹理中，用于后续处理。</li></ul><h2 id="1-4-5-FallBack"><a href="#1-4-5-FallBack" class="headerlink" title="1.4.5 FallBack"></a>1.4.5 FallBack</h2><ul><li>FallBack的主要用途是如果所有的SubShader都在此显卡无法运行，则回退到FallBack所指定的Shader文件中去。语法大概是这样的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">……</span><br><span class="line">FallBack “Name”</span><br><span class="line">or Fallback Off</span><br></pre></td></tr></table></figure><ul><li>当然Fallback不有这个用途，FallBack还可以影响阴影投射，正在渲染一张阴影图也就是ShadowMap时，Unity会在每个UnityShader中寻找一个投射阴影的Pass，而我们通常不需要自己实现，只需要利用FallBack指定一个内置Shader即可。后续会详细介绍。</li><li>Shaderlab还有其他语义，我们会在后续自定义材质面板的过程中讲解到。</li></ul><hr><h1 id="1-5-结语-与参考资料"><a href="#1-5-结语-与参考资料" class="headerlink" title="1.5 结语 与参考资料"></a>1.5 结语 与参考资料</h1><ul><li>恭喜你，我们已经完整认识了UnityShader的几乎所有基础内容，下一步，我们将深入细节，真正完成一个可以正常渲染的Shader。现在我们可以将整个Shader的架构写出来了！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader“MyShader”&#123; //Shader名称</span><br><span class="line">Properties&#123;</span><br><span class="line">Name（DisplayName，PropertyTYpe） = defaultValue;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Tags[]</span><br><span class="line">RenderSetup[]</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">Name</span><br><span class="line">Tags[] *</span><br><span class="line">RenderSetup[]</span><br><span class="line">ShaderPrograms&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">FallBack“”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在想必你应该能看懂先前我们创建的Shader文件了！</li></ul><hr><ul><li>UnityShader入门精要 冯乐乐著</li><li>UntiyShaderlab 新手宝典 唐福幸著</li></ul>]]></content>
      
      
      <categories>
          
          <category> UntiyShader基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EasyShader——重新定义变换矩阵</title>
      <link href="/2025/01/24/EasyShader4%E2%80%94%E2%80%94%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%8F%98%E7%9F%A9%E9%98%B5/"/>
      <url>/2025/01/24/EasyShader4%E2%80%94%E2%80%94%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%8F%98%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="4-0-前言"><a href="#4-0-前言" class="headerlink" title="4.0 前言"></a>4.0 前言</h1><ul><li>本篇是在重心坐标与深度检测成功绘制了前后关系正常的苹果图像，和后一节也就是本次图形学基础课实践部分的最终章节——漫反射材质导入的起承转合章节。本章我们将重构我们的变换代码，主要涉及一下几个部分<ul><li>geometry 类</li><li>main.cpp</li></ul></li><li>我们将实际将矩阵应用在我们的光栅化渲染器中，最后实现效果，为后续进阶的可变换视角的渲染器版本做铺垫。</li></ul><hr><h1 id="4-1-Geometry类"><a href="#4-1-Geometry类" class="headerlink" title="4.1 Geometry类"></a>4.1 Geometry类</h1><ul><li>首先是geometry类，我们对其进行了简单的重构，增加了Matrix类的定义，以及方法实现。相关的代码你可以在我们的库中找到，记住要找到矩阵分支~。</li><li>我们来看矩阵类的实现。</li><li>首先我们定义了一个数组，和两个int类型的值分别代表行和列。接着我们定义了基本的初始化方法以及一些基本的运算，如矩阵的乘法，矩阵的转置，逆阵等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">float</span>&gt; &gt; m;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r = DEFAULT_ALLOC, <span class="type">int</span> c = DEFAULT_ALLOC);</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nrows</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ncols</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Matrix <span class="title">identity</span><span class="params">(<span class="type">int</span> dimensions)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt;&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> i);</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp; a);</span><br><span class="line">    <span class="function">Matrix <span class="title">transpose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">inverse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li>我们在cpp中实现它们。</li><li>首先是最基本的两个内联函数，这两个函数只返回其本身的值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Matrix::nrows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Matrix::ncols</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着，是一个初始化单位阵的函数identity,返回一个单位阵</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">Matrix::identity</span><span class="params">(<span class="type">int</span> dimensions)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">E</span><span class="params">(dimensions, dimensions)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dimensions; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dimensions; j++) &#123;</span><br><span class="line">            E[i][j] = (i == j ? <span class="number">1.f</span> : <span class="number">0.f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>随后，是一个计算符【】，返回矩阵第i 列的值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt;&amp; Matrix::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows);</span><br><span class="line">    <span class="keyword">return</span> m[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接着是乘法，我们只需要取每一行每一列数乘即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Matrix Matrix::<span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp; a) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(cols == a.rows);</span><br><span class="line">    <span class="function">Matrix <span class="title">result</span><span class="params">(rows, a.cols)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a.cols; j++) &#123;</span><br><span class="line">            result.m[i][j] = <span class="number">0.f</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; k++) &#123;</span><br><span class="line">                result.m[i][j] += m[i][k] * a.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>然后是转置，我们只需要新实例化出一个矩阵，并反向填入目标矩阵的值即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">Matrix::transpose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">result</span><span class="params">(cols, rows)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            result[j][i] = m[i][j];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>最后是最为麻烦的逆阵，在这里，我们应用了教科书上的求逆阵方式，也就是所谓的高斯消元法，通过增加一个单位阵并将原矩阵化为最简阶梯形矩阵的方式，得到逆阵。</li><li>详细代码你可以在我的库里找到~。</li></ul><hr><h1 id="4-2-Main"><a href="#4-2-Main" class="headerlink" title="4.2 Main"></a>4.2 Main</h1><ul><li>现在，我们需要根据我们处理好的矩阵，来对我们的主函数文件进行重构。</li><li>但首先，我们需要先回顾一下之前是如何处理相关内容的。回顾先前的代码，我们法线，之前我们定义了一个直接将世界空间坐标映射到视口坐标的Worldtoscreen方法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">world2screen</span><span class="params">(Vec3f v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="built_in">int</span>((v.x + <span class="number">1.</span>) * width / <span class="number">2.</span> + <span class="number">.5</span>), <span class="built_in">int</span>((v.y + <span class="number">1.</span>) * height / <span class="number">2.</span> + <span class="number">.5</span>), v.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>并没有中间的裁剪和投影阶段。这很类似正交投影的方法，不过我们希望其能够移动，也就是能有透视</li><li>因此我们需要实现一系列新方法。</li><li>首先是两个基础的转换函数。其作用在于将矩阵形式和向量形式相互转换，在后续进行矩阵和向量混合运算时起到关键作用。</li><li>在这里，我们强调一点，实际上矩阵也就是一个二维数组，向量则是一个一维数组，计算机中存储二维数组的形式同样是线性排布的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241226122411.png" alt="image.png"><br>  <code>4.2.1</code></li></ul><hr><ul><li>以下是两个方法的代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">m2v</span><span class="params">(Matrix m)</span> </span>&#123;<span class="comment">//转换函数，将矩阵形式转换为向量形式。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(m[<span class="number">0</span>][<span class="number">0</span>] / m[<span class="number">3</span>][<span class="number">0</span>], m[<span class="number">1</span>][<span class="number">0</span>] / m[<span class="number">3</span>][<span class="number">0</span>], m[<span class="number">2</span>][<span class="number">0</span>] / m[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">v2m</span><span class="params">(Vec3f v)</span> </span>&#123;<span class="comment">//转换函数，将向量转换为矩阵形式。</span></span><br><span class="line">    <span class="function">Matrix <span class="title">m</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = v.x;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">0</span>] = v.y;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">0</span>] = v.z;</span><br><span class="line">    m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1.f</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义完这两个基础方法后，下一步，我们就需要定义两个重要的转换操作，一个是视图变换矩阵一个是透视投影矩阵。</li></ul><hr><h1 id="4-3-视图变换与透视投影变换"><a href="#4-3-视图变换与透视投影变换" class="headerlink" title="4.3 视图变换与透视投影变换"></a>4.3 视图变换与透视投影变换</h1><ul><li>首先是外部的视图变换，教程中将这一步与下一步合并，形成了新的视图变换矩阵。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">viewport</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;<span class="comment">//视口+正交变换</span></span><br><span class="line">    Matrix m = Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);</span><br><span class="line">    m[<span class="number">0</span>][<span class="number">3</span>] = x + w / <span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">3</span>] = y + h / <span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">3</span>] = depth / <span class="number">2.f</span>;</span><br><span class="line"></span><br><span class="line">    m[<span class="number">0</span>][<span class="number">0</span>] = w / <span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">1</span>][<span class="number">1</span>] = h / <span class="number">2.f</span>;</span><br><span class="line">    m[<span class="number">2</span>][<span class="number">2</span>] = depth / <span class="number">2.f</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-4-main函数中的变化"><a href="#4-4-main函数中的变化" class="headerlink" title="4.4 main函数中的变化"></a>4.4 main函数中的变化</h1><ul><li>在main函数中，我们首先初始化了一个透视矩阵，随后调用了先前写好的视图变化矩阵方法，得到了一个视图变化矩阵，随后，我们余弦设定了相机的位置朝向，并以此初始化了透视矩阵中第四行第三列的值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">camera</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">Matrix Projection = Matrix::<span class="built_in">identity</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//初始化一个透视矩阵</span></span><br><span class="line">Matrix ViewPort = <span class="built_in">viewport</span>(width / <span class="number">8</span>,height /<span class="number">8</span>,width * <span class="number">3</span>/<span class="number">4</span> ,height * <span class="number">3</span> / <span class="number">4</span>)</span><br><span class="line"><span class="comment">//初始化一个视图+正交矩阵</span></span><br><span class="line"> Projection[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">-1.f</span> / camera.z;<span class="comment">//设置矩阵中第四行第三列的值为-z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接着，我们需要在绘制模型时做一些改动，回归我们最开始绘制的方法，我们需要两个坐标，分别是屏幕以及世界坐标，之后，我们就可以用矩阵的方式得到屏幕坐标，相比之前更加方便了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vec3i screen_coords[<span class="number">3</span>];</span><br><span class="line">Vec3f world_coords[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    Vec3f v = model-&gt;<span class="built_in">vert</span>(face[j]);</span><br><span class="line">    screen_coords[j] = <span class="built_in">m2v</span>(ViewPort * Projection * <span class="built_in">v2m</span>(v));</span><br><span class="line">    world_coords[j] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于矩阵部分的设置，基本上就到此结束了，接下来我们就可以正式进入对于模型加载贴图并绘制的部分了。我们需要修改Model头文件，添加uv坐标以及导入图片纹理的方法。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南</li><li><a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a></li><li>我的项目地址：</li><li><a href="https://github.com/Pleasant233/EasyRender">https://github.com/Pleasant233/EasyRender</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EasyShader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EasyShader小结——完成材质添加</title>
      <link href="/2025/01/24/EasyShader5%E2%80%94%E2%80%94%E6%9D%90%E8%B4%A8%E7%AF%87/"/>
      <url>/2025/01/24/EasyShader5%E2%80%94%E2%80%94%E6%9D%90%E8%B4%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li>接下来，在让我们的渲染器以三维形式工作前，我们需要先完成前面遗留的一点小问题，我们目前还无法渲染一张纹理。</li><li>这在原教程中为一个家庭作业，因为我们的目的是了解渲染器如何工作而不是成为一个图形程序。</li><li>因此，我们之后的代码以实现效果的学习为主而不是重构和追求代码的封装架构，当然后续会尽可能地将方法封装为类。</li></ul><hr><ul><li>如果想要有一个如下图类似的苹果材质，我们需要怎么做呢？</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-30%20095357.png" alt="屏幕截图 2024-05-30 095357.png"><br>  <code>4.1 技术部正式群的头像苹果图片</code></li></ul><hr><ul><li>大致分为以下几个步骤<ul><li>首先，我们需要获取并导入纹理</li><li>接着，我们需要正确的读取并映射纹理（还记得UV坐标吗）</li><li>最后我们需要输出带有纹理信息的图片</li></ul></li><li>接下来，我们通过阅读源码逐一进行学习。感谢开源的大佬为我们提供了学习的平台，我们在理解的基础上运用代码学习，本身也算是一种实践。</li></ul><hr><h2 id="4-1-1-修改Model类以适应更新"><a href="#4-1-1-修改Model类以适应更新" class="headerlink" title="4.1.1 修改Model类以适应更新"></a>4.1.1 修改Model类以适应更新</h2><ul><li>首先，为了加载材质，我们需要进行一些准备工作，其中之一就是，先要保证我们能够获取并导入纹理，在model中，我们增加了面法线，面uv，这些都可以在obj文件中获取，接着，我们增加了一个TGAIMAGE对象作为存储漫反射纹理的目标，并增加了对应的uv映射，以及漫反射贴图映射计算的函数，为我们第二步工作做好准备。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Vec3f&gt; norms_;<span class="comment">//面法线</span></span><br><span class="line">std::vector&lt;Vec2f&gt; uv_;<span class="comment">//面uv</span></span><br><span class="line">TGAImage diffusemap_;<span class="comment">//漫反射贴图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load_texture</span><span class="params">(std::string filname, <span class="type">const</span> <span class="type">char</span>* suffix, TGAImage&amp; img)</span></span>;<span class="comment">//加载贴图</span></span><br><span class="line"></span><br><span class="line"><span class="function">Vec2i <span class="title">uv</span><span class="params">(<span class="type">int</span> iface, <span class="type">int</span> nvert)</span></span>;<span class="comment">//加载uv函数</span></span><br><span class="line"><span class="function">TGAColor <span class="title">diffuse</span><span class="params">(Vec2i uv)</span></span>;<span class="comment">//漫反射贴图映射计算。</span></span><br></pre></td></tr></table></figure><ul><li>详细的内容我们在Model.cpp中定义，这也是应用了声明与定义分离的思想。</li></ul><hr><ul><li>在上一节中我们最后将代码重构为加入矩阵的版本，我们重构了geometry类，这也为我们本讲对于Modle类的重构提供了便利。</li><li>接下来我们进入对于主函数的修改。我们将重新编写之前的深度缓冲，三角形绘制方法，让其能够支持绘制纹理</li><li>首先我们抽象出了一个int指针类型的变量用于记录深度信息，其为zbuffer将其初始化为NULL</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* zbuffer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li>接下来，我们在主函数中初始化它，这与我们先前做的一样。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zbuffer = <span class="keyword">new</span> <span class="type">int</span>[width * height];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; width * height; i++) &#123;</span><br><span class="line">    zbuffer[i] = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与申请模型空间一直，在运行结束后我们需要释放我们申请的空间，因此在主循环结尾，我们需要释放zbuffer</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] zbuffer;</span><br></pre></td></tr></table></figure><hr><h1 id="4-4-更新三角形绘制方法"><a href="#4-4-更新三角形绘制方法" class="headerlink" title="4.4 更新三角形绘制方法"></a>4.4 更新三角形绘制方法</h1><ul><li>这里为了便于大家理解，我们回归最开始的扫描线绘制方法，当然包围盒同样也可以绘制纹理，可以单独为包围盒算法计算uv纹理坐标，这一点大家可以自行开发。</li><li>这里只为各位提供思路。先前我们了解到，实际上uv坐标就是一个对应查找的坐标映射，大家可以理解为一个函数，所以其查找方法与我们绘制直线的方法应当是相同的。也就是都需要进行插值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vec2i uvA = uv0 + (uv2 - uv0) * alpha;</span><br><span class="line">Vec2i uvB = second_half ? uv1 + (uv2 - uv1) * beta : uv0 + (uv1 - uv0) * beta;</span><br></pre></td></tr></table></figure><hr><ul><li>我们需要修改传入参数的部分，将其修改为传入uv0，uv1，uv2的部分，这些参数本身来源于我们的obj模型数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec3i t0, Vec3i t1, Vec3i t2, Vec2i uv0, Vec2i uv1, Vec2i uv2, TGAImage&amp; image, <span class="type">float</span> intensity, <span class="type">int</span>* zbuffer)</span></span></span><br></pre></td></tr></table></figure><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250123150501.png" alt="image.png"><br>  <code>4.4 obj中的uv坐标信息</code></li></ul><hr><ul><li>随后，我们在A和B之间进行插值计算，得到逐个点的坐标以及uv坐标信息，并且以该点坐标为索引设置其深度值，这时，我们会从模型的漫反射贴图中取得该点对应的颜色信息，并依照该点强度值进行设置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = A.x; j &lt;= B.x; j++) &#123;</span><br><span class="line">    <span class="type">float</span> phi = B.x == A.x ? <span class="number">1.</span> : (<span class="type">float</span>)(j - A.x) / (<span class="type">float</span>)(B.x - A.x);</span><br><span class="line">    Vec3i   P = <span class="built_in">Vec3f</span>(A) + <span class="built_in">Vec3f</span>(B - A) * phi;</span><br><span class="line">    Vec2i uvP = uvA + (uvB - uvA) * phi;</span><br><span class="line">    <span class="type">int</span> idx = P.x + P.y * width;</span><br><span class="line">    <span class="keyword">if</span> (zbuffer[idx] &lt; P.z) &#123;</span><br><span class="line">        zbuffer[idx] = P.z;</span><br><span class="line">        TGAColor color = model-&gt;<span class="built_in">diffuse</span>(uvP);</span><br><span class="line">        image.<span class="built_in">set</span>(P.x, P.y, <span class="built_in">TGAColor</span>(color.r * intensity, color.g * intensity, color.b * intensity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-5-采样并设置uv"><a href="#4-5-采样并设置uv" class="headerlink" title="4.5 采样并设置uv"></a>4.5 采样并设置uv</h1><ul><li>最后我们只需要对uv进行采样并设置就好了，这一点实际上跟采样顶点很类似，我们实例化一个二维向量数组，随后将模型对应的uv点坐标设置在上面就可以了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec2i uv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">    uv[k] = model-&gt;<span class="built_in">uv</span>(i, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，我们只需要将所有数据传入triangle函数中，就可以得到一个有diffuse贴图的苹果了。</li></ul><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20250123151930.png" alt="image.png"><code>4.5  最后结课成品</code></p><hr><h1 id="4-6-结语"><a href="#4-6-结语" class="headerlink" title="4.6 结语"></a>4.6 结语</h1><ul><li>不知不觉，我们的图形学分享课就要跟大家说再见了，但是学习图形学的路程依旧漫长，我们只不过是瞥见了冰山一角。EasyShader渲染器为我们提供了很多便利，大家可以跟随原作者的路线继续学习，同样的进阶版渲染器也可以在我的github上找到。下学期会继续给大家分享进阶的光线追踪以及渲染器实践~，还有正式的Shader内容，敬请期待，新的一年，我们一起进步！</li></ul><hr><ul><li>计算机图形学入门——3D渲染指南</li><li><a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a></li><li>我的项目地址：</li><li><a href="https://github.com/Pleasant233/EasyRender">https://github.com/Pleasant233/EasyRender</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EasyShader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学11——几何</title>
      <link href="/2025/01/24/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A611%E2%80%94%E2%80%94%E5%87%A0%E4%BD%95/"/>
      <url>/2025/01/24/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A611%E2%80%94%E2%80%94%E5%87%A0%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="11-1-几何的应用"><a href="#11-1-几何的应用" class="headerlink" title="11.1 几何的应用"></a>11.1 几何的应用</h1><ul><li>我们之前用三角形代替几何图元，这是一种很简单而基础的表示方法，但在真实世界里，很明显我们并不能用这一种简单的图形表示所有的几何形状，因此本节我们将来看一看几何方面诸多的表示方法与应用。</li></ul><hr><h2 id="11-1-1-复杂曲面"><a href="#11-1-1-复杂曲面" class="headerlink" title="11.1.1 复杂曲面"></a>11.1.1 复杂曲面</h2><ul><li>几何方面表示的其中一个典型例子就是复杂的曲面，比如赛车游戏中光滑的汽车模型，就不单是用三角形来进行近似表示了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Forza%20Horizon%204%20Screenshot%202024.09.30%20-%2021.43.24.91.png" alt="Forza Horizon 4 Screenshot 2024.09.30 - 21.43.24.91.png"><br>  <code>11.1.1 复杂曲面的例子——地平线4</code></li></ul><hr><h2 id="11-1-2-毛发渲染"><a href="#11-1-2-毛发渲染" class="headerlink" title="11.1.2 毛发渲染"></a>11.1.2 毛发渲染</h2><ul><li>毛发渲染同样十分需要几何层面的知识与优化，因为其数量巨大，而渲染与存储它更是业界一直在探寻的难题。</li><li>通过一些手段我们可以更加顺滑优化地表示它。最典型的毛发渲染就是最终幻想系列。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/b12fdeb36461e71fd69571f940c64538.jpg" alt="b12fdeb36461e71fd69571f940c64538.jpg"><br>  <code>11.1.2 复杂的毛发渲染例子——最终幻想15</code></li></ul><hr><h2 id="11-1-3-几何体优化"><a href="#11-1-3-几何体优化" class="headerlink" title="11.1.3 几何体优化"></a>11.1.3 几何体优化</h2><ul><li>对于场景中大量的几何体聚集的情况，我们也需要通过各式各样的方法进行优化，最耳熟能详的应该是LOD技术</li><li>这个技术与前文提到过的MIPMAP技术结合使用可以得到很好的性能优化与画面权衡表现的作用，经典的例子就是漫威蜘蛛侠中城市场景。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/1817070_1.jpg" alt="1817070_1.jpg"><br>  <code>11.1.3 几何体优化的例子——漫威蜘蛛侠1</code></li></ul><hr><h1 id="11-2-几何的表示方法"><a href="#11-2-几何的表示方法" class="headerlink" title="11.2 几何的表示方法"></a>11.2 几何的表示方法</h1><ul><li>几何的表示分为显式与隐式。</li></ul><hr><h2 id="11-2-1-隐式的表示"><a href="#11-2-1-隐式的表示" class="headerlink" title="11.2.1 隐式的表示"></a>11.2.1 隐式的表示</h2><ul><li>隐式表示实际上是一种判断方法，满足该条件的点就都可以存在。</li><li>而一般也是以数学公式体现的，比如大家高中学过的点线面的公式，再比如我们会在高数中学到的体的公式，它不告诉我们具体的位置，我们可以将其理解为一种函数。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125085838.png" alt="image.png"><br> <code>11.2.2 隐式的表示实例</code></li></ul><hr><ul><li>虽然隐式表达非常不直观，但是它可以用来检测一个固定的点在不在这个几何体上。下面我们来看显式的表示方法。</li></ul><h2 id="11-2-2-显式的表示"><a href="#11-2-2-显式的表示" class="headerlink" title="11.2.2 显式的表示"></a>11.2.2 显式的表示</h2><ul><li>第一种就是直接将几何体给出，比如建模得到的一个复杂几何体。</li><li>第二种就是通过参数映射方式，在一个二维平面中的点我们用对应的函数去映射到三维空间之中，这和展UV的概念类似。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125090534.png" alt="image.png"><br>  <code>11.2.2 参数映射表示法</code></li></ul><hr><p>11.2.3 CSG表示法</p><ul><li>当然几何的表示方法远远不止以上说的这些，CSG（constructive Solid Geometry）就是一种表示法，它是通过两个简单几何体进行各式各样的运算来得到新的几何体，比如交并补等等。这种运算也被称为布尔运算。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125091126.png" alt="image.png"><br>  <code>11.2.3 CSG 的具体案例</code></li></ul><hr><p>11.2.4 距离表示法</p><ul><li>距离表示法也叫做距离场表示法。这种表示法不去定义具体的几何元素，而是定义任意一点到他的距离，最经典的应用就是融球，在星铁中匹诺康尼场景中就有体现。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125091734.png" alt="image.png"><br>  <code>11.2.4 距离场融球案例——星铁</code></li></ul><hr><ul><li>下面我们来细致理解一下距离函数，或者说叫有向距离场。</li><li>首先如果我们想混合两个物体在屏幕上呈现的占比，我们如果直接混合的话，会得到并非平滑过度的值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125093018.png" alt="image.png"><br>  <code>11.2.4 非平滑过度的直接混合</code></li><li>而SDF函数就可以让我们根据两个面之间的距离关系，平滑的混合这些值，你可以理解为原本其并没有如此细分属性，而距离函数让其本身具备了这样多元的属性，如果我们再对其进行操作，就可以过度的很顺滑了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241125094040.png" alt="image.png"><br>  <code>11.2.4 SDF函数后的混合方式</code></li></ul><hr><h2 id="11-2-5-显示表示方法示例"><a href="#11-2-5-显示表示方法示例" class="headerlink" title="11.2.5 显示表示方法示例"></a>11.2.5 显示表示方法示例</h2><ul><li>点云，顾名思义，由很多点形成的画面，最具代表性的就是高斯抛雪球方法呈现出来的3维立体建模，感兴趣的同学可以浏览下面网页。</li><li><a href="https://lumalabs.ai/">https://lumalabs.ai/</a></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241126104337.png" alt="image.png"><br>  <code>11.2.5 视频生成的AI三维建模</code></li></ul><hr><ul><li>面片，就是引擎与DCC软件中常用到的基本几何形体表示元素。一般多为三角面或四边形，如果在引擎中（Unity举例）打开线框预览模式就能看出整个物体是以一个一个面片组成。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241126105317.png" alt="image.png"><br>  <code>11.2.5.1 Unity中的线框显示</code></li></ul><hr><ul><li>我们的EasyShader使用了一种以这样的数据格式作为代表的模型输入格式——TheWavefront Object File（.OBJ）格式。</li><li>这种格式的特点就是，一切以数值记录，因此存储空间小，我们可以看到有面法线，面纹理坐标，顶点等一系列数据，我们通过读取这些数据，在软件中用我们的算法绘制图形。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241126105046.png" alt="image.png"><br>  <code>11.2.5.2 .obj格式实例</code></li></ul><hr><h2 id="11-2-6-曲线——贝塞尔曲线"><a href="#11-2-6-曲线——贝塞尔曲线" class="headerlink" title="11.2.6 曲线——贝塞尔曲线"></a>11.2.6 曲线——贝塞尔曲线</h2><ul><li>贝塞尔曲线是一种平滑曲线的表示方式，它在很多软件中都有应用，比如平滑运动，或平滑线条线段等等，我们往往通过它来实现一些自由的曲线表示，下面我们来深入了解贝塞尔曲线的原理。</li></ul><hr><ul><li>首先，我们定义曲线的方式可以用近似的思想体现。也就是如果我们希望有一条曲线，那么我们就先定义几条直线。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604204651.png" alt="Pasted image 20240604204651.png"><br>  <code>11.2.6 贝塞尔曲线第一步——找到第一个中心点</code></li><li>在B0到B2的阶段，我们让其拥有一个过渡值b1，想象一下，我们规定从b0到b1需要经过一个单位时间。而我们可以在其上任意取一个时间t，现在假设是t &#x3D; 1&#x2F;3 处。我们在此处可以取一个点，我们将其命名为b01</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604204716.png" alt="Pasted image 20240604204716.png"><br>  <code>11.2.6.1 贝塞尔曲线第二步——找到第一个t时间点</code></li><li>现在，我们只需要继续这个过程，通过不同的参数t就可以绘制出不同样式的贝塞尔曲线了，这种绘制方法叫做二阶贝塞尔曲线。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604204936.png" alt="Pasted image 20240604204936.png"><br>  <code>11.2.6.2 贝塞尔曲线第3-n步——递归绘制</code></li><li>大家可以通过下面这个网站直观地看到演示，还可以跟着互动~</li><li><a href="https://www.longluo.me/projects/bezier/">https://www.longluo.me/projects/bezier/</a></li></ul><hr><ul><li>下面我们来看它的数学表达式。本质上得出每一个点的过程就是进行线性插值的过程，每一个点都可以用起始点和终点进行线性插值，而且下一层的点一定可以用上一层进行表示</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604214935.png" alt="Pasted image 20240604214935.png"><br>  <code>11.2.6.3 贝塞尔曲线的推导</code></li></ul><hr><ul><li>对于B02我们就可以用最底层的B0 B1以及B2表示</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604215109.png" alt="Pasted image 20240604215109.png"><br>  <code>11.2.6.4 第二阶贝塞尔曲线表达式</code></li><li>你是否能总结出规律？</li><li>没错实际上它就是一个二项式的形式，这样我们就可以使用多项式展开将其扩展到N维。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604215224.png" alt="Pasted image 20240604215224.png"><br>  <code>11.2.6.5 多项式展开</code></li><li>我们进一步总结</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240604215242.png" alt="Pasted image 20240604215242.png"><br>  <code>11.2.6.6 N阶贝塞尔曲线表示法</code></li><li>至此我们就可以表述任意曲线了，对三维同样适用，至此我们解决了开头提到的第一个问题，现在你也可以在软件中造出一台精美绝伦的车辆模型了~</li></ul><hr><h2 id="11-2-7-逐段的贝塞尔曲线"><a href="#11-2-7-逐段的贝塞尔曲线" class="headerlink" title="11.2.7 逐段的贝塞尔曲线"></a>11.2.7 逐段的贝塞尔曲线</h2><ul><li>前面我们了解了单独的贝塞尔曲线，但是我们会发现，如果想去定义更复杂的曲线形状，往往单纯用贝塞尔曲线就不够了，我们需要进一步完善这个方法。</li><li>各位在使用PS时应该会发现，有一个很常用但是也很难懂的工具——钢笔工具。</li><li>它本身实际上就是一个多段的贝塞尔曲线，通过这个工具你可以绘制出几乎任意你想要的特定曲线。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241130103911.png" alt="image.png"><br>  <code>11.2.7 Ps中的钢笔工具实例</code></li></ul><hr><ul><li>逐段定义的贝塞尔曲线一般具备四个点，分别是起点终点以及两个对应的控制点。通过调控控制点的位置来控制曲线的弯曲程度。</li><li>逐段链接的贝塞尔曲线也有不同的链接方式，其中在几何上连续的贝塞尔曲线叫做C0连续，也就是第一段贝塞尔曲线的终点与第二段贝塞尔曲线的起点相等。</li><li>而如果他们的切线方向也相同并且控制点等距，我们就称之为C1连续。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241130104749.png" alt="image.png"><br>  <code>11.2.7.1 贝塞尔曲线连续的方式</code></li></ul><hr><h2 id="11-2-8-样条曲线"><a href="#11-2-8-样条曲线" class="headerlink" title="11.2.8 样条曲线"></a>11.2.8 样条曲线</h2><ul><li>样条在很多DCC软件中也有广泛使用，比如blender中颜色渐变节点中渐变方式就有样条这一类型。</li><li>样条本身也是一种曲线，满足一定的连续性，是一种简单可控的曲线。</li><li>B-Splines也叫β样条。叫做基函数样条，我们之前总结出的贝塞尔曲线公式就叫做基函数。β样条也是对贝塞尔曲线的扩展。</li><li>因为贝塞尔曲线牵一发动全身的特点，因此在设计上不符合直觉，因此诞生出来了β样条，它可以对局部的细节进行调整。在此我们不多赘述，感兴趣的同学：</li><li>【清华大学-计算机图形学基础（国家级精品课）】 <a href="https://www.bilibili.com/video/BV13441127CH/?p=13&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV13441127CH/?p=13&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241130110921.png" alt="image.png"><br>  <code>11.2.8 blender中颜色渐变的β样条模式</code></li></ul><hr><h1 id="11-3-曲面"><a href="#11-3-曲面" class="headerlink" title="11.3 曲面"></a>11.3 曲面</h1><h2 id="11-3-1-贝塞尔曲面"><a href="#11-3-1-贝塞尔曲面" class="headerlink" title="11.3.1 贝塞尔曲面"></a>11.3.1 贝塞尔曲面</h2><ul><li>前文我们提到了贝塞尔曲线，它是二维的，在三维中，同样我们也可以利用贝塞尔公式去定义曲面，只不过它是一个数组的形式。</li><li>我们通过在空间中定义一系列的贝塞尔曲线，来获得所需的控制点。通过这些控制点作为一条贝塞尔曲线的表示方法，来形成一个贝塞尔曲面。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/11.3%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E9%9D%A2.png" alt="11.3贝塞尔曲面.png"><br>  <code>11.3.1 贝塞尔曲面的形成</code></li><li>因为贝塞尔曲线的性质，我们可以定义两个参数对应之前我们所提到的UV坐标，通过这两个点的变换，我们就可以得到该曲面在UV坐标上的映射，以此得到UV贴图。</li></ul><hr><h2 id="11-3-2-模型细分"><a href="#11-3-2-模型细分" class="headerlink" title="11.3.2 模型细分"></a>11.3.2 模型细分</h2><ul><li>我们之前了解到，模型是由众多三角面组成。而三角面是由众多顶点组成的，在着色部分我们讲过，增加三角形顶点数量可以拥有更好的着色效果，而增加三角形顶点数量的方法便被成为细分。</li><li>我们在Blender等DCC软件中，细分是一个基础的操作。它本质上就是让模型顶点变化频率增加，能够更加顺滑的体现出细节。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241201112347.png" alt="image.png"><br>  <code>11.3.2 blender中的模型细分</code></li></ul><hr><ul><li>接下来，我们来看它的原理。首先，细分大致可以分为两步操作。</li><li>首先第一步，创建更多新的三角形，这一步很简单，我们可以取原三角形三边中点，分别连线，形成四个新的三角形。这样的划分方式也叫做Loop细分（发明人姓Loop）。</li><li>接下来，我们就需要处理新形成的三角形的位置。</li><li>对于一个新的顶点，往往被几个三角形所共享，我们就可以利用就顶点的位置对新顶点进行加权平均，这样就能获得更加平滑的新三角形。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241201113516.png" alt="image.png"><br>  <code>11.3.2.1 新生成顶点的处理方式</code></li></ul><hr><ul><li>下一步，我们还需要来看老顶点如何更新，新顶点有一部分是要听从于老顶点的变化，因此老顶点的更新十分重要。</li><li>老顶点的更新需要参考两部分，一部分来源于这些老顶点自身，一部分来源于其周围的顶点，同样是进行一定的插值运算，其中有两个参考值，一个是变换目标的’度’,这是图论的概念，实际上很好理解，就是该点与多少个顶点相连接。另一个参考值为u，是根据度来进行的变化，最后通过这两个参考值对图形进行插值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241201114721.png" alt="image.png"><br>  <code>11.3.2.2 旧顶点的更新方式</code></li></ul><hr><ul><li>非三角面细分</li><li>以上我们提到的Loop细分方法是针对三角面进行细分的，而往往我们在实际操作中遇到的网格体不止有三角面一种。接下来介绍的这种Catmull方法就是针对更普遍的网格细分法。</li><li>我们先将网格分为四边形与非四边形两种类型。随后我们定义一个概念叫做奇异点（Extraordinary vertex），也就是度不为4的点，度的概念希望你还记得，也就是所连接的边的数量。</li><li>我们进行细分的方式就是，首先取三角形中点以及面的中点，并将其连接，我们就能得到一系列新的多边形。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241201115954.png" alt="image.png"><br>  <code>11.3.2.3 CatMull细分法</code></li></ul><hr><ul><li>经过上述变换后，我们会发现，奇异点数量增加了。我们可以总结出规律，在非四边形面中增加点，增加出的一定是一个奇异点，非四边形面都消失了。</li><li>但如果我们继续细分之后奇异点数量就不会再继续增加了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241201120325.png" alt="image.png"><br>  <code>11.3.2.4 CatMull细分法-进一步细分</code></li><li>CatMull 等细分方法应用的领域非常多，可以提升画面的表现力以及精度，但有些时候，尤其是在游戏里，我们不希望所有的面都是高精度的，这样会很卡，所以就要牵扯到我们的下一个话题，有细分就有简化，接下来我们来看模型面数的简化，比如Lod技术以及UE的独家技术Nannite网格体。</li></ul><hr><h2 id="11-4-模型的简化"><a href="#11-4-模型的简化" class="headerlink" title="11.4 模型的简化"></a>11.4 模型的简化</h2><ul><li>首先，模型的简化与模型的细分相反，是为了减少三角形面数而诞生的优化手段，不同面数的三角形带来的整体质感是不一样的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241202091427.png" alt="image.png"><br>  <code>11.4 Blender中应用了不同等级的细分修改器后的结果</code></li><li>而对于一些距离我们很遥远的物体，其往往不需要呈现出复杂的细节，因此在游戏中，会将其应用为面数比较低的模型。</li><li>这样的模型先前是需要美术人员手动生成低模，并添加到对应的LOD层级之中。而在Ue中，一种叫做Nannite网格体的技术，可以为我们自动生成这样的低模，今年大火的黑神话就是得益于这样的的技术，让其扫描出的模型能够放心大胆的放入场景之中。</li></ul><hr><h2 id="11-4-1-Nannite网格体"><a href="#11-4-1-Nannite网格体" class="headerlink" title="11.4.1 Nannite网格体"></a>11.4.1 Nannite网格体</h2><ul><li>根据Ue官方文档，我们可以了解到，Nannite在保证帧率流畅的同时，将渲染精度提升了数个数量级。并且支持自动处理细节级别，也就是我们前文提到的LOD。不需要再手动设置这些单个的网格体。</li><li>Ue会根据摄像机远近，自然地调整LOD级别，增加或减少三角形面数。Nannite会将模型拆分为三角形集群，并根据流动只渲染所能见到的细节。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/11.4.1%20Nannite%E7%BD%91%E6%A0%BC%E4%BD%93%E5%AE%9E%E4%BE%8B.png" alt="11.4.1 Nannite网格体实例.png"><br>  <code>11.4.1 Nannite网格体实例</code></li><li>想了解更多内容的各位可以在Ue官方文档中查看</li><li><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/nanite-virtualized-geometry-in-unreal-engine">https://dev.epicgames.com/documentation/zh-cn/unreal-engine/nanite-virtualized-geometry-in-unreal-engine</a></li></ul><hr><h2 id="11-4-2-原理及细节"><a href="#11-4-2-原理及细节" class="headerlink" title="11.4.2 原理及细节"></a>11.4.2 原理及细节</h2><ul><li>接下来，我们来看一下模型简化的原理，是如何做到不破坏原有三角面的大致结构的前提下，还能减少三角面面数的呢？</li><li>边坍缩算法</li><li>边坍缩算法的理解上很简单，我们需要减少三角面数，三角面是由诸多边组成的，我们想要减少三角面数，只需要减少三角边数就好了，也就是将一条边压缩为一个点。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241202095939.png" alt="image.png"><br>  <code>11.4.2 边坍缩算法</code></li></ul><hr><ul><li>原理上很好理解，但实现上并不容易，因为我们会发现，如果单纯的压缩，会导致新生成的模型与原本模型差距巨大。导致模型走样。</li><li>因此我们引入了一个新的方法，叫做二次误差度量，这个意思是我们检测这个新生成的点，到原本的点所在平面的距离的平方和，合适此值最小，何时为最佳生成点。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241202100132.png" alt="image.png"><br>  <code>11.4.2.1 二次误差度量</code></li></ul><hr><ul><li>但是面对大量的三角形面，我们需要用更加效率的方式存储并排序，这就涉及到数据结构中的优先队列结构，以及贪心算法了。</li></ul><hr><ul><li>优先队列</li><li>优先队列是一种抽象的数据类型，每个元素都有各自的优先级，优先级最高的元素首先得到服务，通常使用堆实现。是找到我们所需元素的合适结构。</li><li>贪心算法</li><li>贪心算法叫做算法，实际上是一种策略，一切都为了找到最优解，实际上我们所做的这件事本身就是贪心算法的一种体现。</li><li>贪心算法可以有以下几步<ul><li><ol><li>建立数学模型来描述我们的问题</li></ol></li><li><ol start="2"><li>将求解问题分出若干子问题，也叫单一原则</li></ol></li><li>3.对每一子问题求解，得到局部最优解</li><li>4.将子问题的局部最优解汇总形成总体最优解。</li></ul></li><li>当然实际的应用有很多，各位可以自行了解。</li><li><a href="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241202100132.png">https://pleasant233.oss-cn-beijing.aliyuncs.com/20241202100132.png</a></li></ul><hr><h1 id="11-5-写在最后"><a href="#11-5-写在最后" class="headerlink" title="11.5 写在最后"></a>11.5 写在最后</h1><ul><li>至此，我们初入图形学的脚步就告一段落了，回顾我们的历程，一共前前后后写了将近4万多字，大致带领大家与我一起初识了图形学光栅化的入门内容，并且编写了一个大家自己的渲染器。</li><li>我分享本课的目的是总结自己学习的过程，说实话，很多东西第二遍看才算基本弄懂，我也是现学现卖。作为第一节分享课，我们在实践与理论中进行学习，所有枯燥乏味的知识我都尽量通俗并寻找实际应用中的案例讲解。希望各位阅读时不会有太多不理解的地方吧。（尽力了~）</li><li>本系列课将持续增添删改内容。下一部分打算做光线追踪方面的入门课，并且做Shader的语法与基础入门。带领大家正式进入应用的领域。</li><li>最后，再次感谢各位的支持，感谢我校的zy老师，101课程的闫令琪老师等诸多学术大牛的启蒙。祝大家能够在学业中，有所精进，有所收获！我们下一段分享课再见！</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>Ue文档 <a href="https://dev.epicgames.com/documentation/zh-CN/unreal-engine">https://dev.epicgames.com/documentation/zh-CN/unreal-engine</a></li><li>维基百科 <a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学10——着色2</title>
      <link href="/2025/01/22/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A610%E2%80%94%E2%80%94%E7%9D%80%E8%89%B22/"/>
      <url>/2025/01/22/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A610%E2%80%94%E2%80%94%E7%9D%80%E8%89%B22/</url>
      
        <content type="html"><![CDATA[<h1 id="10-1-着色频率"><a href="#10-1-着色频率" class="headerlink" title="10.1 着色频率"></a>10.1 着色频率</h1><ul><li>上一节我们说到了一个简单的着色模型，这些着色模型是应用在一个点上的，我们叫做着色点，但不同的应用对象也会有不同的效果。</li></ul><hr><h2 id="10-1-1-Flat着色"><a href="#10-1-1-Flat着色" class="headerlink" title="10.1.1 Flat着色"></a>10.1.1 Flat着色</h2><ul><li>这种着色方式所对应的着色‘点’，实际上是一个面，我们在blender里新建一个球体，如果面数很低的话，它就会呈现出下面这种样子，可以看到着色是分块进行的，过度非常不自然，也被称为平直着色。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115160641.png" alt="image.png"><br>  <code>10.1.1 Flat着色下的球体</code></li><li>说回到原因，其本质是因为，我们着色时是需要法线这个重要参数的，而Flat着色，每个面只有一个法线信息，也就是该面对应的法线，因此我们只能得到这样的效果。</li></ul><hr><h2 id="10-1-2-Gouraud着色"><a href="#10-1-2-Gouraud着色" class="headerlink" title="10.1.2 Gouraud着色"></a>10.1.2 Gouraud着色</h2><ul><li>这种着色方式相比之前的Flat着色是逐顶点的，也就是说计算每一个顶点的法线数据，以此来进行着色计算，这种计算方式要比Flat方式更加平滑，其实就是根据顶点附近的几个面的法线信息进行平均计算，最后得到这个顶点的法线值。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115161813.png" alt="image.png"><br>  <code>10.1.2 Gouraud着色下的球体</code></li><li>可以看到有很明显的区别，着色明显更平滑光滑了，但我们依旧可以继续提升它，尽管此着色方式的效果已经很不错了。</li></ul><hr><h2 id="10-1-3-Phong着色"><a href="#10-1-3-Phong着色" class="headerlink" title="10.1.3 Phong着色"></a>10.1.3 Phong着色</h2><ul><li>Phong着色是逐像素的着色方式，这种着色方式应用了逐像素的插值，将每一个点的着色信息全部计算，是最光滑最均匀的着色方式，因为它已经精确到了像素。这种计算方式需要一个全新的知识——重心坐标，我们同样会讲到，现在来看看它的表现。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115162212.png" alt="image.png"><br>  <code>10.1.3 Phong着色下的球体</code></li></ul><hr><ul><li>可以看到相比上一幅图，它的明暗过度更为细腻丝滑，这是因为每一个呈现在屏幕上的像素都会被计算到，因此过度的非常自然，当然代价就是，它的计算量很大，会很消耗性能，因为在编写着色器的时候，这部分内容将被放在片元着色器中，这使得其会消耗更多的性能，本节我们将重新认识渲染管线，相信经过着色部分的学习，你应该对渲染管线有了更加深入地理解。</li></ul><hr><h2 id="10-1-4-添加更多的面"><a href="#10-1-4-添加更多的面" class="headerlink" title="10.1.4 添加更多的面"></a>10.1.4 添加更多的面</h2><ul><li>最后的效果除了着色频率带来的影响，模型本身同样不可忽视，在相同的着色状态下，一个低面数的模型效果往往比高面数的模型效果差。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115162757.png" alt="image.png"><br>  <code>10.1.4 两个同样运用Flat着色下的不同精度的球体</code></li><li>但它的计算消耗也是巨大的，如果你在场景中添加过多的高面数模型，一样会消耗性能，这时就需要去均衡考虑效果，来决定使用不同的方案。</li></ul><hr><h1 id="10-2-再谈渲染管线"><a href="#10-2-再谈渲染管线" class="headerlink" title="10.2 再谈渲染管线"></a>10.2 再谈渲染管线</h1><ul><li>直至目前，我们已经完成了将物体渲染到屏幕上的最基本操作，我们得到了一个有着基本亮暗面的模型，下面我们来回顾一下我们都做了些什么。</li></ul><hr><h1 id="10-2-1-顶点变换部分"><a href="#10-2-1-顶点变换部分" class="headerlink" title="10.2.1 顶点变换部分"></a>10.2.1 顶点变换部分</h1><ul><li>首先，我们在一开始从点入手，了解了顶点是如何经过一系列变换最终变换到屏幕视口坐标下的，这为我们的一切提供了基础。这是管线的第一部分。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115164847.png" alt="image.png"><br>  <code>10.2.1 渲染管线顶点变换部分</code></li></ul><hr><h2 id="10-2-2-三角形部分"><a href="#10-2-2-三角形部分" class="headerlink" title="10.2.2 三角形部分"></a>10.2.2 三角形部分</h2><ul><li>随后，我们将对应的顶点运用算法，将其绘制为三角形片元，作为一切的基础绘制，之后我们开始了光栅化阶段，我们运用了深度缓冲等技术，解决了物体映射到屏幕上的先后顺序，成功绘制了一个带面的模型（如果你跟随实践的话）。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115165424.png" alt="image.png"><br>  <code>10.2.2 渲染管线三角形光栅化阶段</code></li></ul><hr><h2 id="10-2-3-逐片元操作部分"><a href="#10-2-3-逐片元操作部分" class="headerlink" title="10.2.3 逐片元操作部分"></a>10.2.3 逐片元操作部分</h2><ul><li>随后便是我们的着色部分，这一部分我们真正赋予了三角形模型灵魂，我们给予了它明暗面的变化，并且了解了着色模型的着色方式，知道了一个很简单的着色模型，布林冯模型，并将其应用在了我们的模型之上。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241115170055.png" alt="image.png"><br>  <code>10.2.3 基本的渲染管线概览</code></li></ul><hr><h2 id="10-2-4-概述"><a href="#10-2-4-概述" class="headerlink" title="10.2.4 概述"></a>10.2.4 概述</h2><ul><li>至此我们从头至尾大概了解了什么是渲染管线（渲染流水线），并跟随实践了其中一些内容，完成了一个最简单的软光栅渲染器（它真的很简单）。我们了解了每个步骤都做了些什么，正如我之前所说，其中有些部分是可配置的，有些则是可编程的。用于编程他们的语言就是所谓Shader语言，着色语言，比如大家从基础课一开始认识坐标系时就了解到的OPenGL的GLSL，DX的HLSL以及CG，都是作为编程语言编写Shader使用的。</li><li>我们用它来对渲染管线中我们希望定义的部分进行编写。这就催生了两个最常用且应该是必备的着色器阶段。它们分别是VertexShader（顶点着色器），FragmentShader（片元着色器）。</li><li>讲到这里，我们终于可以来看一下我们的代码了，相信我，很想跟大家分享这部分，我们可以开始干活了！</li></ul><hr><h2 id="10-2-5-一个简单的顶点着色器"><a href="#10-2-5-一个简单的顶点着色器" class="headerlink" title="10.2.5 一个简单的顶点着色器"></a>10.2.5 一个简单的顶点着色器</h2><ul><li>后续会有专题文章分享着色器语言的编程学习，这里只作为认识，介绍一下着色器是什么。</li><li>首先一个基本的着色器需要有基本的输入，这也叫做参数，在我最常写的CG语言之上的ShaderLab中，你需要在Shader中声明你传入的变量，它可以是浮点型（注意Shader中一般只有浮点型作为数字变量类型），2D纹理，颜色值等等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Color(&quot;MainColor&quot;, Color) = (1,1,1,1)</span><br><span class="line">_Float1(&quot;Float_1&quot;,Float) = 0.1</span><br><span class="line">_Float2(&quot;Float_2&quot;,Range(0,1)) =0.5</span><br></pre></td></tr></table></figure><ul><li>这样就声明了一个变量，当然在GLSL中你得这么写</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> Float_1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> Color;</span><br></pre></td></tr></table></figure><ul><li>随后，你就可以在你的着色器中计算了。</li></ul><hr><ul><li>在着色器计算部分，你可以将其理解为一个函数体，它有参数也有返回值，不同的语言定义的着色器都不同，我们这里还是展示两种最主流语言的书写方式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct a2v&#123;</span><br><span class="line">float4 vertex : POSITION;</span><br><span class="line">float3 normal : NORMAL;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">struct v2f&#123;</span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float3 texcoord : TEXCOORD;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><ul><li>首先，在Shaderlab中的CG风格语法中，我们首先需要定义结构体，这个结构体正如其名，是用来在两个着色器之间传递参数的。</li></ul><hr><ul><li>随后我们就可以定义着色器代码了，顶点着色器需要使用v2f类型，这是因为其返回值应为传递给片元着色器的返回值类型，而其参数则为a2v 对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>GLSL中则一般片元着色器和顶点着色器分开，并定义统一的传入传出标识符。</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> fragUV;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">gl_Position</span> = <span class="type">vec4</span>(pos,<span class="number">1.0</span>);</span><br><span class="line">fragUV = <span class="type">vec2</span>(uv.x,<span class="number">1.0</span>-uv.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ul><li>片元着色器部分与顶点着色器类似，只不过这部分是真正向外输出的部分，因此返回的就不是结构体类型，而是颜色了。之后会单独出详细的文章分享，接下来让我们关注另一个重要的问题，我们该如何处理逐像素的颜色？换种说法，我们该如何呈现纹理？</li></ul><hr><h1 id="10-3-纹理UV与重心坐标"><a href="#10-3-纹理UV与重心坐标" class="headerlink" title="10.3 纹理UV与重心坐标"></a>10.3 纹理UV与重心坐标</h1><ul><li>经过前文的介绍，在着色时，有一项参数我们其实并没有说清楚，那就是漫反射系数，在实际的游戏，场景之中，漫反射系数在每一个材质的每一个点上其实都是不一样的，而定义它的方式，实际上就是用纹理贴图来定义，接下来我们来看纹理贴图的概念。</li></ul><hr><h2 id="10-3-1-纹理贴图基础概念"><a href="#10-3-1-纹理贴图基础概念" class="headerlink" title="10.3.1 纹理贴图基础概念"></a>10.3.1 纹理贴图基础概念</h2><ul><li>为什么会出现纹理贴图，这是由于对画面表达的丰富度与便捷性的结合而催生出的产物，纹理贴图可以快速的记录一组参数数据，并以直观的图像形式呈现，便于复用扩展修改</li></ul><hr><ul><li>纹理贴图实际上就是一张图片，其本身通过一系列操作映射到物体表面。纹理贴图有很多种类，包括但不限于漫反射贴图，法线贴图，粗糙度贴图，环境光遮蔽贴图，高光贴图，视差贴图等等。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241116193709.png" alt="image.png"><br>  <code>10.3.1 一组纹理图像</code></li><li>那么纹理图像是如何映射到模型上的呢？这就需要提到其中的操作，便是纹理映射，纹理映射自然需要坐标去描述，这就是我们常常听到的UV坐标。</li></ul><hr><ul><li>UV坐标是一组二维坐标，其数值范围是0-1，不论纹理图像本身大小如何，我们都会用这个区间去描述它，相当于你可以理解为纹理图像是面料，但最后穿在身上的才是衣服，而如何穿着在身上就纹理映射的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241116200029.png" alt="image.png"><br>  <code>10.3.1.2 纹理坐标图</code></li></ul><hr><ul><li>从这张图可以看到，颜色对应的是绿色和红色，为什么是这两种颜色呢？前面我们提到RGB颜色中我们将其表示为0-1之间的数值，所以三个值分别对应的就是红绿蓝。因此在这个范围内，我们可以发现它便是红绿两色的混合值。</li><li>我们用这个坐标进行纹理的映射，但这个坐标是建立在模型空间之上的，我们利用一些方法去将模型空间坐标对应在这张纹理坐标上，然后去寻找该点在纹理图像上对应的纹理值</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241116211152.png" alt="image.png"><br>  <code>10.3.1.3 纹理映射的过程</code></li><li>因此实际上纹理坐标只是便于平铺纹理的工具，我们会在很多DCC软件中捡到纹理坐标的应用，也就是我们所说的展UV的过程，实际上就是将贴图与模型上的点进行对应，中间的桥梁叫做纹理坐标。讲到这里各位应该大概明白是什么意思了吧，很不直观，不过现在如果再去软件中操作一下，应该会有不一样的体会</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241116211639.png" alt="image.png"><br>  <code>10.3.1.4 Blender中的UV编辑</code></li><li>大家可以看到上图之中，实际上我们选择的是苹果上表面的顶点，其在左侧UV坐标中对应的区域就是我们现在所看到的样子，很直观的可以体会到实际上物体的顶点是与材质如此一一对应的。</li></ul><hr><h2 id="10-3-2-重心坐标"><a href="#10-3-2-重心坐标" class="headerlink" title="10.3.2 重心坐标"></a>10.3.2 重心坐标</h2><ul><li>重心坐标是用三角形三个顶点来描述三角形内任意一点的方式。</li><li>三角形内任意一点都可以用重心坐标来表示，重心坐标由三角形三点乘以三个系数来表示，且这三个系数和为1</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118083355.png" alt="image.png"><br>  <code>10.3.2 重心坐标</code></li></ul><hr><ul><li>那么如何求这三个系数呢？我们可以利用三角形面积关系来表示。</li><li>三个系数所对应的面积是其对边所成三角形的面积，用这个面积作为分子与整个分母面积相除，得到的就是系数。</li><li>而且我们也可以只计算两个值，由定义求出第三个值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118083831.png" alt="image.png"><br>  <code>10.3.2.1 重心坐标系数表示方法</code></li></ul><hr><h2 id="10-3-3-重心坐标的应用——插值"><a href="#10-3-3-重心坐标的应用——插值" class="headerlink" title="10.3.3 重心坐标的应用——插值"></a>10.3.3 重心坐标的应用——插值</h2><ul><li>先前我们提到，我们想通过一些手段得到一个片元上每一个像素的颜色值，这就需要我们使用纹理。而纹理覆盖在每一个片元上的方式，就是插值。重心坐标就是一种插值手段。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118084852.png" alt="image.png"><br>  <code>10.3.3 重心坐标的应用</code></li><li>但是重心坐标同样存在问题，那就是可能在投影变化下出错，因为在三维空间中使用二维的重心坐标容易出现错误，所以我们应该在三维空间下插值后再去映射到二维坐标。</li></ul><hr><h2 id="10-3-4-纹理的放大与优化"><a href="#10-3-4-纹理的放大与优化" class="headerlink" title="10.3.4 纹理的放大与优化"></a>10.3.4 纹理的放大与优化</h2><ul><li>纹素（Texel——texture pixel）也被成为纹理元素，其是纹理空间中的基本单位，也是我们在查找纹理颜色时搜索的基本单位。</li><li>在纹理放大时我们就需要通过在纹素上做文章来尽量减少因为多个纹素同时映射在同一个像素内而导致的图片模糊问题，由此我们得出了我们的优化方法——双线性差值法。</li></ul><hr><h2 id="10-3-5-双线性差值（Bilinear-Interpolation）"><a href="#10-3-5-双线性差值（Bilinear-Interpolation）" class="headerlink" title="10.3.5 双线性差值（Bilinear Interpolation）"></a>10.3.5 双线性差值（Bilinear Interpolation）</h2><ul><li>在了解双线性插值前，我们首先要先了解线性插值，线性插值是什么呢？如果从数学上定义很像我们画一条直线的方法。画一条直线的时候我们需要知道斜率，而如果知道斜率实际上就等于我们知道了这条线的走向，就是说我们可以定义这条线上任意一点的值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118091029.png" alt="image.png"><br>  <code>10.3.5 线性插值</code></li></ul><hr><ul><li>但在图形学应用中实际上我们可以将其抽象为占比表示，这也是很多真实应用时的方法，我们定义</li><li>lerp（x,v0,v1）&#x3D; v0 + x(v1 - v0)</li><li>这样我们就可以表示v0到v1这条线段上任意一点了。</li><li>正如前文所说，我们应用线性插值的目的在于解决在低像素情况下任意一点所对应纹素值的问题。因此我们就可以使用这个插值方法，先找到临近的四个像素中心，随后对其进行插值，因为t，s长度均为1，实际上就是一个百分比计算</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118091524.png" alt="image.png"><br>  <code>10.3.6 双线性差值——1</code></li></ul><hr><ul><li>接着，由上述操作我们可以得到u1，u2，它们分别是对上下两组像素坐标进行插值得到的结果。随后就要体现我们的‘双’线性插值了。我们将再对这两个值在竖直方向上做插值，最后就能得到对应的我们想要的任何一点的值了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118091749.png" alt="image.png"><br>  <code>10.3.7 双线性差值——2</code></li></ul><hr><ul><li>至此我们就完成了双线性差值的操作，它可以优化低面数模型上的纹理表现效果，让纹理过渡更丝滑清晰，当然我们还可以对更多的像素进行插值，这也被称为三线性插值或三立方插值，大家可以通过下文了解。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC">https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC</a></li></ul><hr><h2 id="10-3-5-过大的纹理带来的问题"><a href="#10-3-5-过大的纹理带来的问题" class="headerlink" title="10.3.5 过大的纹理带来的问题"></a>10.3.5 过大的纹理带来的问题</h2><ul><li>前文我们讨论了如果一个纹理比对应的像素小，该如何优化其显示，接下来我们来看反之的情况，若过大的问题映射在小像素中呢？</li><li>下面这幅图像，右图我们可以看到，远处得到纹理出现了摩尔纹，希望你还记得摩尔纹的概念，摩尔纹就是走样的一种形式，说明我们的图像出现了走样，可为何会出现走样呢？</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119085025.png" alt="image.png"><br>  <code>10.3.5 大纹理映射在屏幕上出现了摩尔纹</code></li></ul><hr><ul><li>这就要回顾我们之前提到的走样的概念，走样就是高频信息的叠加，就是采样频率慢于纹理变化频率。解决方法我们当时也提出了，那就是增加采样率的诸多方法，其中最有代表性的就是MSAA。希望你还记得。</li><li>分析之后我们就可以得出一个简单的解决方案，那就是使用算法进行超采样。但换来的却是庞大的数据开销，会严重影响性能。所以我们还要讨论别的解决方案，这就引出了一个非常重要的概念，那就是范围查询。</li><li>我们先前讨论的都是点查询，何谓点查询，其实就是聚焦于每一个点上的属性，我们之前聚焦的是采样点，而现在，我们需要快速得出一片纹理范围内对应的像素属性，这时候，就需要使用范围查询优化性能了，其中最具代表性的方式就是MIPMAP，也叫多级纹理。</li></ul><hr><h2 id="10-3-6-MIPMAP"><a href="#10-3-6-MIPMAP" class="headerlink" title="10.3.6 MIPMAP"></a>10.3.6 MIPMAP</h2><ul><li>MipMap这个概念其实在引擎使用之中或多或少大家可能都看见过，比如如果你在Unity打开一个纹理对象，它的面板中就会有这一选项。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119091646.png" alt="image.png"><br>  <code>10.3.6 Unity面板中的MIPMAP视窗</code></li></ul><hr><ul><li>MipMap顾名思义，就是小纹理的意思。为了解决范围查询问题，我们将一张纹理上任意相邻像素求其平均并缩放到新一级纹理的一个纹素上，这样。最终我们一定会得到一张单个像素的纹理值（如果其符合方形并且是2的指数次方的像素数的话）</li><li>MIPMAP会由引擎自行生成，而其所占内存总量仅为原本原图的4&#x2F;3倍，这是个级数求和问题，最后得出仅仅会多占1&#x2F;3的空间，是一个非常好的算法。</li><li>而我们该如何将像素对应到纹素并进行查询呢？</li></ul><hr><ul><li>首先，我们先在对应片元上寻找我们感兴趣的点，接着，需要将其映射到Uv坐标下，这个过程其实是在求对应像素的偏导值，在此之后我们就能在对应的UV坐标下获取这个片元像素对应的范围了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119092203.png" alt="image.png"><br>  <code>10.3.6.1 像素映射UV坐标的过程</code></li></ul><hr><ul><li>接着，我们该如何获取这个区域的颜色呢？这就需要我们找到对应的MIPMAP，现在需要一点数学知识。我们知道每一级是上一级对应的两个像素之和，因此共有log2N级MIPMAP，我们只需要去找对应的矩形范围在哪一级变为一个像素范围即可，因此可以得出以下公式：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119092815.png" alt="image.png"><br>  <code>10.3.6.2 MIPMAP层级对应公式</code></li><li>现在我们就可以查找任意像素对应的颜色范围了，因为最终都会对应到一张MIPMAP只需要获取对应的颜色即可。</li></ul><hr><ul><li>我们还能继续优化吗？当然可以，现在我们只有10张图，肯定无法满足所有情况下的查找，如果像素覆盖范围在两张图之间，我们该如何取舍？这时候就要继续用到我们先前所学的概念，那就是插值。</li><li>这次我们要对两张MIPMAP进行插值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119093331.png" alt="image.png"><br>  <code>10.3.6.3 三线性插值</code></li></ul><hr><h2 id="10-3-7-各向异性过滤"><a href="#10-3-7-各向异性过滤" class="headerlink" title="10.3.7 各向异性过滤"></a>10.3.7 各向异性过滤</h2><ul><li>前文所提到了三线性插值，虽然能够获得一个较为平滑的过度，但仍然无法解决一些问题，比如如果一个区域被拉伸为长方形而不是正方向，就无法查询了。这时就会诞生出一个新的解决方法，那就是各向异性过滤。</li><li>各向异性过滤在游戏中有广泛的应用，它的原理实际上很简单，就是通过按不同比率压缩图像，实际上这也叫做RipMap</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119094517.png" alt="image.png"><br>  <code>10.3.7 各向异性过滤RIpMAP</code></li></ul><hr><ul><li>而在引擎中，实际上我们并不是这样做的，因为这样做会消耗很大的内存空间，我们会仍然复用MIPMAP，但这时我们会用同区域的最短边区域查找对应的MIPMAP层级，并沿着各向异性的方向多次采样，这里调节的采样倍数，就是采样次数，这样我们就可以以同样的内存代价获得与RIpMap一样的结果</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119095440.png" alt="image.png"><br>  <code>10.3.7.1 引擎中的采样方案</code></li></ul><hr><h2 id="10-3-8-其他的查询方法"><a href="#10-3-8-其他的查询方法" class="headerlink" title="10.3.8 其他的查询方法"></a>10.3.8 其他的查询方法</h2><ul><li>积分图 利用积分生成各个区域的积分值，并利用算法查找对应的平均值，SAT</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119094935.png" alt="image.png"><br>  <code>10.3.8 SAT 积分图</code></li></ul><hr><h2 id="10-3-9-纹理的优化区间"><a href="#10-3-9-纹理的优化区间" class="headerlink" title="10.3.9 纹理的优化区间"></a>10.3.9 纹理的优化区间</h2><ul><li>在业界，我们优化的目标是尽量降低DrawCall，希望你还记得它是CPU向GPU发送指令的方式。</li><li>我们会将纹理合并为纹理图集，通过使用不同的采样坐标来采样对应的图片，同样我们也可以将纹理放入一个数组之中，这一样可以减少DRAWCALL降低开销。</li></ul><hr><h1 id="10-4-一些常用纹理"><a href="#10-4-一些常用纹理" class="headerlink" title="10.4 一些常用纹理"></a>10.4 一些常用纹理</h1><ul><li>这部分是简单扼要的介绍，主要介绍一下一些在美术和引擎中常用的纹理。</li></ul><h2 id="10-4-1-反射率or漫反射纹理"><a href="#10-4-1-反射率or漫反射纹理" class="headerlink" title="10.4.1 反射率or漫反射纹理"></a>10.4.1 反射率or漫反射纹理</h2><ul><li>这种纹理是提供颜色的基础纹理，我们可以用这种纹理为图像提供基本的颜色。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119100252.png" alt="image.png"><br>  <code>10.4.1 反射率or漫反射纹理</code></li></ul><hr><h2 id="10-4-2-凹凸纹理与法线纹理"><a href="#10-4-2-凹凸纹理与法线纹理" class="headerlink" title="10.4.2 凹凸纹理与法线纹理"></a>10.4.2 凹凸纹理与法线纹理</h2><ul><li>凹凸纹理只记录了每个像素突出的大小，而且这种计算并不能真正改变顶点高度，只能让顶点看起来这样，这是因为它改变了纹理着色的数值，因此会使得不同区域呈现出不同的质感。</li></ul><hr><ul><li>我们可以在一条线身上来看这个问题，原本的这条直线的法线方向是竖直向上的，而如果增加了凹凸贴图，计算时就会改变该点的法线方向。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241120082554.png" alt="image.png"><br>  <code>10.4.2 bump贴图改变表面法线的原理</code></li><li>这样表面法线的数据就被改变了，因此根据我们之前计算漫反射的方法，物体表面就会出现凹凸感。</li></ul><hr><ul><li>法线纹理则实质上使得纹理向不同方向进行突出，不过它仍然无法改变突出大小，但我们可以利用它改变顶点位置。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119100617.png" alt="image.png"><br>  <code>10.4.2.1 加入了基础的凹凸纹理</code></li></ul><hr><h2 id="10-4-3-遮蔽纹理"><a href="#10-4-3-遮蔽纹理" class="headerlink" title="10.4.3 遮蔽纹理"></a>10.4.3 遮蔽纹理</h2><ul><li>这类纹理一般是用来定制一些特殊效果，比如高光遮蔽纹理，环境光遮蔽纹理等，都是用来提供不同的质感。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119100935.png" alt="image.png"><br>  <code>10.4.3 加入了基础的高光遮蔽纹理</code></li></ul><hr><h2 id="10-4-4-环境光"><a href="#10-4-4-环境光" class="headerlink" title="10.4.4 环境光"></a>10.4.4 环境光</h2><ul><li>我们之前一直回避的一个问题，那就是环境光。环境光虽然看起来很简单，不就是环境给物体的映射吗，实际上环境光的计算并不简单，反而是光栅化中最困难的部分，因为我们要获取整个场景的反射，这就是环境光照，动态环境光技术也是图形学前沿一直在努力的话题。现在我们来看一下我们如何巧妙地得到环境光。</li></ul><hr><ul><li>光栅化中，我们尽量减少计算，因此我们更希望通过内存来换取性能的节省，因此，我们往往使用一张环境光贴图来为所有物体提供光照采样。比如Unity中的天空盒子以及UE中的天空光照，实际上就是干的这件事。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/10.4.4Ambient.png" alt="10.4.4Ambient.png"><br>  <code>10.4.4 Ue天空光照开启与关闭对比</code></li><li>可以看到开启环境光之后，整个环境明显变亮很多，细节更加丰富了。</li></ul><hr><h2 id="10-4-5-HDR与HDRI"><a href="#10-4-5-HDR与HDRI" class="headerlink" title="10.4.5 HDR与HDRI"></a>10.4.5 HDR与HDRI</h2><ul><li>首先我们要区分HDR和HDRI的区别。HDR叫做高动态范围，什么是动态范围？</li><li>动态范围是指一张图片中最亮处与最暗处之比。亮部和暗部范围可以非常大。之前我们提到我们使用256种不同的亮度来表现环境。而HDR可以让我们很方便的尽可能记录更多的光照变化。</li><li>用NVIDIA的总结来说：HDR可以让亮部更亮，暗部更暗</li><li>我们可以用HDRI图像来模拟环境光照，往往能得到更加真实的结果。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/indoor.png" alt="indoor.png"><br>  <code>10.4.5 blender中HDRI贴图转模型的实例</code></li></ul><hr><ul><li>至此为止，我们基本上介绍了在光栅化中着色的各类技术，但这只是部分，如果你想进一步了解，欢迎浏览下方的参考资料与网站，我们下一节将来看看渲染中的几何部分。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li><li>UnityShader入门精要——冯乐乐著</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EasyShader——重心坐标检测以及深度缓冲</title>
      <link href="/2025/01/17/EasyShader3%E2%80%94%E2%80%94%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
      <url>/2025/01/17/EasyShader3%E2%80%94%E2%80%94%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E6%A3%80%E6%B5%8B%E4%BB%A5%E5%8F%8A%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-重心坐标"><a href="#3-1-重心坐标" class="headerlink" title="3.1 重心坐标"></a>3.1 重心坐标</h1><ul><li>先前在光栅化部分的理论讲解中，我们大致知道了重心坐标的概念，在此我们再次回顾一下。重心坐标是一种用三个顶点来描述三角形中任意顶点属性值的方法，其三个系数和为1，而我们可以用这样的方法来优化我们对于三角形的描述。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025120903.png" alt="image.png"></li></ul><hr><ul><li>我们通过计算三角形顶点与任意一点P的关系来计算其是否在三角形内，这用到了我们先前提到的判断方法，也就是判断其叉积是否符号一致，而转化到重心坐标中我们就可以用叉积的第三个结果是否小于1来判断。</li><li>如果第三个值小于1，则说明其为0，这是因为我们的数值都是以整数值作为坐标的。于是这个三角形就是不正确的，此时我们直接返回一个错误值即可。若正确我们就返回其在重心坐标下的值即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">barycentric</span><span class="params">(Vec2i *pts, Vec2i P)</span> </span>&#123; </span><br><span class="line">    Vec3f u = <span class="built_in">Vec3f</span>(pts[<span class="number">2</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">1</span>][<span class="number">0</span>]-pts[<span class="number">0</span>][<span class="number">0</span>], pts[<span class="number">0</span>][<span class="number">0</span>]-P[<span class="number">0</span>])^<span class="built_in">Vec3f</span>(pts[<span class="number">2</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">1</span>][<span class="number">1</span>]-pts[<span class="number">0</span>][<span class="number">1</span>], pts[<span class="number">0</span>][<span class="number">1</span>]-P[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">abs</span>(u.z)&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-2-包围盒判断"><a href="#3-2-包围盒判断" class="headerlink" title="3.2 包围盒判断"></a>3.2 包围盒判断</h1><ul><li>先前我们曾在光栅化中介绍了包围盒判断法，现在我们来看它的实现。</li><li>首先，包围盒需要我们确定这个图元的边界，而事先，我们需要设定这个边界值。最大值我们设定为画布大小-1，最小值我们设定为（0,0）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TriangleWithBox</span><span class="params">(Vec2i pts* , TGAImage image,TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Vec2i <span class="title">bboxmin</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Vec2i   <span class="title">bboxmax</span><span class="params">(image.get_width()<span class="number">-1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">image.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>随后，我们需要限定包围盒的最大范围为画布的最大范围。然后，根据传入的顶点值，来更新包围盒的范围。</li><li>包围盒的最小范围我们取的是传入顶点与包围盒最大范围的最小值，并将其更新到包围盒的坐标中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="function">Veci <span class="title">clamp</span><span class="params">(image.get_width()<span class="number">-1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">image.get_height()<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">bboxmin.x = std::<span class="built_in">max</span>(<span class="number">0</span>,std::<span class="built_in">max</span>(bboxmin.x,pts[i].x));</span><br><span class="line">bboxmin.y = </span><br><span class="line">std::<span class="built_in">max</span>(<span class="number">0</span>,std::<span class="built_in">max</span>(bboxmin.y,pts[i].y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>包围盒的最大范围设置也是如此，我们取包围盒现有得最小值与顶点值的最大值。同时不超过画布范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">bboxmax.x = </span><br><span class="line">std::<span class="built_in">min</span>(clamp,std::<span class="built_in">min</span>(bboxmax.x,pts[i].x));</span><br><span class="line">bboxmax.y = </span><br><span class="line">std::<span class="built_in">min</span>(clamp,std::<span class="built_in">min</span>(bboxmax.y,pts[i].y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>随后，我们创建一个点P，遍历在包围盒内的P点，并判断其是否在三角形内，如果其任意值不小于0，则证明其在三角形内，便设置这个点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vec2i P;</span><br><span class="line"><span class="keyword">for</span>(P.x = bboxmin.x;P.x &lt;= bboxmax.x;P.x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(P.y = bboxmin.y;P.y&lt;=bboxmax,y;P.y++)</span><br><span class="line">&#123;</span><br><span class="line"> Vec3f bc_screen  = <span class="built_in">barycentric</span>(pts, P); </span><br><span class="line"> <span class="keyword">if</span>(bc_screen.x&lt;<span class="number">0</span> || bc_screen.y&lt;<span class="number">0</span> || bc_screen.z&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        image.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，我们便完成了最基本的包围盒检测与设置，后续我们会改进算法，让它们更规范。</li></ul><hr><ul><li>接下来我们来看一个叫做深度缓冲的东西，这个技术在我们的渲染器中的应用就是用来防止被遮挡的面渲染到其他面前面。</li><li>深度缓冲有一些基本的特性，之前在理论部分我们了解到了，深度缓冲存储着该像素点的最小深度，并实时更新。在实际实现部分，深度缓冲是窗口自动创建的，会以16,24,32 位浮点形式存储深度值。</li><li>在后续我们还会优化深度缓冲的算法，目前它只作为判断前后顺序的一个标准。</li></ul><hr><h1 id="3-3-更新深度缓冲算法"><a href="#3-3-更新深度缓冲算法" class="headerlink" title="3.3 更新深度缓冲算法"></a>3.3 更新深度缓冲算法</h1><h2 id="3-3-1-对重心坐标判断法的重构"><a href="#3-3-1-对重心坐标判断法的重构" class="headerlink" title="3.3.1 对重心坐标判断法的重构"></a>3.3.1 对重心坐标判断法的重构</h2><ul><li>首先，更新后最大的重构就是，我们需要引入深度缓冲，当然这并不困难，对于我们的玩具渲染器而言，我们实践是为了更好的理解原理，后续工业化的实践你可以借助图形API来完成，当然我们没有兴趣也没有必要自己写API。</li><li>在我们的包围盒判断函数中，我们将使用一个更为直观简便的矩阵写法，代替我们之前所写的一大长串的点积公式。</li></ul><hr><ul><li>首先，我们定义了一个Vec3f 变量的数组，在计算之前，请确保你更新了你的geometry头文件，我们将会依赖其中定义的运算符。</li><li>之后，我们使用一个for循环，计算出用来判断的三个向量值，并填充这个空的矩阵。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec3f s[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i--; ) &#123;</span><br><span class="line">    s[i][<span class="number">0</span>] = C[i] - A[i];</span><br><span class="line">    s[i][<span class="number">1</span>] = B[i] - A[i];</span><br><span class="line">    s[i][<span class="number">2</span>] = A[i] - P[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就像上面这样。</li></ul><hr><ul><li>随后，就到了我们最重要的求重心坐标的阶段了，首先我们计算了叉积得到了该平面的法向量，其中z分量代表了面向观察者的三角形面积，如果这个值非常小，说明该三角形是退化的（三点共线），也就是说可以忽略，所以我们就返回一个无效值即可。如果通过，则计算P的重心坐标</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec3f u = <span class="built_in">cross</span>(s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">abs</span>(u[<span class="number">2</span>]) &gt; <span class="number">1e-2</span>) <span class="comment">// dont forget that u[2] is integer. If it is zero then triangle ABC is degenerate</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">1.f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// in this case generate negative coordinates, it will be thrown away by the rasterizator</span></span><br></pre></td></tr></table></figure><hr><ul><li>这样，我们就更新了我们的判断函数，接下来，我们利用这个新的判断函数作为检测依据，与包围盒算法一起更新，最后加入深度缓冲判断。</li></ul><hr><h2 id="3-3-2-对于包围盒三角形绘制法的重构"><a href="#3-3-2-对于包围盒三角形绘制法的重构" class="headerlink" title="3.3.2 对于包围盒三角形绘制法的重构"></a>3.3.2 对于包围盒三角形绘制法的重构</h2><ul><li>接下来，让我们关注三角形，先前我们使用了包围盒作为三角形绘制的方法，效果不错，现在我们需要在其中加入深度缓冲作为优化方法，其实这并不困难，我们只需要写入对应的深度值就好了。利用我们已经做好的算法，只需要改进一下就好了。</li><li>首先，让我们先关注对包围盒的优化~</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2f <span class="title">bboxmin</span><span class="params">(std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br><span class="line"><span class="function">Vec2f <span class="title">bboxmax</span><span class="params">(-std::numeric_limits&lt;<span class="type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="type">float</span>&gt;::max())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>首先，我们先将包围盒扩展为c++能够得到的上下限，这个做法是为了后续我们进行大规模渲染做准备，我们需要足够的空间。</li></ul><hr><ul><li>接着，我们需要限定画布的范围，我们只希望渲染画布上的内容，因此依然限定为画布大小。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2f <span class="title">clamp</span><span class="params">(image.get_width() - <span class="number">1</span>, image.get_height() - <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>随后，我们利用嵌套循环，实现了对包围盒的更新。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        bboxmin[j] = std::<span class="built_in">max</span>(<span class="number">0.f</span>, std::<span class="built_in">min</span>(bboxmin[j], pts[i][j]));</span><br><span class="line">        bboxmax[j] = std::<span class="built_in">min</span>(clamp[j], std::<span class="built_in">max</span>(bboxmax[j], pts[i][j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接着，我们利用包围盒算法进行绘制，首先我们判断屏幕上任意一点是否在对应的三角形内，并利用我们之前完成的中心坐标算法进行计算。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec3f P;</span><br><span class="line"><span class="keyword">for</span> (P.x = bboxmin.x; P.x &lt;= bboxmax.x; P.x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (P.y = bboxmin.y; P.y &lt;= bboxmax.y; P.y++) &#123;</span><br><span class="line">        Vec3f bc_screen = <span class="built_in">barycentric</span>(pts[<span class="number">0</span>], pts[<span class="number">1</span>], pts[<span class="number">2</span>], P);</span><br></pre></td></tr></table></figure><ul><li>如果任意一个值小于0则直接跳过，说明不在该点内，接着我们先初始化P的z值为0，这与一般的方法不一样，不过无伤大雅，因为我们想做的只是逐层绘制而已。</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bc_screen.x &lt; <span class="number">0</span> || bc_screen.y &lt; <span class="number">0</span> || bc_screen.z &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">P.z = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>接着，就到了最重量级的环节，我们需要获得这个三角形所在像素的深度值，通过对应顶点的z值与对应权重相乘来得到P的近似权重值，以此更新深度缓冲值。</li><li>接着，我们对于深度缓冲的每一个像素进行判断，如果P点的深度值比它大，就将其更新为P的权重值，并设置该点颜色。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zbuffer[<span class="built_in">int</span>(P.x + P.y * width)] &lt; P.z) &#123;</span><br><span class="line">    zbuffer[<span class="built_in">int</span>(P.x + P.y * width)] = P.z;</span><br><span class="line">    image.<span class="built_in">set</span>(P.x, P.y, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>大功告成，不过现在，我们还需要更新一下屏幕呈现的算法，因为我们需要将世界坐标变化为屏幕坐标，希望你还记得这一步视口变换~。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec3f <span class="title">world2screen</span><span class="params">(Vec3f v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vec3f</span>(<span class="built_in">int</span>((v.x + <span class="number">1.</span>) * width / <span class="number">2.</span> + <span class="number">.5</span>), <span class="built_in">int</span>((v.y + <span class="number">1.</span>) * height / <span class="number">2.</span> + <span class="number">.5</span>), v.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随后我们将创建一个深度缓冲数组，并将窗口大小传给它，随后我们将其初始化为c++数值上限，代表无限远。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* zbuffer = <span class="keyword">new</span> <span class="type">float</span>[width * height];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = width * height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>());</span><br></pre></td></tr></table></figure><ul><li>接着就是一如既往的操作，我们从模型中取出顶点，通过变换将其变换为视口坐标，然后绘制它。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TGAImage <span class="title">image</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">    Vec3f pts[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) pts[i] = <span class="built_in">world2screen</span>(model-&gt;<span class="built_in">vert</span>(face[i]));</span><br><span class="line">    <span class="built_in">triangle</span>(pts, zbuffer, image, <span class="built_in">TGAColor</span>(<span class="built_in">rand</span>() % <span class="number">255</span>, <span class="built_in">rand</span>() % <span class="number">255</span>, <span class="built_in">rand</span>() % <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>这样我们就得到了最终渲染的新苹果。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241210111025.png" alt="image.png"><br>  <code>3.3.2 深度缓冲更新后前后遮挡关系正确的苹果</code></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南</li><li><a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a></li><li>我的项目地址：</li><li><a href="https://github.com/Pleasant233/EasyRender">https://github.com/Pleasant233/EasyRender</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EasyShader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学9——着色1</title>
      <link href="/2025/01/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A69%E2%80%94%E2%80%94%E7%9D%80%E8%89%B21/"/>
      <url>/2025/01/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A69%E2%80%94%E2%80%94%E7%9D%80%E8%89%B21/</url>
      
        <content type="html"><![CDATA[<h1 id="9-1-深度缓冲与可见性（Z-BUFFER）"><a href="#9-1-深度缓冲与可见性（Z-BUFFER）" class="headerlink" title="9.1 深度缓冲与可见性（Z-BUFFER）"></a>9.1 深度缓冲与可见性（Z-BUFFER）</h1><h2 id="9-1-1-画家算法"><a href="#9-1-1-画家算法" class="headerlink" title="9.1.1 画家算法"></a>9.1.1 画家算法</h2><ul><li>我们如何去描述一个场景，或者说场景式如何逐步的画出来的，这本质上涉及的算法就是我们所说的画家算法</li><li>画家算法是按照从远到近的顺序绘制图形的，实际上渲染管线本身的思路也是源自于这个过程。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/9.1.1%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="9.1.1画家算法实例.png"><br>      <code>9.1.1  画家算法实例</code></li><li>可以看到图中的绘制顺序分别是远处的天空，山脉，树林，最后是湖泊。但这样的算法依然存在问题，如果图像相互遮挡，就无法确定谁先谁后，这是就需要介绍一个重要的技术，深度缓冲。</li></ul><hr><h2 id="9-1-2-深度缓冲"><a href="#9-1-2-深度缓冲" class="headerlink" title="9.1.2 深度缓冲"></a>9.1.2 深度缓冲</h2><ul><li>深度缓冲顾名思义，是对于<strong>深度的一次缓冲</strong>，为何要缓冲深度？这是因为我们现在要转换我们的思维方式。</li><li>先前我们提到的画家算法，实际上是在考虑<strong>物体直接映射到屏幕上</strong>，但根据先前我们学习的<strong>光栅化知识</strong>，我们应该发现其中漏掉了很重要的一点，那就是<strong>物体离散化到像素</strong>的过程。而如果从像素角度来思考，则可以很方便的理解深度缓冲的含义。</li></ul><hr><ul><li>对于每个像素我们最后只需要将<strong>没有遮挡的对象填入其颜色值</strong>即可，所以说我们会一次又一次将不同的物体对象（也就是<strong>三角形片元</strong>）投射在像素上，就像我们之前做的那样，而此时我们同时记录每一个<strong>片元所对应像素的深度</strong>，如果深度比之前更小我们就覆盖这个像素，让这个物体的片元显示出来。</li></ul><hr><ul><li>我们在渲染最后结果的frame时，同时也会渲染深度图，就像下面这样</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241111093334.png" alt="image.png"><br>      <code>9.1.2 Unity中的深度图</code></li></ul><hr><ul><li>其中远处为无限深度，也就是黑色，而近处逐渐深度减小，所以为偏白色的灰色，并且越近越偏向白色。</li><li>我们可以通过一个简单的网格图进一步加深我们对这个过程的理解。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240529084406.png" alt="Pasted image 20240529084406.png"><br>  <code>9.1.2.1 深度缓存步骤1</code></li><li>一开始像素深度都是无限远的，开始绘制第一个三角形，它的深度值都是5，通过原理比对，绘制在无限远(R)前。</li></ul><hr><ul><li>然后我们开始绘制第二个三角形，它的每个像素深度都是不一样的，通过我们已经得出的算法，我们同样可以把它绘制到屏幕上，深度小的永远在前面，每个像素都会被绘制，并更新</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240529084540.png" alt="Pasted image 20240529084540.png"><br>  <code>9.1.2.2 深度缓存步骤2</code></li></ul><hr><ul><li>以上提到的深度缓冲算法，我们可以来看一个伪代码实现，这种算法的时间复杂度是O（n），因为我们本身只关注n个像素的深度值，而并不是在给片元们排序，所以消耗的线性时间。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240529084206.png" alt="Pasted image 20240529084206.png"><br>  <code>9.1.2.3 深度缓冲伪代码</code></li></ul><hr><h1 id="9-2-着色初步"><a href="#9-2-着色初步" class="headerlink" title="9.2 着色初步"></a>9.2 着色初步</h1><h2 id="9-2-1-着色的定义"><a href="#9-2-1-着色的定义" class="headerlink" title="9.2.1 着色的定义"></a>9.2.1 着色的定义</h2><ul><li>什么是着色？着色顾名思义，就是将颜色附着在物体表面的过程。也就是不同的材质，同一个模型拥有了不一样的材质，外表就会发生不一样的变换。</li><li>着色最基本的内容：添加明暗变化，添加颜色变化。比如下面这个材质球就是所谓的着色，它将原本的材质变化了属性，赋予了明暗和颜色变化。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/9.2.1%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9D%90%E8%B4%A8%E8%B5%8B%E4%BA%88%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9D%80%E8%89%B2%E6%95%88%E6%9E%9C.png" alt="9.2.1不同的材质赋予不同的着色效果.png"><br>  <code>9.2.1 不同的材质赋予不同的着色效果</code></li></ul><hr><h2 id="9-2-2-Bullin-Phong-布林冯-模型"><a href="#9-2-2-Bullin-Phong-布林冯-模型" class="headerlink" title="9.2.2 Bullin-Phong(布林冯)模型"></a>9.2.2 Bullin-Phong(布林冯)模型</h2><ul><li>以上描述的着色模型有很多，其中一种最为基础而经典的就是布林冯模型，这个着色模型定义了三个最基本的着色组成部分，分别是<ul><li>漫反射项（diffuse）</li><li>高光项（Specular）</li><li>环境光项（Ambient）</li></ul></li><li>这三个部分共同组成了一个最基本的材质，我们可以用它来模拟一些简单的光照场景。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241112101541.png" alt="image.png"><br>                  <code>9.2.2 Unity布林冯着色模型</code></li></ul><hr><h2 id="9-2-5-着色基础"><a href="#9-2-5-着色基础" class="headerlink" title="9.2.5 着色基础"></a>9.2.5 着色基础</h2><ul><li>实际上我们看到的着色模型，它们都是计算得来的（当然这是一句废话）。你肯定想问，计算什么呢？</li><li>着色模型计算的基本变量：<ul><li>视角方向（ViewDir）</li><li>光线方向（LightDir）</li><li>法线方向（Normal）</li></ul></li><li>并且它们都是单位向量（希望你还知道这代表什么意思），也就是说只考虑方向，因为我们只需要利用它们描述每一个点的接受光的多少，呈现出什么颜色而已。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240529091012.png" alt="Pasted image 20240529091012.png"><br>  <code>9.2.5 着色计算的基本条件</code></li></ul><hr><ul><li>相信细心的同学已经发现了，我们的向量是由点指向光源和摄像机的，这与我们着色的基本概念有关，我们只考虑每个点接受光的多少，而不考虑阴影（暂时的）因此我们定义LightDir作为点指向光源的向量，这个向量对于每个点都是不一样的：<ul><li>*L &#x3D; Q - P</li></ul></li><li>当然这是建立在光源是点光的基础上，我们才能这么表达这个向量，如果是方向光呢？最经典的例子就是太阳。太阳离我们很远，因此它发射的光线近乎可以看做是平行光，因此此时对于整个场景。它们的L都是一样的<ul><li>L’ &#x3D; L</li></ul></li></ul><hr><h2 id="9-2-4-漫反射项"><a href="#9-2-4-漫反射项" class="headerlink" title="9.2.4 漫反射项"></a>9.2.4 漫反射项</h2><ul><li>接下来我们来逐一了解这三个部分，首先先来看看漫反射项（diffuse）</li><li>漫反射在生活中随处可见，比如大家现在立刻看看自己的手臂，自己的衣服，是不是你能看到他们！（好奇怪的发言）但这本身说明他们在反射光线，而且是均匀地反射，这其实就是漫反射的定义。</li><li>这些物体也叫做哑光物体。</li><li>接下来我们考虑反射的多少，这取决于它接受的多少，能量守恒定律是普遍存在的客观规律。而如果我们要描述这种规律就需要聚焦于一个单位范围，因为我们要保持其他变量不会影响我们的理解。</li></ul><hr><ul><li>单位区域内，所接受到的光，决定了漫反射的强弱，而如果我们想去描述它，就需要借助法线和光线了。</li><li>来想一下这个问题，什么时候光线最多？当然是全部射到上面的时候，这时候法线方向与入射光方向平行，我们借助三角函数描述，那就是</li><li>cosa &#x3D; N · L &#x2F; |N| |L| </li><li>（当然如果是单位向量也可以省略分母，希望你还记得我们用点积描述角度大小）</li><li>很明显，当N与L共线时，cosa &#x3D; 1，此时为最大值。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241112105242.png" alt="image.png"><br>  <code>9.2.4 漫反射强度与法线和入射光的夹角大小有关</code></li></ul><hr><ul><li>除去接受部分，我们还需要关注传播部分，之前说过，光线在传递过程中也会衰减，这个频率我们描述为</li><li>I’ &#x3D; I &#x2F; R（半径）^2 </li><li>这个同样容易理解，我们可以想象点光源发射的光是球形的，这个球在传播的过程中r在变大，意味着其表面积在变大，球体表面积公式</li><li>S &#x3D; 4πR^2</li><li>因此单位面积上的I就变为 I &#x2F; 4πr^2,且由于我们求得是比例关系，可以忽略常数，由此可得到变化规律。</li></ul><hr><ul><li>最后，我们就可以描述漫反射了，它就是由发射部分和接受部分定义的，最后利用max操作取最大值的目的是规范一个取值范围，毕竟一个小于0的贡献值对于计算光线没用，它不可能从表面吸取光线吧？！所以我们限定其最小为0（黑色）</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241112110414.png" alt="image.png"><br>  <code>9.2.4.1 漫反射方程</code></li></ul><hr><ul><li>kd部分被称作漫反射系数，这个部分其实很好理解，毕竟不同材质漫反射也有强弱，这个值只是在控制宏观的反射关系的多少而已，越大反射整体越强烈</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240529092510.png" alt="Pasted image 20240529092510.png"><br>  <code>9.2.4.2 不同kd值（左&lt;右）球体的不同亮度表现</code></li></ul><hr><ul><li>这很直观，到此你已经可以让物体具有基本的亮暗面关系了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113100926.png" alt="image.png"><br>  <code>9.2.4.3 Unity中的BlinnPhong漫反射项</code></li></ul><hr><h2 id="9-2-5-高光项（Specular）"><a href="#9-2-5-高光项（Specular）" class="headerlink" title="9.2.5 高光项（Specular）"></a>9.2.5 高光项（Specular）</h2><ul><li>高光项也叫做镜面反射，这个词（Specular）来自于拉丁文，意思是“镜子”，那么我们来思考一下镜子有什么特点？</li><li>镜子的反射与漫反射相比是集中地，也就是说反射光线会在某个区间内集中。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Drawing%202024-03-04%2021.29.06.excalidraw.png" alt="Drawing 2024-03-04 21.29.06.excalidraw.png"><br>              <code>9.2.5 镜面反射入射与反射关系</code></li></ul><hr><ul><li>入射线L指向的是光源所在位置，如果镜面的光泽度（s）变化，会使得反射光线不只为一条，而是多条，越靠近R越为集中。因为表面不平整因此会有光线从其他角度散射，但大多数光线都是聚集在R附近的。<strong>越靠近R光线越多</strong>，因此光泽度决定了反射光线的衰减程度，接下来我们来探讨有多少光进入了我们的视野。</li></ul><hr><ul><li>我们想知道有多少光线进入了我们的摄像机，本质上，就是视线向量V与反射射线R之间的夹角，当全部光线进入摄像机中时，a&#x3D;0°，同样的，a&#x3D;90°的时候，就没有光线进入了。 </li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240520215756.png" alt="Pasted image 20240520215756.png"><br>          <code>9.2.5.1 反射的强烈与反射光线和视线角度有关</code></li></ul><hr><ul><li>我们对这个光照模型的值进行进一步的分析，a是V和R的夹角，而R则是通过V和N得到的。我们可以将L拆解为Lp和Ln这两个方向向量，他们分别垂直和平行于N，之后我们就可以对Ln进行表示，他就是N(N* L)，括号里是他的长度，外面是他的方向与N平行。由于L &#x3D; Lp+Ln，所以Lp &#x3D; L - N(N* L)。而R是由-Lp和LN组成的，因此我们只需要略微变化，就可以得出我们所需要的，R的表达式：<ul><li>R &#x3D; 2N(N* L) - L</li></ul></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113093922.png" alt="image.png"><br>      <code>9.2.5.1 计算反射光线</code></li></ul><hr><h2 id="9-2-6-布林冯模型中的反射计算"><a href="#9-2-6-布林冯模型中的反射计算" class="headerlink" title="9.2.6 布林冯模型中的反射计算"></a>9.2.6 布林冯模型中的反射计算</h2><ul><li>经过上面一系列的推导，你是不是觉得头晕眼花了？（反正我是不想看），那么有没有一种可以简单计算反射光线多少的方法呢？答案当然是有的！</li><li>现在我们变换一下思路，回到问题的本源，我们所要知道的其实就是真正射到摄像机里的光线有多少，或者说我们其实是在模拟而不是仿真，因此我们只需要通过表达有多少光线射出的状态而不是真的去计算每一根光线（当然在后续的光线追踪系列中我们必须考虑）</li></ul><hr><ul><li>所以布林冯为我们提出了一种取巧的方式，通过计算<strong>半程向量</strong>与法线夹角的关系，来近似的描述有多少光线反射了出去</li><li>什么是半程向量，其实就是入射光线和摄像机光线的角平分线上的向量，它的计算非常简单</li><li>H &#x3D; V + L &#x2F; |V + L|</li><li>而通过它我们就能很方便的描述有多少光线反射了出去，因为它的变化趋势与光线和摄像机视线变化趋势相同。</li><li>至此，我们只需要依据之前推导漫反射部分的思路，推算出高光反射的表达式即可。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113094743.png" alt="image.png"><br>  <code>布林冯的高光反射模型</code></li></ul><hr><ul><li>你发现了什么？好像有些不对劲？为什么会存在一个指数项呢？出错了吗？当然不是！</li><li>这个指数项被称为<strong>镜面反射指数</strong>，用来描述不同材质镜面反射高光的变化趋势，实际上，在材质制作与特效制作的过程中，我们经常会用到指数幂去控制变化范围，因为在数学上，它可以使得小于1的数值更小，大于1的数值更大，会增加函数的变化趋势</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240520220101.png" alt="Pasted image 20240520220101.png"><br>  <code>9.2.6 镜面反射指数</code></li></ul><hr><ul><li>现在我们已经可以描述高光项了，让我们将它加到模型上，我们可以通过调节指数来控制高光的衰减范围。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113101146.png" alt="image.png"><br>  &#96;9.2.6.1 UnityUnity中的BlinnPhong漫反射项+ 高光项</li></ul><hr><h2 id="9-2-7-环境光（Ambient）"><a href="#9-2-7-环境光（Ambient）" class="headerlink" title="9.2.7 环境光（Ambient）"></a>9.2.7 环境光（Ambient）</h2><ul><li>恭喜你，到现在已经可以描述布林冯模型里的漫反射项和高光项了，我们还剩最后一项，那就是环境光。</li><li>环境光是来源于整个环境的所有光线的总和，计算其本身相对复杂，在Unity中会存在一个宏变量，供我们直接调用环境光照，同时在Lighting中你也可以设置环境光颜色等，Ue中的天空光照同样是模拟这个过程。全局光照系统是更进一步的高级环境光，这个之后会进行讨论，我们先假设已知了环境光</li><li>La &#x3D; KaIa</li><li>其中Ka 是环境光系数，Ia 是环境光强度。</li></ul><hr><h2 id="9-2-8-布林冯模型总览"><a href="#9-2-8-布林冯模型总览" class="headerlink" title="9.2.8 布林冯模型总览"></a>9.2.8 布林冯模型总览</h2><ul><li>到现在，我们将这三项逐一加和，所得到的就是我们所想要的布林冯模型了！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113095927.png" alt="image.png"><br>  <code>9.2.8 布林冯模型全貌</code></li><li>现在，不管什么样的物体我们都可以对其进行基本的着色了，当然这任重而道远，不过我们已经掌握了第一步，后面的路也就铺开了，你还可以自行了解诸如兰伯特模型，半兰伯特模型等等经典的光栅化模型。下一节我们将继续深入着色系统并重谈渲染管线，相信你一定对之前所说的业界定制的管线有更深刻的理解！</li></ul><hr><ul><li>让我们一起看看最后得到的图像</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113101351.png" alt="image.png"><br>  <code>9.2.8.1 布林冯光照模型</code></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>UnityShader入门精要 冯乐乐著</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>计算机图形学入门——3D渲染指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EasyShader——线框与三角形</title>
      <link href="/2025/01/15/EasyShader2%E2%80%94%E2%80%94%E7%BA%BF%E6%A1%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2025/01/15/EasyShader2%E2%80%94%E2%80%94%E7%BA%BF%E6%A1%86%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>本节分享需要一个obj格式的模型文件，我的库里提供了这个文件，当然，如果你具备建模能力也可以自己建一个模型使用，重要的是思路，不是素材！当然素材一样会提供，并且这节分享需要更多的资源我们一一来看。</li></ul><hr><ul><li>model.h<ul><li>这个头文件是用来导入模型的，它能够导入后缀为obj的模型类型。</li></ul></li><li>Vector<ul><li>这是c++为我们提供的库文件，它叫做容器，内部维护着一个动态数组，我们通过它来讲模型数据导入并输出成为像素点。</li></ul></li></ul><hr><h2 id="2-1-重构mainc-cpp"><a href="#2-1-重构mainc-cpp" class="headerlink" title="2.1 重构mainc.cpp"></a>2.1 重构mainc.cpp</h2><h2 id="2-1-1-头文件项更改"><a href="#2-1-1-头文件项更改" class="headerlink" title="2.1.1 头文件项更改"></a>2.1.1 头文件项更改</h2><ul><li>首先我们必须加入以上提到的头文件，依次获取其中的变量与方法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tgaimage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;model.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;geometry.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="2-1-2-全局变量与main函数修改"><a href="#2-1-2-全局变量与main函数修改" class="headerlink" title="2.1.2 全局变量与main函数修改"></a>2.1.2 全局变量与main函数修改</h2><ul><li>我们需要创建一个Model * 类型的变量，它本身是个Model类型的指针，对应着一片Model长度的内存地址，我们用其来存储我们读取到的模型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model *model = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li>我们现将其设置为空，请注意，在此提醒一个编程小技巧，我们能够申请到的空间叫做堆，我们需要谨慎小心地操作内存空间，所以一定要对每一个声明的指针变量对应一个确定的内存区域，NULL区域在不同的系统中对应空间不一样，但是它是安全的，所以我们一开始将其赋于我们的模型变量，让它安全的申请下来。</li></ul><hr><ul><li>接下来是main函数部分</li><li>首先我们需要让main函数具有两个参数，你可能觉得这不符合你的习惯，确实，我们一般不在main函数中声明参数，但main函数实际上是程序运行的入口函数，它是被系统调用的函数之一，因此我们一样完全可以为其添加参数</li></ul><hr><ul><li>这两个参数是为了防止读取模型失败导致内存泄漏而存在的，如果模型正常加载则写入我们存放在对应路径下的文件（注意是相对路径），否则交给model内的方法处理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span>==argc) &#123;</span><br><span class="line">        model = <span class="keyword">new</span> <span class="built_in">Model</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model = <span class="keyword">new</span> <span class="built_in">Model</span>(<span class="string">&quot;obj/.obj&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>接下来，我们需要对.obj文件进行读取，如果你打开.obj文件，其实可以发现，它就是一大堆的点坐标，我们需要的就是依次读入点坐标所形成的面，并调用我们之前的line算法，将其连接并画在画布上。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;model-&gt;<span class="built_in">nfaces</span>(); i++) &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; face = model-&gt;<span class="built_in">face</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            Vec3f v0 = model-&gt;<span class="built_in">vert</span>(face[j]);</span><br><span class="line">            Vec3f v1 = model-&gt;<span class="built_in">vert</span>(face[(j<span class="number">+1</span>)%<span class="number">3</span>]);</span><br><span class="line">            <span class="type">int</span> x0 = (v<span class="number">0.</span>x<span class="number">+1.</span>)*width/<span class="number">2.</span>;</span><br><span class="line">            <span class="type">int</span> y0 = (v<span class="number">0.</span>y<span class="number">+1.</span>)*height/<span class="number">2.</span>;</span><br><span class="line">            <span class="type">int</span> x1 = (v<span class="number">1.</span>x<span class="number">+1.</span>)*width/<span class="number">2.</span>;</span><br><span class="line">            <span class="type">int</span> y1 = (v<span class="number">1.</span>y<span class="number">+1.</span>)*height/<span class="number">2.</span>;</span><br><span class="line">            <span class="built_in">line</span>(x0, y0, x1, y1, image, white);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>我们遍历模型中所有的面，并将其全部装到一个int类型的数组中，而后我们以3为一个单位，去遍历这个数组，并将其中的点取出作为v0和v1，而后我们将这些点缩放到屏幕空间（希望你还记得这个概念），最后调用绘制算法，将图像用白色绘制到画布上！</li><li>不过在这里你得到的可能是反着的，这和坐标系不同有关（希望你同样记得这个概念），接下来我们利用TGAIMAGE内置的方法，将这个图像统统翻转！然后绘制就好了，但最后别忘记释放你申请的内存！这跟申请一样同样需要你小心翼翼！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image.<span class="built_in">flip_vertically</span>(); </span><br><span class="line">   image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;output.tga&quot;</span>);</span><br><span class="line">   <span class="keyword">delete</span> model;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="2-1-3-物体线框渲染"><a href="#2-1-3-物体线框渲染" class="headerlink" title="2.1.3 物体线框渲染"></a>2.1.3 物体线框渲染</h2><ul><li>现在，你就可以得到你的大苹果了！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113112119.png" alt="image.png"><br>  <code>2.1.2 线框大苹果</code></li><li>很有成就感是不是？但这远远没有结束，我们将做的更酷！最后我们完成时，这将是个有材质的苹果。</li></ul><hr><h2 id="2-2-三角形"><a href="#2-2-三角形" class="headerlink" title="2.2 三角形"></a>2.2 三角形</h2><h2 id="2-2-1-三角形线框绘制"><a href="#2-2-1-三角形线框绘制" class="headerlink" title="2.2.1 三角形线框绘制"></a>2.2.1 三角形线框绘制</h2><ul><li>首先，三角形是由基本的三个点组成的，因此我们如果要定义一个绘制三角形点的函数，这并不困难，我们只需要让其包含三个最基本的点坐标，并用合适的颜色绘制它就好了，这和我们绘制苹果线框的逻辑是一样的，所以在这里我们可以利用line方法写出一个初步的方案</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">line</span>(t0, t1, image, color); </span><br><span class="line">    <span class="built_in">line</span>(t1, t2, image, color); </span><br><span class="line">    <span class="built_in">line</span>(t2, t0, image, color); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>让我们测试一下这个函数，我们绘制三个三角形</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec2i t0[<span class="number">3</span>] = &#123;<span class="built_in">Vec2i</span>(<span class="number">0</span>, <span class="number">70</span>),   <span class="built_in">Vec2i</span>(<span class="number">10</span>, <span class="number">160</span>),  <span class="built_in">Vec2i</span>(<span class="number">10</span>, <span class="number">80</span>)&#125;; </span><br><span class="line">Vec2i t1[<span class="number">3</span>] = &#123;<span class="built_in">Vec2i</span>(<span class="number">120</span>, <span class="number">50</span>),  <span class="built_in">Vec2i</span>(<span class="number">160</span>, <span class="number">1</span>),   <span class="built_in">Vec2i</span>(<span class="number">70</span>, <span class="number">180</span>)&#125;; </span><br><span class="line">Vec2i t2[<span class="number">3</span>] = &#123;<span class="built_in">Vec2i</span>(<span class="number">184</span>, <span class="number">150</span>), <span class="built_in">Vec2i</span>(<span class="number">122</span>, <span class="number">160</span>), <span class="built_in">Vec2i</span>(<span class="number">130</span>, <span class="number">120</span>)&#125;; </span><br><span class="line"><span class="built_in">triangle</span>(t0[<span class="number">0</span>], t0[<span class="number">1</span>], t0[<span class="number">2</span>], image, red); </span><br><span class="line"><span class="built_in">triangle</span>(t1[<span class="number">0</span>], t1[<span class="number">1</span>], t1[<span class="number">2</span>], image, white); </span><br><span class="line"><span class="built_in">triangle</span>(t2[<span class="number">0</span>], t2[<span class="number">1</span>], t2[<span class="number">2</span>], image, green);</span><br></pre></td></tr></table></figure><hr><ul><li>最后你应该会得到这张图像</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241113120108.png" alt="image.png"><br>  <code>2.2.1 简单的三角形线框 </code></li></ul><hr><h2 id="2-2-2-三角形填充原理"><a href="#2-2-2-三角形填充原理" class="headerlink" title="2.2.2 三角形填充原理"></a>2.2.2 三角形填充原理</h2><ul><li>实际上，这个问题的解决方法有很多，我们可以尝试很多不同的方法，在此我们先根据最简单的思路，那就是扫描线绘制，我们可以一条一条的填充我们的三角形，这条线的y值是固定的，x值由左端到右端变化，我们只需要依次调用我们之前写好了的DrawLine方法，绘制就可以了，伪代码如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each horizontal line y between the triangle‘s top and Bottom</span><br><span class="line">comput x_left and x_right for this y</span><br><span class="line">drawline(x_left,y,x_right,y)</span><br></pre></td></tr></table></figure><hr><ul><li>接着，我们可以将y值进行排序，选出三个点之中的最小值和最大值，并将其分别命名为y0，y2，所以y的取值就是在y0——y2区间内。</li><li>随后我们关注我们的x_left与x_right，我们希望他们包含整个三角形的全部取值范围，因此我们需要关注不同形态的三角形，并计算其边的x值。</li></ul><hr><ul><li>对于三角形我们可以通过y值分出长边和短边，在这里我们统一定义P0——P2为高边。x_right的值要么来自高边，要么来自短边</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241118094225.png" alt="image.png"><br>  <code>2.2.2 分离三角形的高边与短边</code></li></ul><hr><ul><li>因此我们可以使用插值计算这些边中y值对应的x值，其实就是之前我们绘制直线方法的变体。我们将这些数据记录在三个数组之中，并且合并x01 和 x12 数组为x012 也就是整个三角形的x变量数组。</li><li>随后我们就可以判断谁是x_left中的数谁是x_right中的数了，只需要选择任何一条水平线，比较其在x02与x012中的值，如果x02 小于x012，那么就说明x02中的值为x_left否则为x_right。至此我们完成了绘制方法，接着调用DrawLine方法绘制即可。</li><li>接下来我们来看代码实现</li></ul><hr><h2 id="2-3-代码实践"><a href="#2-3-代码实践" class="headerlink" title="2.3 代码实践"></a>2.3 代码实践</h2><h2 id="2-3-1-三角形长短边分类"><a href="#2-3-1-三角形长短边分类" class="headerlink" title="2.3.1 三角形长短边分类"></a>2.3.1 三角形长短边分类</h2><ul><li>首先来按我们的思路，给三角形长短边分分类吧，这在代码实现中很简单，我们只需要判断谁大谁小，然后给他们排序就好了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">triangleLine</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//在这段代码中我们主要区分长边与短边,我们需要将其按从小到大排序</span></span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">1.</span>y) std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t0, t2);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">1.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t1, t2);</span><br><span class="line"><span class="comment">//排序好了，我们将其分别绘制</span></span><br><span class="line"><span class="built_in">line</span>(t0, t1, image, green);</span><br><span class="line"><span class="built_in">line</span>(t1, t2, image, green);</span><br><span class="line"><span class="built_in">line</span>(t2, t0, image, red);</span><br><span class="line"><span class="comment">//最后我们将得到长边与短边的区分，最长的也就是y差别最大的就是长边，红色。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-3-2-上下区域分离"><a href="#2-3-2-上下区域分离" class="headerlink" title="2.3.2 上下区域分离"></a>2.3.2 上下区域分离</h2><ul><li>现在我们已经可以区分长边和短边了，下一步我们就将对三角形进行分解，因为短边始终会有两个，因此我们会将这两个边按其交点处分解，分别绘制！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApartOfTriangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">1.</span>y) std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t0, t2);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">1.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t1, t2);</span><br><span class="line"><span class="comment">//首先我们计算总高度，这也就是最长边的y值变化范围</span></span><br><span class="line"><span class="type">int</span> total_height = t<span class="number">2.</span>y - t<span class="number">0.</span>y;</span><br><span class="line"><span class="comment">//随后我们绘制其中下方的短边所形成的部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = t<span class="number">0.</span>y; y &lt;= t<span class="number">1.</span>y; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> segment_height = t<span class="number">1.</span>y - to.y + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//我们设置我们需要绘制的直线范围，这里+1是为了避免重复绘制</span></span><br><span class="line"><span class="type">float</span> alpha = (<span class="type">float</span>)(y - t<span class="number">0.</span>y) / total_height;</span><br><span class="line"><span class="type">float</span> beta = (<span class="type">float</span>)(y - t<span class="number">0.</span>y) / segment_height;</span><br><span class="line"><span class="comment">//这里是设置占比范围，通过乘上不同的占比来设置最后绘制的图像的真实距离</span></span><br><span class="line"><span class="comment">//实际上做的就是线性插值！</span></span><br><span class="line">Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">Vec2i B = t0 + (t1 - t0) * beta;</span><br><span class="line">image.<span class="built_in">set</span>(A.x, y, red);</span><br><span class="line">image.<span class="built_in">set</span>(B.x, y, green);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>现在我们已经可以描绘三角形下半部分的线框了，但这样的线性插值难免会有问题，因为步长的缘故所以会出现断线！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241119113726.png" alt="image.png"><br><code>2.3.2 断线问题</code></li><li>这个问题其实我们可以忽略，因为最后绘制时我们用对应的水平线连接这些点，间隙就会消失。</li></ul><hr><h2 id="2-3-2-填充三角形并绘制上半部分"><a href="#2-3-2-填充三角形并绘制上半部分" class="headerlink" title="2.3.2 填充三角形并绘制上半部分"></a>2.3.2 填充三角形并绘制上半部分</h2><ul><li>我们可以直接简单的使用一个for循环去绘制这些连接两段的直线，为了避免出现问题，我们在设置直线时先判断大小，若大小相反则将其翻转并绘制</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilledTriangle</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.x &lt; B.x)</span><br><span class="line">std::<span class="built_in">swap</span>(A, B);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = A.x; j &lt;= B.x; j++)<span class="comment">//通过内层嵌套的循环绘制每一层的线条</span></span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">set</span>(j, y, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = t<span class="number">1.</span>y; y &lt;= t<span class="number">2.</span>y; y++) &#123;</span><br><span class="line"><span class="type">int</span> segment_height = t<span class="number">2.</span>y - t<span class="number">1.</span>y + <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> alpha = (<span class="type">float</span>)(y - t<span class="number">0.</span>y) / total_height;</span><br><span class="line"><span class="type">float</span> beta = (<span class="type">float</span>)(y - t<span class="number">1.</span>y) / segment_height; <span class="comment">// be careful with divisions by zero </span></span><br><span class="line">Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">Vec2i B = t1 + (t2 - t1) * beta;</span><br><span class="line"><span class="keyword">if</span> (A.x &gt; B.x) std::<span class="built_in">swap</span>(A, B);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = A.x; j &lt;= B.x; j++) &#123;</span><br><span class="line">image.<span class="built_in">set</span>(j, y, color); <span class="comment">// attention, due to int casts t0.y+i != A.y </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>恭喜你，你现在已经可以绘制一个实心三角形了，但是我们可以做的更好</li></ul><hr><ul><li>首先被考虑到的就是，我们可以对代码层面进行优化，因为现在存在四个for循环，总共的时间复杂度就是2n^2，我们可以将其缩减。合并为一个for循环。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FilledTriangleLv2</span><span class="params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">1.</span>y) std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">0.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t0, t2);</span><br><span class="line"><span class="keyword">if</span> (t<span class="number">1.</span>y &gt; t<span class="number">2.</span>y) std::<span class="built_in">swap</span>(t1, t2);</span><br><span class="line"><span class="comment">//首先我们计算总高度，这也就是最长边的y值变化范围</span></span><br><span class="line"><span class="type">int</span> total_height = t<span class="number">2.</span>y - t<span class="number">0.</span>y;</span><br><span class="line"><span class="comment">//随后我们绘制其中下方的短边所形成的部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;total_height; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先我们先判断绘制的是上部分还是下部分</span></span><br><span class="line"><span class="type">bool</span> secound_half = i &gt; t<span class="number">1.</span>y - t<span class="number">0.</span>y || t<span class="number">1.</span>y == t<span class="number">0.</span>y;</span><br><span class="line"><span class="comment">//这两个条件分别对应了锐角三角形以及直角三角形的情况</span></span><br><span class="line"><span class="type">int</span> segment_height = secound_half ? t<span class="number">2.</span>y - t<span class="number">1.</span>y : t<span class="number">1.</span>y - t<span class="number">0.</span>y;</span><br><span class="line"><span class="comment">//我们根据上面的判断结果来设置我们绘制的是那一部分的高度</span></span><br><span class="line"><span class="type">float</span> alpha = (<span class="type">float</span>)i / total_height;</span><br><span class="line"><span class="type">float</span> beta = (<span class="type">float</span>)(i - (secound_half ? t<span class="number">1.</span>y - t<span class="number">0.</span>y : <span class="number">0</span>)) / segment_height;</span><br><span class="line"><span class="comment">//这部分我们通过处理绘制哪一部分来排除我们已经绘制的部分保证参数正确。</span></span><br><span class="line">Vec2i A = t0 + (t2 - t0) * alpha;</span><br><span class="line">Vec2i B = secound_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * beta;</span><br><span class="line"><span class="comment">//这里我们判断绘制的是哪个部分，要是上半部分就从t1开始</span></span><br><span class="line"><span class="keyword">if</span> (A.x &gt; B.x) std::<span class="built_in">swap</span>(A, B);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = A.x; j &lt; B.x; j++)</span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">set</span>(j, t<span class="number">0.</span>y + i, color);<span class="comment">//这里我们保证绘制是从最低点开始的。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>大功告成了！。。。吗？不知道你是否还记得。在光栅化篇我们提到过的，包围盒以及后续提到的重心坐标的概念，我们如果按现在这种扫描线的方法设置，确实很简单，但效率很低，我们希望优化我们的算法，跟上时代，接下来我们将利用包围盒以及重心坐标，重新绘制三角形！</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南</li><li><a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a></li><li>我的项目地址：</li><li><a href="https://github.com/Pleasant233/EasyRender">https://github.com/Pleasant233/EasyRender</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EasyShader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学8——光栅化2</title>
      <link href="/2025/01/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A68%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%962/"/>
      <url>/2025/01/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A68%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%962/</url>
      
        <content type="html"><![CDATA[<h1 id="8-1-采样"><a href="#8-1-采样" class="headerlink" title="8.1 采样"></a>8.1 采样</h1><h2 id="8-1-1-采样的定义"><a href="#8-1-1-采样的定义" class="headerlink" title="8.1.1 采样的定义"></a>8.1.1 采样的定义</h2><ul><li>采样是利用一些方法（函数）对一个非离散的对象进行映射，得到一组离散的值。</li><li>实际上可以理解为本身一张图片或者一个视频拍摄的客观物体是连续的，而摄像机将其捕捉下来，就是将其分为离散的对象的过程。这就是所谓采样。</li></ul><hr><ul><li>在后续学习Shader过程中，我们会遇到各种各样的贴图，而往往我们会使用tex2D函数来对其进行采样（Unity中），这个过程就是将一张贴图真正变为像素的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241105120522.png" alt="image.png"><br>      <code>8.1.1 视频实际上也是采样得到的</code></li></ul><hr><h2 id="8-1-2-采样的问题"><a href="#8-1-2-采样的问题" class="headerlink" title="8.1.2 采样的问题"></a>8.1.2 采样的问题</h2><ul><li>采样会出现一些问题，图形学中我们将其称为“Artifacts”瑕疵。例如我们上节课遗留下来的，三角形映射在画面上产生的锯齿问题就是其中一种</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241105120857.png" alt="image.png"><br>          <code>8.1.2 采样中的“瑕疵“</code></li><li>其他问题比如摩尔纹，这是一种因为像素不对齐而导致的差异，比如将一张图像的奇数行和奇数列去掉，但其依然呈现出原本的大小，此时就会产生摩尔纹。</li></ul><hr><ul><li>那么综上所述其中有什么规律呢？是什么导致了采样出现了问题呢？其中的最根本的原因就是，采样的对象变化的太快了！这如何理解？比如上面的这个图像，它本身是连续的，因此在实际的内存空间中，变化也是连续的，但如果映射到屏幕像素上，因为我们要填充像素，所以需要使用我们上节课提到的模式，这种模式实际上就是一种迟钝的反应，可能实际数值变化了好几个单位，采样值才变化一点，这就导致了根本的问题。接下来我们看如何解决。</li></ul><hr><h2 id="8-1-3-反走样基础"><a href="#8-1-3-反走样基础" class="headerlink" title="8.1.3 反走样基础"></a>8.1.3 反走样基础</h2><ul><li>如何进行反走样？</li><li>其中一种方法是，先对图像源进行模糊，然后再进行采样操作。但这个顺序不能更改。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241105121917.png" alt="image.png"><br>      <code>8.1.3 先对对象模糊再采样的方法</code></li><li>这时你一定会问，凭什么，为什么会用这种方法，而最后为啥又不能更改这个顺序呢？这就涉及到信号处理的基础问题了，我们来看。</li></ul><hr><ul><li>频域与频率</li><li>频域是描述频率变化的坐标系</li><li>我们可以通过一些数学方法（傅里叶展开）将任何一个函数通过简单的不同频率的正弦波和余弦波来表示：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528103614.png" alt="Pasted image 20240528103614.png"><br>  <code>8.1.3.1 近似表示一个函数</code></li></ul><hr><h2 id="8-1-4-走样的再定义"><a href="#8-1-4-走样的再定义" class="headerlink" title="8.1.4 走样的再定义"></a>8.1.4 走样的再定义</h2><ul><li>现在我们可以通过波来解释为何会走样了，我们采样的频率是固定的，但对于不同的波形采样的结果会产生差异，对变化越剧烈的波采样结果差异越大，就像下面这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241105132705.png" alt="image.png"><br>                      <code>8.1.4 在波形上的走样的分析</code></li></ul><hr><h2 id="8-1-5-傅里叶变换与滤波"><a href="#8-1-5-傅里叶变换与滤波" class="headerlink" title="8.1.5 傅里叶变换与滤波"></a>8.1.5 傅里叶变换与滤波</h2><ul><li>傅里叶变换看起来似乎很困难，但实际上，我们不需要知道他具体是什么样的。只用知道最后它带给我们了一个结果，我们可以通过这个结果来观察到一些内容，当然这个方式也是可以相互转换的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528104651.png" alt="Pasted image 20240528104651.png"><br>      <code>8.1.5 傅里叶变换</code></li></ul><hr><ul><li>滤波，滤波实际上就是对上面那一幅图案进行一些操作。因为实际上我们得到的是相互对应的波形图。因此如果我们对其进行一系列操作，实际上会直接反应到图片上，这就是对图像进行的处理操作。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528105134.png" alt="Pasted image 20240528105134.png"><br>      <code>8.1.5.1  高通滤波</code></li><li>上面这个图片进行的操作实际上就是过滤掉低频部分，也就是相对应的中间的部分，而剩下来的就是高频部分。</li></ul><hr><ul><li>我们可以在PS中做一些实验，看看频域与图像的关系：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241105141159.png" alt="image.png"><br>                      <code>8.1.5.2 色阶映射到频域上的体现</code></li><li>左侧这张图片就是实域，而右侧调节的对象就是频域，通过调节频域的变化与占比来调节实域的颜色。</li></ul><hr><ul><li>如果细心的同学可能会发现，得到的效果是图像的边缘。边缘和高频又何关系呢？我们可以这么理解，高频区域实际上就是图像变化幅度最大的区域，也就是边界，因此如果我们过滤掉低频区域，那么最后剩下的就是边界了。</li><li>这些操作都是涉及到图像处理方面的知识，这里只是跟大家分享概念。后续UnityShader部分会实现一个类似的效果。</li></ul><hr><h2 id="8-1-6-卷积与滤波"><a href="#8-1-6-卷积与滤波" class="headerlink" title="8.1.6 卷积与滤波"></a>8.1.6 卷积与滤波</h2><ul><li>卷积是什么，卷积实际上就是一种滤波操作，它在数学上是一种平均计算，这两者的内在机理是什么？滤波是对数值的操作，过滤掉特定数值的波，而卷积的平均同样也是对数值进行的平均</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528105806.png" alt="Pasted image 20240528105806.png"><br>          <code>8.1.6 卷积的操作</code></li><li>通过上面这张图片我们可以发现，它是上述的这些数字通过一个固定的值进行取平均的运算最后得到一个结果，这个过程就叫做卷积操作。</li><li>这些固定的数值就叫做卷积核。</li></ul><hr><ul><li>对于一个实域图像，进行卷积操作，实际上我们也可以将其转化为频域上的图形进行操作，这个操作同样成立，而这种操作则是用乘除法实现的，殊途同归。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528110301.png" alt="Pasted image 20240528110301.png"><br>      <code>8.1.6.1 实域上的卷积操作</code></li><li>所以在频域上的乘积就等于实域上的卷积。</li></ul><hr><h2 id="8-1-7-采样的重定义"><a href="#8-1-7-采样的重定义" class="headerlink" title="8.1.7 采样的重定义"></a>8.1.7 采样的重定义</h2><ul><li>一个函数进行傅里叶变换后得到的结果在频域上体现出来的就是一个峰值：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528111414.png" alt="Pasted image 20240528111414.png"><br>      <code>8.1.7 函数在频域上的体现</code></li><li>然后，我们使用名为冲击函数的函数对其进行采样，最后得到的就是一系列采样的值，因此我们可以定义采样就是重复原始数据的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528111437.png" alt="Pasted image 20240528111437.png"><br>      <code>8.1.7.1 采样的本质就是重复数据</code></li></ul><hr><ul><li>现在我们可以来定义走样了，走样就是重复的频率太慢了，冲击函数的频率慢了，因此最后得到的结果就会重复，这样就发生了走样。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528111652.png" alt="Pasted image 20240528111652.png"><br>      <code>8.1.7.2 走样的原理</code></li><li>现在我们已经得到了走样的最终定义了，那就是在重复采样数据的过程中，因为采样频率慢而导致采样结果相互干涉，导致出现走样，下面我们来重新来审视如何反走样。</li></ul><hr><h2 id="8-2-反走样"><a href="#8-2-反走样" class="headerlink" title="8.2 反走样"></a>8.2 反走样</h2><h2 id="8-2-1-反走样的方式"><a href="#8-2-1-反走样的方式" class="headerlink" title="8.2.1 反走样的方式"></a>8.2.1 反走样的方式</h2><ul><li>1.提升屏幕自身的分别率，增加采样频率，但这并不是解决方案，因为我们无法改变物理的显示状态。</li><li>2.先对原始信号进行操作，避免发生重叠。</li></ul><hr><ul><li>我们来看一下第二个方法，之前我们提到最后得到的对实域的采样得到的频域上的结果，我们可以将其高频部分去掉，这本身就是将其进行模糊，因为低通滤波本身就是模糊操作，其图像如下，我们会发现在原本的采样率下，它们不重叠了。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528111944.png" alt="Pasted image 20240528111944.png"><br>          <code>8.2.1 去除高频信号后的结果</code></li><li>现在我们可以回答原本的问题了，为什么我们要先模糊再采样，原因就是我们可以避免信号的重叠，从而避免走样。</li></ul><hr><h2 id="8-2-2-抗锯齿方式"><a href="#8-2-2-抗锯齿方式" class="headerlink" title="8.2.2 抗锯齿方式"></a>8.2.2 抗锯齿方式</h2><ul><li>MSAA<ul><li>MSAA这种方式实际上是一种取巧的方式，每一个像素中抽象出数个像素点，我们对其采样后即可得到更细致的采样结果，得到这个结果后，我们就将其进行平均，最后得到这个像素的采样值，这其实模拟了卷积的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240528112415.png" alt="Pasted image 20240528112415.png"><br>                  &#96;8.2.3 MSAA的实现示意</li></ul></li></ul><hr><ul><li>FXAA</li><li>FXAA是一种快速进行抗锯齿的操作，只需要很简单的操作就能得到结果，更注重与性能而非完美的效果。缺点是在移动时会发生闪烁。</li><li>详情请参考此文：</li><li><a href="https://zhuanlan.zhihu.com/p/431384101">https://zhuanlan.zhihu.com/p/431384101</a></li></ul><hr><ul><li>DLSS</li><li>DLSS是一种基于机器学习的AI生成算法，通过走样的画面反推丢失的细节，但需要用到一些特殊单元，目前只有有限的显卡支持。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Games101计算机图形学入门——闫令琪</li><li>计算机图形学入门——3D渲染指南</li><li>知乎专栏</li><li><a href="https://zhuanlan.zhihu.com/p/431384101">https://zhuanlan.zhihu.com/p/431384101</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EasyShader——直线</title>
      <link href="/2025/01/12/EasyShader1%E2%80%94%E2%80%94%E7%9B%B4%E7%BA%BF/"/>
      <url>/2025/01/12/EasyShader1%E2%80%94%E2%80%94%E7%9B%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>本文初衷是为了配合入门图形学教程制作的同期系列编程教程，面向具有一定的编程语言学习基础的同学们，欢迎各位讨论交流！</li><li>本文将在图形学第八节课后随课程实时更新，共分为四个板块——直线绘制，三角形绘制，三角形填充，光线着色计算，最后可以得到一个具备基本亮暗面阴影的模型。</li><li>本文只是最基本的渲染器部分，后续会继续更新进阶版本内容。本文需要配合IDE使用，你可以访问我的库，其中的EasyRender项目有项目源码</li></ul><hr><h1 id="1-1直线的数学定义"><a href="#1-1直线的数学定义" class="headerlink" title="1.1直线的数学定义"></a>1.1直线的数学定义</h1><h2 id="1-1-1-为什么又是数学"><a href="#1-1-1-为什么又是数学" class="headerlink" title="1.1.1 为什么又是数学"></a>1.1.1 为什么又是数学</h2><ul><li>可能很多同学看到数学又出现了会感到厌烦，我很能理解大家的感受，但实际情况是，我们不能避免这种情况的发生，因为数学是我们的工具，我们做渲染本身实际上就是用数学去表达世界，因此数学是我们必须要去学习和认识的，况且，我们所用到的数学并 不难只需要大家去分析理解就够了。</li></ul><hr><h2 id="1-1-2-我们如何表示直线"><a href="#1-1-2-我们如何表示直线" class="headerlink" title="1.1.2 我们如何表示直线"></a>1.1.2 我们如何表示直线</h2><ul><li>在高中我们就学过了一条直线基本的表示方法，那就是点斜式表示法，可以写成：<ul><li>*P &#x3D; P0 + t(P1 - P0)</li></ul></li><li>同样，我们也可以将其拆分为x轴向上的以及y轴向上的坐标，方便我们理解实际的实现<ul><li>*x &#x3D; x0 + t(x1 -x0)</li><li>*y &#x3D; y0 + t(y1 - y0)</li></ul></li></ul><hr><ul><li>非常好，我们现在只需要去解决t这个变量了，通过联立上面的等式，我们可以得到<ul><li>*t &#x3D; x - x0 &#x2F; y - y0</li></ul></li><li>随后，我们将其带入方程，就能得到我们想要的点斜式雏形了。<ul><li>*y &#x3D; y0 + (x - x0)(y1 - y0)&#x2F;x1 - x0</li></ul></li><li>这时，我们发现，其实 (y1 - y0)&#x2F;x1 - x0 是一个常数，所以我将其设为a ， 当然 y0也是一个常数，我们设其为b，因此我们得到了我们喜闻乐见的公式<ul><li>y &#x3D; ax + b</li></ul></li><li>现在，我们已经具备的基本的数学认知，可以进行实践了！</li></ul><hr><h1 id="1-2-准备工作"><a href="#1-2-准备工作" class="headerlink" title="1.2 准备工作"></a>1.2 准备工作</h1><ul><li>首先，请保证你正确地将以下资源放入你的项目目录中，它们会提供一切你所需的包括但不限于函数，变量等。</li><li>1.geomertry.h<ul><li>这个头文件定义了基本的几何数据类型，如二维向量，三维向量等。</li></ul></li><li>2.tgaimage.h<ul><li>这个头文件包含我们设置颜色产生图片的函数声明，非常重要，是帮助我们创建画布的关键对象。</li></ul></li><li>3.tgaimage.cpp<ul><li>这个文件包含了上述tgaimage头文件的函数实现，会为我们设置对应的像素颜色。</li></ul></li></ul><hr><h2 id="1-2-1-什么是TGA格式"><a href="#1-2-1-什么是TGA格式" class="headerlink" title="1.2.1 什么是TGA格式"></a>1.2.1 什么是TGA格式</h2><ul><li>它是一种光栅化图形格式</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241107213822.png" alt="image.png"><br>          <code>TR 1.2.1TGA 的维基百科定义 </code></li><li>我们可以自由的用其最关键的<code>set（）</code>函数来填充像素，它接受四个参数，分别是x，y坐标以及绘制对象的引用还有颜色。下面让我们创建你的第一个光栅化着色器。</li></ul><hr><h2 id="1-2-2-创建项目"><a href="#1-2-2-创建项目" class="headerlink" title="1.2.2 创建项目"></a>1.2.2 创建项目</h2><ul><li>你可以使用任何你喜欢的IDE，这里演示时我们将使用VS2022版本进行演示。首先，创建你的项目，这里默认各位都是没有问题的，我们直接快进到main函数所在的CPP文件。</li><li>请包含以下基础的头文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include<span class="string">&quot;TGAImage.h&quot;</span></span><br></pre></td></tr></table></figure><hr><ul><li>下面我们来完成main函数，我们需要明确我们光栅化的逻辑，我们对对象进行算法处理，最后告诉TGA我们要怎么绘制它，所以基本的main函数应该是这样的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">TGAImage <span class="title">image</span><span class="params">(width, height, TGAImage::RGB)</span></span>;</span><br><span class="line">image.<span class="built_in">write_tga_file</span>(<span class="string">&quot;TRIANGLE.tga&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在第一行我们定义了一个TGAImage类型的变量image，它接受三个值，用于设定这个变量的长宽以及色彩通道，这里我们需要创建全局固定变量width以及height用于设定图像的长宽高，这里我们设定为1920×1080。</li><li>第二行我们用这个实例化对象调用了内置的<code>write_tga_file（）</code>方法，这个方法接受一个字符串变量，是我们在文件夹中创建的tga格式的文件，设置完成后，我们就可以来到我们最关注的代码部分了。</li></ul><hr><h1 id="1-3-直线算法实现"><a href="#1-3-直线算法实现" class="headerlink" title="1.3 直线算法实现"></a>1.3 直线算法实现</h1><h2 id="1-3-1-第一版直线代码"><a href="#1-3-1-第一版直线代码" class="headerlink" title="1.3.1 第一版直线代码"></a>1.3.1 第一版直线代码</h2><ul><li>如你所见，我们只需要根据我们第一次想到的逻辑去绘制这条直线就好了，它看起来应该是这样的：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0 , <span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1 , TGAImage &amp;imag,TGAColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> t = <span class="number">0.</span>; t&lt;<span class="number">1</span>;t+=<span class="number">.01</span>)&#123;</span><br><span class="line"><span class="type">int</span> x = x0 + (x1 - x0)*t;</span><br><span class="line"><span class="type">int</span> y = y0 + (y1 - x0)*t;</span><br><span class="line">image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>这些代码是什么意思呢？首先它接受六个参数，分别是这条直线的起始和结束的横纵坐标，以及需要写入的TGA图片对象，以及颜色信息。</li><li>随后我们以0.01为步长，开始这个循环，也就是一共会完成十次渲染每一次逐渐逼近填充到目标位置，最后一次就会设置所有路径上的像素。</li></ul><hr><ul><li>最后使用image对象自身具备的set函数，设置像素，看起来是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241108113705.png" alt="image.png"><br>                  <code>1.3.1 线段——第一次尝试</code></li></ul><hr><h2 id="1-3-2-第一次尝试改进"><a href="#1-3-2-第一次尝试改进" class="headerlink" title="1.3.2 第一次尝试改进"></a>1.3.2 第一次尝试改进</h2><ul><li>首先这段代码要遍历100次，速度非常慢，并且如果调整步长，会导致像素之间分离，让直线断开。接下来我们需要对其调整，我们不希望因为步长原因舍弃直线的精度同样也不希望因此导致绘制失败，所以我们要回归最基本的内容，那就是我们只负责绘制每一个点上的像素，而其解决方法就是，以x为准，绘制x1 - x0 次，我们就应该能够得到所需线段。</li><li>于是我们有了以下的改进：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(<span class="type">int</span> x0,<span class="type">int</span> y0,<span class="type">int</span> x1,<span class="type">int</span> y1,TGAImage &amp;image,TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x =x0 ,x &lt;= x1 ;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> t = (x - x0) / (<span class="type">float</span>)(x1 - x0);</span><br><span class="line"><span class="type">int</span> y = y0*(<span class="number">1.</span>-t) + y1*t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>现在我们不用担心步长变化给直线本身带来的错误了，但还有个问题，那就是如果我们绘制一条很陡的线段，也就是 x1 - x0 很小几乎接近于0 的线段时，t增加的速度就会变得非常快，因此还是会出现分离的状况：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241108121426.png" alt="image.png"><br>              <code>1.3.2 线段——第二次尝试</code></li><li>其实原因就在于x变化太快了，我们只要选择变化慢一些的算法（这本质上是一种走样）也就是使用y作为变化量即可，用选择分支来判断是否要执行这样的操作。</li></ul><hr><h2 id="1-3-3-第三次改进——分类绘制"><a href="#1-3-3-第三次改进——分类绘制" class="headerlink" title="1.3.3 第三次改进——分类绘制"></a>1.3.3 第三次改进——分类绘制</h2><ul><li>按照以上的思路，我们使用一下代码….<br><code>if (dx &gt; dy) {for (int x) else {for int y}}</code></li><li>但是等一下，我们可以做的更好，实际上我们只需要写一套逻辑就够了，我们让对应的数据交换，而不是单独为其编写一套新逻辑，这样能节省我们的步骤同样是优化的一种方式。</li><li>代码看起来是这样的</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">( <span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1 ,<span class="type">int</span> y1 , TGAImage &amp;image, TGAColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> steep = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">abs</span>(x0 - x1) &lt; std::(y0 - y1))</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(x0,y0);</span><br><span class="line">std::<span class="built_in">swap</span>(x1,y1);</span><br><span class="line">steep = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x0 &gt; x1)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(x0,x1);</span><br><span class="line">std::<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x =x0 ,x &lt;= x1 ;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> t = (x - x0) / (<span class="type">float</span>)(x1 - x0);</span><br><span class="line"><span class="type">int</span> y = y0*(<span class="number">1.</span>-t) + y1*t;</span><br><span class="line"><span class="keyword">if</span>(steep)</span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">set</span>(y,x,color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">set</span>(x,y,color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>我们在上述的过程中首先对y0 - y1值与x1 - x0 值进行了判断。并根据结果考虑是否要交换其值，本质上相当于对线段进行了一次以横坐标为轴向的翻转。</li><li>但翻转过后我们也得考虑是否破坏了我们原本想要的图像，因此如果x0比x1小的话，我们只需要再次将其翻转即可，后续在循环中我们只需要依据是否交换了数据来填写不同的set函数参数即可完成任意线段的绘制了。</li><li>但如果你现在运行这个程序，它绘制的依然没有达到我们想要的最高速度，这是因为在循环中存在着大量的乘除法运算，它的开销在一些低端平台上很大，因此考虑到这一点，我们需要去对其进行改变，这里我们用到一个误差思想。</li></ul><hr><h2 id="1-3-4-第四次尝试——优化乘除法与浮点数"><a href="#1-3-4-第四次尝试——优化乘除法与浮点数" class="headerlink" title="1.3.4 第四次尝试——优化乘除法与浮点数"></a>1.3.4 第四次尝试——优化乘除法与浮点数</h2><ul><li>我们可以设置一个标准斜率也就是我们的k值，其叫做debugger，这个标识用于判断我们的直线是否离开了选定的范围，随后，我们用error来进行标志，每一次设置颜色就将error加上一个debugger，这很容易理解，因为回到线段的最初始定义，y &#x3D; kx + b ，每一次y增加的就是 一个k的距离，因此如果设置第二个点，偏差就应该超过这个范围了，因此y+1，随后偏移值再次减少，循环这个过程，代码修改部分是这样的：</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx = x1-x0; </span><br><span class="line">   <span class="type">int</span> dy = y1-y0; </span><br><span class="line">   <span class="type">float</span> derror = std::<span class="built_in">abs</span>(dy/<span class="built_in">float</span>(dx)); </span><br><span class="line">   <span class="type">float</span> error = <span class="number">0</span>; </span><br><span class="line">   <span class="type">int</span> y = y0; </span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">       <span class="keyword">if</span> (steep) &#123; </span><br><span class="line">           image.<span class="built_in">set</span>(y, x, color); </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">       &#125; </span><br><span class="line">       error += derror; </span><br><span class="line">       <span class="keyword">if</span> (error&gt;<span class="number">.5</span>) &#123; </span><br><span class="line">           y += (y1&gt;y0?<span class="number">1</span>:<span class="number">-1</span>); </span><br><span class="line">           error -= <span class="number">1.</span>; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>在此基础上我们依然也可以继续修改，现在的代码看起来 已经很好了，但我们还能再继续修改，因为浮点数在CPU上的开销同样比较大，因此我们可以使用整数型代替浮点型，这就要求我们需要是的这个算法对于误差感知更精准，所以我们将误差感知的范围从原来的浮点型放大为以dx代表的整数型，并以此来进行逻辑判断，其余的形式一样，这样的思想类似于数学上的放缩思想。</li></ul><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> derror2 = std::<span class="built_in">abs</span>(dy)*<span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span> error2 = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> y = y0; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x=x0; x&lt;=x1; x++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (steep) &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(y, x, color); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            image.<span class="built_in">set</span>(x, y, color); </span><br><span class="line">        &#125; </span><br><span class="line">        error2 += derror2; </span><br><span class="line">        <span class="keyword">if</span> (error2 &gt; dx) &#123; </span><br><span class="line">            y += (y1&gt;y0?<span class="number">1</span>:<span class="number">-1</span>); </span><br><span class="line">            error2 -= dx*<span class="number">2</span>; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>后面两种方法只需要了解即可，我们需要关注的实际上是如何绘制线段本身，性能需求虽然也是考虑的内容，但在如今的计算平台上已经是可被忽略的改进了。至此我们第一部分线段的内容就已经完成了，下一节我们将用这个算法绘制一个苹果线框以及考虑三角形的绘制。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南</li><li><a href="https://github.com/ssloy/tinyrenderer">https://github.com/ssloy/tinyrenderer</a></li><li>我的项目地址：</li><li><a href="https://github.com/Pleasant233/EasyRender">https://github.com/Pleasant233/EasyRender</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EasyShader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学7——光栅化1</title>
      <link href="/2025/01/12/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A67%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%961/"/>
      <url>/2025/01/12/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A67%E2%80%94%E2%80%94%E5%85%89%E6%A0%85%E5%8C%961/</url>
      
        <content type="html"><![CDATA[<h1 id="7-0-前言"><a href="#7-0-前言" class="headerlink" title="7.0 前言"></a>7.0 前言</h1><ul><li>从本节开始，将开始真正结合编程知识开始大量实践，本课讲单独开设一个分专题来进行专门的编程实践部分分享，每节课都会有对应代码部分的章节，跟随实践的同学可以参考代码。</li></ul><hr><h1 id="7-1-相关基本概念"><a href="#7-1-相关基本概念" class="headerlink" title="7.1 相关基本概念"></a>7.1 相关基本概念</h1><h2 id="7-1-1-屏幕"><a href="#7-1-1-屏幕" class="headerlink" title="7.1.1 屏幕"></a>7.1.1 屏幕</h2><ul><li>关于屏幕，其具备基本的基础属性，如：长，宽，亮度，色彩范围等。</li><li>我们主要关注的是屏幕的长宽。</li><li>屏幕可以视为一个二维数组，其位置坐标可以表示为屏幕长宽中任意两个数字组合。</li><li>我们通过设置每一个数组元素的值来定义如何呈现需要呈现的点。</li></ul><hr><h2 id="7-1-2-像素"><a href="#7-1-2-像素" class="headerlink" title="7.1.2 像素"></a>7.1.2 像素</h2><ul><li>像素是屏幕的基本单位，也就是上述单个数组的具体实现方式。</li><li>我们目前阶段可以简单的认为像素是一个具有基本位置信息，由红绿蓝三个颜色通道值来定义的对象。</li></ul><hr><h2 id="7-1-3-光栅化"><a href="#7-1-3-光栅化" class="headerlink" title="7.1.3 光栅化"></a>7.1.3 光栅化</h2><ul><li>光栅化实际上就是我们设置屏幕像素的过程</li><li>光栅（Raster）在德语中的意思就是屏幕。</li></ul><hr><h1 id="7-2-屏幕视口坐标及其转化"><a href="#7-2-屏幕视口坐标及其转化" class="headerlink" title="7.2 屏幕视口坐标及其转化"></a>7.2 屏幕视口坐标及其转化</h1><h2 id="7-2-1-什么是屏幕视口坐标"><a href="#7-2-1-什么是屏幕视口坐标" class="headerlink" title="7.2.1 什么是屏幕视口坐标"></a>7.2.1 什么是屏幕视口坐标</h2><ul><li>屏幕视口坐标就是真正呈现在平面上的二维坐标系。</li><li>在先前我们通过矩阵变换将三维信息变换到裁剪空间之后，需要进行屏幕视口坐标的映射，这一步并不困难，实际上就是将对象的坐标位置变换到视口坐标原点，这一般是图像正中，但就像我们之前所提到的，根据不同的图形API规定，视口坐标也并不相同。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103153610.png" alt="image.png"><br>                      <code>7.2.1 屏幕视口坐标系</code></li></ul><hr><h2 id="7-2-2-屏幕视口坐标变换"><a href="#7-2-2-屏幕视口坐标变换" class="headerlink" title="7.2.2 屏幕视口坐标变换"></a>7.2.2 屏幕视口坐标变换</h2><ul><li>我们只需要使用一个很简单的矩阵变换就可以搞定了。</li><li>如下图，先将原本的（-1，1）的图像缩放至屏幕大小，对于单独的一个坐标应该是先将原本的宽高绝对值为2的NDC（设备归一化坐标）下的图形划归为1，随后再缩放到（w，h）大小，再将将元素的中心（原本是(0,0)）移动到屏幕中心(w&#x2F;2,H&#x2F;2)，将左下角作为（0,0）点。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103154056.png" alt="image.png"><br>                          <code>7.2.2 屏幕视口变换矩阵</code></li><li>到此为止我们就完成了将顶点从模型空间变换到在屏幕空间上的完整过程。</li></ul><hr><h1 id="7-2-3-将顶点映射到像素"><a href="#7-2-3-将顶点映射到像素" class="headerlink" title="7.2.3 将顶点映射到像素"></a>7.2.3 将顶点映射到像素</h1><ul><li>现在，我们具备了顶点信息，下一步我们需要以一定图元的方式呈现顶点，这样做的好处有：<ul><li>方便后续进行插值计算</li><li>方便更好的判断顶点位置</li><li>方便渲染减少开销</li></ul></li><li>一般使用三角形作为图元，那么我我们如何判断三角形对于像素的影响呢？</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103175601.png" alt="image.png"><br>                      <code>7.2.3 如何将三角形图元映射到像素上？</code></li><li>我们通过<strong>采样</strong>的方式来进行线性的图元到离散像素的变换。</li></ul><hr><ul><li>采样实际上就是用一个函数描述逐个像素点上对应的值的变化，我们可以写一个伪代码来描述它，实际上我很不喜欢伪代码，但如果作为表达方法实现的思路，倒是也有可取之处。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x =<span class="number">0</span>;x&lt;xmax;++x)</span><br><span class="line">output[x] = <span class="built_in">f</span>(x);</span><br></pre></td></tr></table></figure><ul><li>你可以看到实际上它就是对逐个离散化的x变量用一个函数输出到一个数组中。不理解数组没关系，你可以理解为就是输出到了屏幕上。</li></ul><hr><ul><li>理解了这个过程，我们就可以进行下一步的判断了，我们要去判断一个像素点是否在这个映射的范围内，如果在，则输出1否则输出0，像素中心可以理解为像素的x，y坐标分别+0.5个单位值对应的点，如图</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241103180835.png" alt="image.png"><br>                          <code>7.2.3.1 离散后的像素中心点坐标</code></li></ul><hr><ul><li>所以它对应的伪代码应该是这样的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x =<span class="number">0</span>;x&lt;xmax;++x)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;max;++y)</span><br><span class="line"><span class="built_in">inside</span>(tri,x<span class="number">+0.5</span>,y<span class="number">+0.5</span>);</span><br><span class="line"><span class="built_in">inside</span>(triangle,<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">point newpoint = <span class="built_in">point</span>(x,y);</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">crows</span>(triangle.t1- newpoint,triangle.t1 - triangle.t2);</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">crows</span>(triangle.t2- newpoint,triangle.t2 - triangle.t3);</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">crows</span>(triangle.t3- newpoint,triangle.t1 - triangle.t3);</span><br><span class="line"><span class="keyword">if</span>(a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>&amp;&amp;c&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此处对应的判断方法在之前的线代基础中已经提到过了，实际上就是用叉积检测点是否同时在三角形的同一边，如果是，则说明该点在三角形内。数学过程就不再赘述，欢迎大家回顾之前的内容。</li></ul><hr><h2 id="7-2-4-光栅化加速方法"><a href="#7-2-4-光栅化加速方法" class="headerlink" title="7.2.4 光栅化加速方法"></a>7.2.4 光栅化加速方法</h2><ul><li>AABB包围盒：<ul><li>现在如果我们按以上方法判断三角形与映射像素的关系，我们会发现，它太耗时间了！如果要遍历全部像素的话，的确是如此，但是我们可以只关注我们需要关注的部分，那就是三角形本身，我们可以只遍历三角形而不关注其他部分。</li><li>这种覆盖三角形的部分就叫做包围盒，类似于Unity等引擎中的碰撞箱。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104145440.png" alt="image.png"><br>                    <code>7.2.4 AABB包围盒</code></li></ul></li></ul><hr><ul><li>针对特殊三角形的特殊遍历</li><li>上面这样的三角形虽然很方便，但却太理想了，有可能会出现那种又窄又长的三角形，这时候再用包围盒，加速效果就远没有那么明显了，因此此时我们会使用针对这种三角形的遍历方式，那就是从左到右遍历，实际上在实现中我们也将使用这种方式，它将先查找三角形最左段然后逐一向右遍历，依次绘制：</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104150626.png" alt="image.png"><br>                      <code>7.2.4.1 特殊三角形的由左至右的遍历</code></li></ul><hr><h1 id="7-3-拓展"><a href="#7-3-拓展" class="headerlink" title="7.3 拓展"></a>7.3 拓展</h1><h2 id="7-3-1-真实的屏幕像素"><a href="#7-3-1-真实的屏幕像素" class="headerlink" title="7.3.1 真实的屏幕像素"></a>7.3.1 真实的屏幕像素</h2><ul><li>在现实中像素会像是我们上述所讲的样子吗？显然不会，实际上受击屏幕上的像素其实是由红绿蓝三原色像素条所组成的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104151013.png" alt="image.png"><br>                      <code>7.3.1 真实的像素屏幕</code></li><li>如果仔细观察会发现，实际上像素的绿色部分会更多，这是因为人眼对绿色光更为敏感，因此绿色部分占屏幕比例自然会更多。</li></ul><hr><h1 id="7-3-2-一些问题"><a href="#7-3-2-一些问题" class="headerlink" title="7.3.2 一些问题"></a>7.3.2 一些问题</h1><ul><li>现在，我们已经可以去实现将三角形填充在像素上了，但这个结果并不完美，因为填充的部分是均匀的，如果像素中心点不在三角形内，填充的结果就是空白，所以我们会得到下面这个结果，如何去优化它呢？等到下一节我们在去分析，在同期的程序部分，你将可以渲染出一个这样一个红色片元，我们模拟了这个过程。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241104151449.png" alt="image.png"><br>                          <code>7.3.2 初步的光栅化结果</code></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li><li>Games101计算机图形学入门——闫令琪</li><li>计算机图形学入门——3D渲染指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学6——渲染管线综述</title>
      <link href="/2024/12/21/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A66%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/12/21/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A66%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-什么是渲染管线（渲染流水线）"><a href="#6-1-什么是渲染管线（渲染流水线）" class="headerlink" title="6.1 什么是渲染管线（渲染流水线）"></a>6.1 什么是渲染管线（渲染流水线）</h1><ul><li><strong>渲染管线</strong>或称<strong>渲染流水线</strong>实际上描述的就是存在在计算机内存中的数据<strong>如何渲染呈现在屏幕上的过程。</strong> 当下的大多数主流的设备终端都支持的一系列操作的总称，接下来我们将为各位分享详细的渲染流程，以及管线综述。</li></ul><h2 id="6-1-1-什么是SHADER？"><a href="#6-1-1-什么是SHADER？" class="headerlink" title="6.1.1 什么是SHADER？"></a>6.1.1 什么是SHADER？</h2><ul><li>Shader是着色器，是可编程渲染管线的一部分，有一定的着色器，顶点着色器（vertex Shader），片元着色器（Fragment Shader ）等，我们可以通过Shader与GPU交流，控制渲染细节。主要分为可编程和可配置两类。</li></ul><h2 id="6-1-2-SHADER与Material的关系？"><a href="#6-1-2-SHADER与Material的关系？" class="headerlink" title="6.1.2 SHADER与Material的关系？"></a>6.1.2 SHADER与Material的关系？</h2><ul><li>Shader与贴图等资源组合起来得到Material，材质好比商品，Shader是加工方法，而贴图是原材料</li></ul><hr><h1 id="6-2-渲染管线的流程"><a href="#6-2-渲染管线的流程" class="headerlink" title="6.2 渲染管线的流程"></a>6.2 渲染管线的流程</h1><h1 id="6-2-1-渲染管线的三个主要阶段"><a href="#6-2-1-渲染管线的三个主要阶段" class="headerlink" title="6.2.1 渲染管线的三个主要阶段"></a>6.2.1 渲染管线的三个主要阶段</h1><ul><li>渲染管线就像工厂中的流水线，主要分为以下三个阶段<ul><li>应用阶段</li><li>几何阶段</li><li>光栅化阶段</li></ul></li><li>第一个阶段主要由CPU负责，而后两个阶段则由GPU负责</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240827220247.png" alt="imag.png"><br>              <code>6.2.1 渲染管线大致流程划分</code></li><li>应用阶段又可分为加载显存数据，加速算法，设置渲染状态，调用DRAWCALL。此部分由CPU负责，主要将应用软件里的数据整理调试，并最后打包发送给GPU。</li></ul><hr><ul><li>几何阶段可分为顶点变换（也就是我们之前所提到的MVP矩阵）裁剪，屏幕映射，这三个阶段，最终将渲染出来的图元存储在缓存（buffer）之中。此阶段对应的是<strong>曲面细分着色器和顶点着色器</strong></li><li>光栅化阶段则将上一阶段的数据进行三角形设置，遍历，传递给<strong>片元着色器</strong>。最后通过逐片元操作，进行一系列的测试，在将片元对应像素绘制到屏幕之上。</li><li>由此便完成了基本的图像绘制流程，下面是这些流程的详细介绍与具体应用。</li></ul><hr><h1 id="6-2-2-应用阶段"><a href="#6-2-2-应用阶段" class="headerlink" title="6.2.2 应用阶段"></a>6.2.2 应用阶段</h1><ul><li>应用阶段大致步骤</li><li>**准备场景数据</li><li>场景物体数据<ul><li>物体的**变换数据，位置，旋转等</li><li>物体的**网格数据，顶点位置，UV贴图等</li></ul></li><li>摄像机数据<ul><li>摄像机的**位置方向，远近裁剪平面</li><li>正交透视FOV</li><li>**视口比例大小尺寸</li></ul></li></ul><hr><ul><li>光源以及阴影数据<ul><li>光源**类型，位置方向，角度</li><li>是否需要阴影，判断是否有**能够投射阴影的物体</li><li>阴影参数，对应光源序号，**阴影强度，级联参数，</li><li>**深度偏移，近平面偏移等</li><li>逐光源绘制阴影贴图：<ul><li>近平面偏移</li><li>逐级联，计算当前**光源加级联对应的观察矩阵投影矩阵以及对应阴影贴图里的视口</li><li>绘制到阴影贴图</li></ul></li></ul></li><li>其他全局数据</li></ul><hr><ul><li>加速算法，颗粒度剔除<ul><li>碰撞检测</li><li>加速算法<ul><li>可见光裁剪</li><li>可见场景物体裁剪<ul><li>八叉树，BSP数，K-D树，BVH包围盒等</li></ul></li></ul></li><li>遮挡剔除</li></ul></li></ul><hr><ul><li>设置渲染状态，准备渲染参数<ul><li>绘制设置<ul><li>使用着色器</li><li>合批方式</li></ul></li><li>绘制顺序(Render Queue)<ul><li>相对摄像机的距离</li><li>UICanvas等（Unity举例）</li></ul></li><li>渲染目标(RenderTarget)<ul><li>帧缓存（FrameBuffer）</li><li>渲染纹理RenderTexture</li></ul></li><li>渲染模式(RenderMode）<ul><li>如ForwardBase等</li></ul></li></ul></li></ul><hr><h2 id="6-2-3-DRAWCALL与OpenGL，DX等"><a href="#6-2-3-DRAWCALL与OpenGL，DX等" class="headerlink" title="6.2.3 DRAWCALL与OpenGL，DX等"></a>6.2.3 DRAWCALL与OpenGL，DX等</h2><ul><li>我们常说的OpenGL与DirectX是什么东西呢？</li><li>这两种都是图形API，也就是图形接口，它是渲染硬件上的一层抽象，我们通过编写HLSL，GLSL&#x2F;CG来调用这些接口，它们将向显卡硬件驱动发动相关指令，由硬件驱动翻译并让硬件执行，我们向硬件发出的命令被称为DRAWCALL。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241101150457.png" alt="image.png"><br>                       <code>渲染操作的逻辑层次</code></li></ul><hr><ul><li>目前游戏中的着色器语言是针对多平台的，它会根据平台不同智能编译成对应的机器语言，并传递对应的信息，所以在游戏中经常会遇到“编译着色器”这个提示，比如黑神话中的这个开头，其实就是在将统一的着色器语言，翻译成对应API对应驱动程序版本的底层机器语言</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241101150738.png" alt="image.png"><br><code>6.2.3 黑神话的着色器编译中~</code></li><li>提个小问题，这部分的速度快慢主要依靠的指标是什么？</li></ul><hr><ul><li>DRAWCALL</li><li>这个步骤实际上就是CPU调用图像编程接口的过程，例如OpenGL中的glDrawElements命令，这也是造成性能瓶颈最大的原因所在。DrawCall中造成性能问题的根本不是GPU而是CPU，实际上，在渲染流程中，我们会在此构建一个缓冲区，它存储CPU发出的指令，由GPU读取，这样GPU快速的读取就不会因为CPU的缓慢而减速。</li></ul><hr><ul><li>我们要尽可能的优化渲染流程，因此DrawCall便是我们的一大优化目标，因为每次发送DrawCall指令，CPU都要向GPU发送大量信息，例如模型的顶点法线等参数，这就会大量消耗时间。</li><li>怎么优化DrawCall？我们可以有很多种方式，这里主要讨论批处理方式（Batching）</li><li>Batching实际上可以理解为打包，而DrawCall可以理解为提交。</li></ul><hr><ul><li>顾名思义，这个方法就是让我们将很多的小DrawCall打包成为一个大的命令，来向GPU传输，以此降低批量传输的损耗，但是打包同样需要耗费时间，因此我们只针对静态的物体进行这个操作</li><li>目前在实际引擎应用中，主要有四种优化方式，Static Batching ，Dynamic Batching ，GPU Instance ， SRP Batcher。</li><li>旧有的优化方式（StaticBatching静态批处理）：<ul><li>避免添加大量的很小的网格（但是Nanite可以帮我们解决这点）</li><li>避免添加大量的材质（但是虚拟材质可以帮我们解决这点）</li><li>以上的优化方式在如今都可以不被考虑，但初学时依然需要记忆他们！</li></ul></li></ul><hr><h2 id="6-2-4-几何阶段"><a href="#6-2-4-几何阶段" class="headerlink" title="6.2.4 几何阶段"></a>6.2.4 几何阶段</h2><ul><li>顶点着色<ul><li>视图变换</li><li>顶点着色</li></ul></li><li>这个阶段对应的着色器就是顶点着色器，主要处理的是顶点由模型空间变换到视图坐标系的一系列变换，也就是前文我们推导的MVP变换矩阵的前两部分</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008193638.png" alt="image.png"><br>         <code>6.2.4 顶点的坐标变换</code></li></ul><hr><ul><li>可选点处理<ul><li>曲面细分，通过插值增加顶点，实现曲面细分效果。</li><li>几何着色器，操作图元，操作多个顶点组成的图元以生成更多图元。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008193848.png" alt="image.png"><br>     <code>6.2.4.1 几何着色器</code></li><li>什么是片元，图元？</li><li>几何顶点被组合为图元（点，线段或多边形），然后图元被合成片元，最后片元被转换为帧缓存中的象素数据。片元是增加了着色，深度等信息的顶点，其阶段是等价的。</li></ul></li></ul><hr><ul><li>投影<ul><li>正交</li><li>透视</li><li>至此完成顶点空间到投影空间的变换，变换的结果被称作归一化设备坐标系（NDC）<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008194030.png" alt="image.png"><br>      <code>6.2.4.2 投影操作</code></li></ul></li></ul><hr><ul><li>裁剪<ul><li>CVV剔除，如果变化后的图元大于NDC时，则会进行裁剪，保留在NDC立方体内的图元</li></ul></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193727.png" alt="image.png"><br>      <code>6.2.4.3 片元裁剪剔除</code><ul><li>正反面剔除（可配置）</li><li>剔除正面或者背面的片元，UnityShader中的Cull 指令</li></ul></li><li>图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐标被转换为窗口坐标。最后，光栅化将裁剪好的图元转换为片元。</li></ul><hr><ul><li>屏幕映射<ul><li>由连续的线变为二维坐标上离散的点</li></ul></li><li>将NDC根据屏幕比例和大小变化为实际屏幕显示的位置</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193807.png" alt="image.png"><br>                      <code>6.2.4.4 屏幕映射</code></li></ul><hr><h2 id="6-2-5-光栅化阶段"><a href="#6-2-5-光栅化阶段" class="headerlink" title="6.2.5 光栅化阶段"></a>6.2.5 光栅化阶段</h2><ul><li>三角形设置<ul><li>得到三角形边界信息</li></ul></li><li>三角形遍历<ul><li>寻找被三角形覆盖的像素，插值并填充三角形</li></ul></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027194356.png" alt="image.png"><br>                          <code>6.2.5. 三角形遍历</code></li><li>同时还能进行的操作，抗锯齿处理</li></ul><hr><ul><li>抗锯齿MSAA<ul><li>有三种主流的抗锯齿类型，分别是</li><li>SSAA<ul><li>将片元放大并存入缓冲，对放大n倍的buffer采样</li></ul></li><li>MSAA<ul><li>在光栅化阶段，计算多个覆盖样本</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027194759.png" alt="image.png"><br>                  <code>6.2.5.1 抗锯齿MSAA</code></li><li>这个操作是对片元进行深度测试和覆盖测试，来对像素进行叠加，计算多个覆盖版本，并且还可以将数据传递给后续逐片元操作中的混合操作。</li></ul></li><li>FXAA，TXAA<ul><li>后处理技术，不在光栅化阶段</li></ul></li></ul></li></ul><hr><ul><li>逐片元操作阶段<ul><li>片元着色器</li><li>颜色混合</li><li>目标缓冲区</li></ul></li><li>片元首先要通过模版，深度测试，才能和缓冲区也就是上一帧素材混合进入到颜色缓冲区。裁剪会根据需求发生在深度测试之前</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027193959.png" alt="image.png"><br>                      <code>6.2.5.2 逐片元操作流程</code></li></ul><hr><ul><li>片元着色</li><li>使用三定点插值进行计算得到最终的着色结果</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027195715.png" alt="image.png"><br>                      <code>6.2.5.3 差值实现三角形着色</code></li></ul><hr><ul><li>颜色混合</li><li>透明度测试<ul><li>透明度小于某阈值被剔除</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027195814.png" alt="image.png"><br>                  <code>6.2.5.4 透明度测试</code></li></ul></li><li>模版测试，深度测试</li><li>存入深度信息和模版所需数据信息。这两个操作都是可配置的。</li></ul><hr><h2 id="6-2-5-模版测试"><a href="#6-2-5-模版测试" class="headerlink" title="6.2.5 模版测试"></a>6.2.5 模版测试</h2><ul><li>模版测试是位于<strong>逐片元操作</strong>中的一环，通过掩码读取<strong>模版缓冲区</strong>中的相关值，与参考值进行比较，这个比较结果可由开发者决定，不论通过与否，都可以修改缓冲区的值，主要用于<strong>设定渲染范围</strong>以及高阶的阴影边缘效果等</li></ul><hr><h2 id="6-2-6-深度测试"><a href="#6-2-6-深度测试" class="headerlink" title="6.2.6 深度测试"></a>6.2.6 深度测试</h2><ul><li>深度测试用于记录场景中片元深度，并且根据深度来调整渲染方案，可以省略不需要的片元来减少性能消耗，这个过程有时会在进入片元着色器阶段前进行。</li></ul><hr><h2 id="6-2-7-混合模式"><a href="#6-2-7-混合模式" class="headerlink" title="6.2.7 混合模式"></a>6.2.7 混合模式</h2><ul><li>混合(Blend)通过设置混合状态，来调节当前颜色值与颜色缓冲区中的颜色值之间的运算关系。</li><li>不透明材质则直接覆盖掉颜色缓冲区中的值，而对于半透明等材质就可以对其进行混合操作来进行更多元化的更改,混合操作是高度可配置的。</li></ul><hr><ul><li>颜色混合中的测试的顺序是什么样的？详细可以查看：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/d65dbf5a8b7abadbb5899871c6c48b3.jpg" alt="d65dbf5a8b7abadbb5899871c6c48b3.jpg"><br>                    <code>6.2.5.3 测试顺序</code></li></ul><hr><h1 id="6-3-固定渲染管线（已被淘汰）"><a href="#6-3-固定渲染管线（已被淘汰）" class="headerlink" title="6.3 固定渲染管线（已被淘汰）"></a>6.3 固定渲染管线（已被淘汰）</h1><ul><li>固定渲染管线如今几乎已经被抛弃，它是只有一定的配置能力而无法让我们掌控全局的渲染管线，我们只能通过控制管线流程的开关以此来实现局限的效果，现在已经被抛弃。目前主流的渲染管线为SRP（可编程渲染管线）</li></ul><h1 id="6-4-引擎中的渲染管线"><a href="#6-4-引擎中的渲染管线" class="headerlink" title="6.4 引擎中的渲染管线"></a>6.4 引擎中的渲染管线</h1><ul><li>首先，我们需要区分两个概念，一个叫做渲染模式，也就是所谓的前向渲染，延迟渲染，另外就是我们这节课所提到的渲染管线。</li><li>渲染模式更类似于处理方法，而渲染管线则是实际处理的对象，我们利用不同的处理方法处理渲染管线得到的数据。</li></ul><hr><ul><li>目前在Unity中，渲染管线主要分为Built-in 以及URP 和HDRP，后续Untiy大概率会合并URP 以及 HDRP。其中主要的区别是，Built-in是内置渲染管线，何为内置，也就是放在里面，它对于我们自定义的部分所提供的效果较少，适合完成一些对于定制需求效果没有那么高的项目。</li><li>而URP则更加通用，这也是为何称其为URP，它为我们提供了更多可自定义的部分，比如RenderFeather就可以允许我们更自由的调用或修改管线中我们想要的部分。</li></ul><hr><h1 id="6-5-结语"><a href="#6-5-结语" class="headerlink" title="6.5 结语"></a>6.5 结语</h1><ul><li>至此，我们已经大致了解了一个软件中的资产是如何渲染到屏幕之上的，接下来我们将细致剖析各个流程之中的细节，并亲自动手实践，体会一个简单的三角片元是如何渲染的。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>UnityShader入门精要——冯乐乐著</li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li><li>Games101计算机图形学入门——闫令琪</li><li>知乎诸佬<br>  猫都能看懂的URP RenderFeature使用及自定义方法 - 蚊子尼的文章 - 知乎<br>  <a href="https://zhuanlan.zhihu.com/p/396965255">https://zhuanlan.zhihu.com/p/396965255</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学5——变换2</title>
      <link href="/2024/12/14/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A65%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A22/"/>
      <url>/2024/12/14/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A65%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A22/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-变换的组合"><a href="#5-1-变换的组合" class="headerlink" title="5.1 变换的组合"></a>5.1 变换的组合</h1><h2 id="5-1-1-任何变换都可以由单个变换组合得到"><a href="#5-1-1-任何变换都可以由单个变换组合得到" class="headerlink" title="5.1.1 任何变换都可以由单个变换组合得到"></a>5.1.1 任何变换都可以由单个变换组合得到</h2><ul><li>在上一节我们了解到了基本的变换类型了，并接触了将变换统一的坐标类型——其次坐标，还了解了其表现形式，其次矩阵。</li><li>这一节我们来看变换组合中需要注意的点。</li><li>事实上，任何变换都可以由单个变换组合而来，但他们的顺序却是需要考虑的。</li></ul><hr><h2 id="5-1-2-不同的顺序带来不同的结果"><a href="#5-1-2-不同的顺序带来不同的结果" class="headerlink" title="5.1.2 不同的顺序带来不同的结果"></a>5.1.2 不同的顺序带来不同的结果</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028084338.png" alt="image.png"><br>      <code>5.1.2 不同的变换顺序带来的结果不同</code></li><li>图中是一个变换的例子，它先进行了平移而后进行了旋转，但如果是先旋转再平移，呈现出的结果就不同，这很好理解，因为操作导致顶点位置发生了改变，因此就会使得结果不一样。</li></ul><hr><ul><li>这也表明了数学上，矩阵不符合交换律。因此往往平移是最后发生的。</li><li>我们往往应用矩阵的顺序是由右向左进行的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028084718.png" alt="image.png"><br>      <code>5.1.2.1 矩阵的应用是由右向左进行的</code></li><li>但矩阵同样具有结合律，因此我们可以将复杂的矩阵操作何为一个矩阵来对向量进行操作变换，例如MVP矩阵。</li></ul><hr><h2 id="5-1-3-变换的分解"><a href="#5-1-3-变换的分解" class="headerlink" title="5.1.3  变换的分解"></a>5.1.3  变换的分解</h2><ul><li>变换能够组合自然也能够分解，一些复杂的变换我们都可以通过将其分解为简单变换来实现，比如下面这个变换。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028085652.png" alt="image.png"><br>          <code>5.1.3 变换的分解</code></li><li>仔细观察这个变换，实际上它做的操作是将该图形平移到远点后，对其旋转，而后再平移回这个图形位置，这样就用我们已有的知识完成了一个复杂的不以原点为中心旋转的变换。在后续的学习过程中我们都应该保持这种思考方式，化繁为简，抓住主要矛盾。</li></ul><hr><h1 id="5-2-三维的变换"><a href="#5-2-三维的变换" class="headerlink" title="5.2 三维的变换"></a>5.2 三维的变换</h1><h2 id="5-2-1-知识的迁移"><a href="#5-2-1-知识的迁移" class="headerlink" title="5.2.1 知识的迁移"></a>5.2.1 知识的迁移</h2><ul><li>实际上，三维空间中的坐标变换与二维空间类似，本质上只不过多了个维度，我们依然使用其次坐标方式表示任何变换。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028090209.png" alt="image.png"><br>              <code>5.2.1 一个三维变换矩阵</code></li><li>这里闫老师在101中给大家提了一个小思考，三维空间中是先考虑线性变换还是先考虑平移呢？</li><li>相信大家已经有了自己的答案，当然是先考虑线性变换啊！多加了个维度本质都是通用的嘛！</li></ul><hr><h2 id="5-2-2-三维空间的旋转"><a href="#5-2-2-三维空间的旋转" class="headerlink" title="5.2.2 三维空间的旋转"></a>5.2.2 三维空间的旋转</h2><ul><li>三维空间中的旋转可能乍一看很复杂，但我们同样可以对其进行分解。</li><li>以下是分别按X，Y，Z轴向进行旋转的旋转矩阵，请各位观察其特点。</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028091513.png" alt="image.png"><br>          <code>5.2.2 三维轴向旋转矩阵</code></li><li>很容易可以发现，绕哪个轴旋转哪个轴的列不变，为1，这里涉及到之前提到过矩阵乘法，希望大家自己动手试一试，看看是不是这样。</li><li>细心的同学会发现了，有点小问题，为何中间的旋转矩阵右上方的sina 符号不太对？这是因为叉乘的性质，实际上，如果我们要得到一个现在图中的正方向的y我们需要用x叉乘z，这与其他两个方向正好相反（回顾左右手定则！）因此我们需要颠倒他们的符号。</li></ul><hr><h2 id="5-2-3-一般的三维旋转"><a href="#5-2-3-一般的三维旋转" class="headerlink" title="5.2.3 一般的三维旋转"></a>5.2.3 一般的三维旋转</h2><ul><li>我们会介绍三大方法，分别是欧拉角，矩阵法，四元数法，它们各有利弊。</li><li>1.<strong>欧拉角</strong></li><li>我们分别定义绕三个方向的旋转为ROll，Yaw，Pitch，这三个旋转方式，它们的任意组合就可以成为一个任意的旋转角度。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028092307.png" alt="image.png"><br>              <code>5.2.3 欧拉角旋转</code></li><li>Rxyz（a，β，γ） &#x3D;  Rx(α)Ry(β)Rz(γ)</li><li>但不可避免的会有一些问题，比如万向死锁，你可以浏览这个视频来了解<ul><li>【无伤理解欧拉角中的“万向死锁”现象】 <a href="https://www.bilibili.com/video/BV1Nr4y1j7kn/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Nr4y1j7kn/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li></ul></li></ul><hr><ul><li>2.<strong>矩阵法</strong>任意轴旋转：罗德里德斯公式</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526210933.png" alt="Pasted image 20240526210933.png"><br>          <code>5.2.3.1 罗德里德斯公式</code> </li><li>将该向量平移到原点后再变换</li><li>感兴趣的同学可以自行推导这个公式是如何产生的。这里放一下闫老师推导的过程。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/GAMES101_Lecture_04_supp_1.jpg" alt="GAMES101_Lecture_04_supp_1.jpg"><br>          <code>5.2.3.2 罗德里德斯公式的推导</code></li><li>依然有缺点，那就是矩阵蠕变，简单来说就是矩阵运算参数出现差错导致整个矩阵出现问题</li><li>3.<strong>四元数</strong></li><li>是一种便于做<strong>旋转差值</strong>的方法，抽象出第四位度的虚数轴。</li><li>这里不会详细展开，有兴趣的可以查看这个视频来了解<ul><li>【四元数如何控制物体旋转？】 <a href="https://www.bilibili.com/video/BV14t421h7M4/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV14t421h7M4/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li></ul></li></ul><hr><h1 id="5-3-视图变换和投影变换"><a href="#5-3-视图变换和投影变换" class="headerlink" title="5.3 视图变换和投影变换"></a>5.3 视图变换和投影变换</h1><h2 id="5-3-1-类比拍照的MVP变换"><a href="#5-3-1-类比拍照的MVP变换" class="headerlink" title="5.3.1 类比拍照的MVP变换"></a>5.3.1 类比拍照的MVP变换</h2><ul><li>在生活中，我们经常需要拍摄某些事物，可能是美丽的风景，也可能是人物，动物等等，拍摄的过程大致可以分为三步：<ul><li>将物体摆好位置——模型变换</li><li>调整好适合的角度——视图变换</li><li>将三维场景拍摄到二维照片中——投影变换</li></ul></li><li>以上就是图形学中最重要的将三维场景投射到二维画面中的操作——MVP矩阵。</li></ul><hr><h2 id="5-3-2-视图变换"><a href="#5-3-2-视图变换" class="headerlink" title="5.3.2 视图变换"></a>5.3.2 视图变换</h2><ul><li>第一步，定义相机，如果我们要定义一个摄像机，最基本的要素是什么？没错，是摄像机的位置，这就是第一个要素Position，随后我们要拍摄物体，那么我们要定义相机向何处看，这是第二个关键点，Look——at观看的视角方向，第三个关键点，我们如何规定相机的旋转呢？我们需要固定一个向上的方向来确定相机视图的旋转。</li><li>因此我们得出了相机的三要素——POSITION，LOOK_AT，以及UP</li><li>第二部，我们来思考如果要得到一张图像，我们具备了摄像机的这三个属性，如何让摄像机移动的同时物体也进行移动呢，最好的选择就是，将摄像机放在原点位置，我们还为其规定了上一步提到的两个属性：LOOK_AT和UP，分别是-Z以及Y，你会发现他们也是满足叉乘结果的。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030102821.png" alt="image.png"><br>                  <code>5.3.2 摄像机的位置与方向</code></li><li>如何将任意一点的摄像机移动到标准的观察位置呢？这就需要应用我们之前学到的矩阵了，我们需要先将摄像机移动到原点位置，再将视角方向和向上方向旋转到-z与y上。</li><li>这需要我们进行矩阵变换，之前在三维变换中我们已经了解过，矩阵的三维变换需要先平移后做其他的线性变换，那么看起来应该是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030103934.png" alt="image.png"><br>                      <code>5.3.2.1 视图变换矩阵</code></li><li>平移变换很好写，我们只需要让任意一个点乘以一个平移值为（-x,-y,-z）的其次平移阵就好了，看起来就像这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030104242.png" alt="image.png"><br>                  <code>5.3.2.2 视图变换中的平移变换</code></li><li>但接下来就不太好写了，我们如何将任意方向的轴旋转到固定的方向呢？这其实就要用到我们本节提到的新知识了，旋转矩阵是一个正交阵，如果你忘了正交阵是什么，回到第3讲中查看一下吧，我们继续，正交阵的特点是其转置等于逆，逆阵又是啥，逆阵相当于是反向的操作，也就是说我们只需要先整出来一个将确定方向的向量旋转到任意方向的矩阵就好了，这很好做，随后我们只需要将其转置，就可以得到我们需要的矩阵了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030104716.png" alt="image.png"><br>                  <code>5.3.2.3 正交矩阵的逆等于其转置</code></li><li>这样我们就完成了视图变换</li></ul><hr><h2 id="5-3-3投影变换"><a href="#5-3-3投影变换" class="headerlink" title="5.3.3投影变换"></a>5.3.3投影变换</h2><ul><li>投影变换分为两种：<ul><li>1.透视投影</li><li>2.正交投影</li></ul></li><li>两者的共同点都是将三维的视图投影到二维画面上的过程，两者之不同是在于后者正交投影没有所谓的透视效果，也就是近大远小的效果，我们分别来看，首先是正交投影</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008194030.png" alt="image.png"><br>                          <code>5.3.3 投影变换</code></li></ul><hr><ul><li>正交投影</li><li>正交投影模拟的是在摄像机距离物体无限远时，物体投射到摄像机屏幕上的效果，因为距离很远，因此就没有透视效果，可以看上图右图上的结果。</li><li>正交投影的操作是什么呢？实际上它是规定了空间中任意一个立方体的上下左右前后这三组平面，分别为TB，LR，以及NF(也被成为近，远裁剪平面)，其中NF不太好理解，因为我们是以右手坐标系为标准，因此实际上数值来讲F比N更小。（OpenGl中是左手坐标系）其F比N更大。</li><li>之后正交投影将其分别映射到位于原点的正则标准正方形（1^3）上，这就完成了正交投影的变换。</li><li>我们来看矩阵实现，很简单，我们需要做的事情是，首先，将这个立方体移动到原点位置，用的是一个平移矩阵，之后，我们将这个立方体缩放至标准大小也就是xy∈【-1,1】区间内。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030112934.png" alt="image.png"><br>                  <code>5.3.3.1 正交投影变换矩阵</code></li></ul><hr><ul><li>我们来看一下Unity里的正交投影和透视投影，正常移动摄像机对应的是透视投影，但当我们点到视口栏中的2D选项实际上就是正交投影。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030113840.png" alt="image.png"><br>                  <code>5.3.3.2 Unity中的正交投影</code></li></ul><hr><ul><li>透视投影变换</li><li>透视投影实际上与正交投影最大的区别就是，两条平行线在屏幕上看起来会变成相交的了，这其实比较容易理解，就像我们看火车轨道，街道尽头，我们都能指出它们相交的地方，也就是交点，这就是透视效应。</li><li>那么我们该如何理解透视投影呢？实际上做了些什么呢？我们可以这样理解，虽然与正交投影不同，透视投影远近平面是不一样大的，但我们可以在保证他们的远近比例关系情况下，将透视投影视椎体“挤压”成为一个正交投影的长方体视椎体，最后就可以用我们已经学会的正交投影来对其进行处理了。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030115420.png" alt="image.png"><br>                  <code>5.3.3.3 如何做透视投影？</code></li><li>通过我们初中学习的相似三角形知识，我们可以对这个过程进行一个分析，我们专注于y值，那么我们会发现如果要将f平面上方的点挤压到与n平面平行的点，我们就要考虑如下视图中相似三角形的关系：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241030115904.png" alt="image.png"><br>                  <code>5.3.3.4 NF平面的透视三角形关系</code></li><li>我们可以得到以下比例关系式：N&#x2F;Z &#x3D; Y’&#x2F;Y ，因此就可以推出Y’ &#x3D; N&#x2F;Z * Y</li><li>x的推理过程一模一样，不再赘述，最后得到X’ &#x3D; N&#x2F;Z * X</li><li>目前我们知道了XY变化的过程，对于Z任然不知道，但没关系，我们已经可以根据其它关系推导出完整的矩阵了，还记得之前我们怎么推导二维旋转矩阵的吗？欢迎各位跟我一起推导，下面放出我的手写推导过程</li><li>手推过程较长，各位只要细心观察一定能最后得到一样的结果。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/109b066181a02341a54c4424067c6a1.jpg" alt="109b066181a02341a54c4424067c6a1.jpg"><br>                  <code>5.3.3.5 MVP——透视投影矩阵推导过程</code></li><li>这样，经过这一个矩阵变换我们就可以得到位于裁剪空间下的物体坐标了。</li></ul><hr><h2 id="5-3-4-裁剪空间与裁剪平面"><a href="#5-3-4-裁剪空间与裁剪平面" class="headerlink" title="5.3.4 裁剪空间与裁剪平面"></a>5.3.4 裁剪空间与裁剪平面</h2><ul><li>前文我们提到过了裁剪平面这个概念，裁剪平面实际上就是摄像机能看到的空间范围，一共分为6个裁剪平面。在Unity中，我们可以通过调节Near与Far裁剪平面与摄像机视口的距离，来决定裁剪空间的大小。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117115043.png" alt="image.png"><br>  <code>5.3.4 unity中的摄像机组件</code></li><li>我们之前的工作，实际上就是将场景中的物体，通过一系列缩放，平移变换，映射到这个裁剪空间之中，何为裁剪？相信之前认真观察的同学能够留意到我们的第四维变量W，该变量实际上就是一个判断区间的范围。</li><li>如果物体顶点在这个裁剪范围，则会被保留，而若在这个裁剪范围外，则将会被剔除。我们来看一下详细的过程</li></ul><hr><ul><li>首先，不同空间对应的裁剪坐标范围不同，Unity使用的OPenGL裁剪空间的范围是【-z，z]。如果超出这个范围则将被剔除，这事就会有疑问，如何剔除呢？</li><li>我们会将物体分为几种类型，完全在裁剪空间内的，一半在裁剪空间内的，以及完全在裁剪空间外的。</li><li>接着我们会对其进行裁剪，对于一半处在裁剪空间内的边缘情况，我们将进行进一步的操作，划分三角形，对于三角形，我们根据其每个顶点与平面的位置关系来判断是否要裁剪它，若需要裁剪，则我们将边界作为一条新的边，与在边界内的三角形部分形成一个新的几何体。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117122542.png" alt="image.png"><br>  <code>5.3.4.1 裁切三角形</code></li></ul><hr><h2 id="5-3-5-其次除法与视口坐标映射"><a href="#5-3-5-其次除法与视口坐标映射" class="headerlink" title="5.3.5 其次除法与视口坐标映射"></a>5.3.5 其次除法与视口坐标映射</h2><ul><li>在完成上述的MVP变换后，我们就需要将图像呈现在屏幕上，在此之前，为了方便计算，我们会将XYZ三个量全部除以W，将其归一化到归一设备坐标（NDC）下。这样便于计算，接着，我们将单独提取这个立方体内的物体的x，y坐标，并将其变化到屏幕上，这个过程被称为视口坐标映射，同样也是利用矩阵操作完成的。我们对物体映射在屏幕上的像素坐标位置，是这么计算的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241117123246.png" alt="image.png"><br>  <code>5.3.5 其次除法与视口坐标映射</code></li><li>至此，我们就可以得到物体在屏幕像素上的位置了。不过就像我们在一开始所说的那样，这个映射方式在不同的API中定义并不相同，OPenGL直中与DX中是相反的，需要我们留意。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学4——变换1</title>
      <link href="/2024/12/04/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A64%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A21/"/>
      <url>/2024/12/04/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A64%E2%80%94%E2%80%94%E5%8F%98%E6%8D%A21/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-变换的定义与作用"><a href="#4-1-变换的定义与作用" class="headerlink" title="4.1 变换的定义与作用"></a>4.1 变换的定义与作用</h1><h2 id="4-1-1-什么是变换"><a href="#4-1-1-什么是变换" class="headerlink" title="4.1.1 什么是变换"></a>4.1.1 什么是变换</h2><ul><li>变换也称<strong>仿射变换或仿射映射</strong> ，是利用矩阵在空间中使物体发生<strong>运动</strong>的操作的总称。</li><li>包括诸如：平移，旋转，缩放，错切等。</li></ul><hr><h2 id="4-1-2-变换的种类与操作"><a href="#4-1-2-变换的种类与操作" class="headerlink" title="4.1.2 变换的种类与操作"></a>4.1.2 变换的种类与操作</h2><ul><li>变换大致分为<strong>模型变换和视图变换</strong>，前者是不改变坐标系，变换模型本身，而后者是变换坐标系。这一点孰优孰劣需要具体分析，但绝大多数场景下，我们使用变换坐标系的变换，因为这样可以忽略很多细节，提高性能。</li><li>而物体变换某个量相当于坐标系变换相反的量，这也不难理解，比如想要某个物体缩放0.5倍，其实就是将坐标系变大2倍，自然原本的物体尺寸就变为了原来的0.5倍：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027094935.png" alt="image.png"><br>                          <code>4.1.2  缩放变换</code></li></ul><hr><h1 id="4-2-二维的变换"><a href="#4-2-二维的变换" class="headerlink" title="4.2 二维的变换"></a>4.2 二维的变换</h1><h2 id="4-2-1-二维缩放"><a href="#4-2-1-二维缩放" class="headerlink" title="4.2.1 二维缩放"></a>4.2.1 二维缩放</h2><ul><li>首先我们来看一个最简单的变化也就是我们前文提到的<strong>二维缩放变化</strong>，基于之前我所学的矩阵乘法，我们很容易就可以得到以下结果</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191106.png" alt="Pasted image 20240524191106.png"><br>  <code>4.2.1  二维缩放矩阵</code></li><li>最后我们可以发现，结果就是 x‘ &#x3D; Sx * x ， y’ &#x3D; Sy * y</li></ul><hr><h2 id="4-2-2-二维反转"><a href="#4-2-2-二维反转" class="headerlink" title="4.2.2 二维反转"></a>4.2.2 二维反转</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191220.png" alt="image.png"><br>  <code>4.2.2 二维翻转矩阵</code></li><li>如上是一个二维翻转矩阵，我们可以很快判断出，实际上它是将x进行取反操作，y保持不变。</li><li>那么我们就可以得出来一个结论，谁乘1保持不变，谁就是旋转轴，因此，该矩阵实际上是按y轴进行翻转，那么你能给出一个绕x轴翻转的矩阵吗？相信很简单，只需要调换一下正负号就好了。</li></ul><hr><h2 id="4-2-3-二维切变"><a href="#4-2-3-二维切变" class="headerlink" title="4.2.3 二维切变"></a>4.2.3 二维切变</h2><ul><li>接下来我们看一个稍微复杂一点的变换，二维切变，这种变换方式比上述两种变换方式都要更难理解，但我们同样可以通过分析得出其操作方式。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027100428.png" alt="image.png"><br>                       <code>4.2.3 二维切变</code></li></ul><hr><ul><li>观察这个变化，你发现了什么呢？有如下几点：<ul><li>1.首先，这张图片的y坐标并没有任何变化</li><li>2.这张图片的底部x坐标也没发生变换</li><li>3.这张图片的顶部x坐标向x正方向移动了a个单位距离</li></ul></li><li>因此根据以上这些判断，我们可以得出，实际上x坐标变化了ay个单位，最大时y &#x3D; 1，因此最大变化a，实际上这是一条斜率为a的斜线。因此我们可以得出以下的矩阵：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191506.png" alt="Pasted image 20240524191506.png"><br>                       <code>4.2.4 二维切变矩阵</code></li></ul><hr><h2 id="4-2-4-二维旋转"><a href="#4-2-4-二维旋转" class="headerlink" title="4.2.4 二维旋转"></a>4.2.4 二维旋转</h2><ul><li>接下来我们来看一个更困难一点的操作——旋转，这里需要唤醒各位一点关于三角函数的知识，但放心，并不难，只需要细心观察，认真计算即可。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027101603.png" alt="image.png"><br>                       <code>4.2.4 二维旋转</code></li></ul><hr><ul><li>我们来一起推导一下这些个值都是如何得到的</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/4ba5a85a671b3d41773d3cd75137e8b.jpg" alt="4ba5a85a671b3d41773d3cd75137e8b.jpg"><br>                      <code>4.2.4.1 二维旋转矩阵的推导</code></li></ul><hr><ul><li>最后，我们就可以得到我们想要的二维旋转矩阵了，旋转值由我们来定，当然这是一个只限于原点的旋转，后续我们会继续扩充，使其可以绕任意轴向旋转。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524191724.png" alt="Pasted image 20240524191724.png"><br>                      <code>4.2.4.2 二维旋转矩阵</code></li></ul><hr><h2 id="4-2-5-线性变换"><a href="#4-2-5-线性变换" class="headerlink" title="4.2.5 线性变换"></a>4.2.5 线性变换</h2><ul><li>通过观察上述这几个变换，我们可以总结出一下规律</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524192227.png" alt="Pasted image 20240524192227.png"><br>                       <code>4.2.5 变换规律</code></li><li>我们称这种变换方式叫做线性变换。</li></ul><hr><h1 id="4-3-平移矩阵与其次坐标"><a href="#4-3-平移矩阵与其次坐标" class="headerlink" title="4.3 平移矩阵与其次坐标"></a>4.3 平移矩阵与其次坐标</h1><h2 id="4-3-1-为什么没有平移？"><a href="#4-3-1-为什么没有平移？" class="headerlink" title="4.3.1 为什么没有平移？"></a>4.3.1 为什么没有平移？</h2><ul><li>细心的同学肯定发现了，我们介绍了这些线性变换之中，竟然没有我们最常用也应该是最基础的变换，那就是平移变换，为什么没有呢？这是因为平移这个操作，很特殊。</li></ul><hr><h2 id="4-3-2-特殊的平移变换"><a href="#4-3-2-特殊的平移变换" class="headerlink" title="4.3.2 特殊的平移变换"></a>4.3.2 特殊的平移变换</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027104422.png" alt="image.png"><br>                      <code>4.3.2 二维平移操作</code></li><li>同样，我们试着去描述它，我们能否将其写作如上文所述的线性表达形式呢，尝试一下？可能很快就会给出结果了吧，答案是不行，我们只能用额外的矩阵操作表述这个平移变换</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027104607.png" alt="image.png"><br>              <code>4.3.2.1 引入平移变换的二维线性变换矩阵</code></li><li>这样虽然表示出来了，但并不美好，它是一个特殊的操作，计算机中我们不喜欢这样的特例，你需要花费更多的时间去记忆这些特例，太麻烦了，那么如何解决呢？数学家们为我们给出了答案那就是——其次坐标！</li></ul><hr><h2 id="4-3-3-其次坐标"><a href="#4-3-3-其次坐标" class="headerlink" title="4.3.3 其次坐标"></a>4.3.3 其次坐标</h2><ul><li>首先再次强调一下为何我们要引入其次坐标：<br>  Translation特殊，无法用线性变换完成，那么就要引入&#x3D;&#x3D;其次坐标&#x3D;&#x3D;</li><li>接下来介绍其次坐标，实际上其次坐标就做了一下的操作：<ul><li>通过增加维度来统一，&#x3D;&#x3D;点增加一个维度为1，向量为0&#x3D;&#x3D;</li><li>因为我们要通过原点坐标来描述向量或点在空间中的位置，而这个位置是固定不变的因此我们需要一个&#x3D;&#x3D;记录坐标信息的额外维度来扩充原有的矩阵&#x3D;&#x3D;</li></ul></li><li>我们来看一下其次坐标的推导过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/389cac6f69e60c21f265cd47f399d23.jpg" alt="389cac6f69e60c21f265cd47f399d23.jpg"></li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027105203.png" alt="image.png"><br>                      <code>4.3.3 其次坐标矩阵</code></li><li>铛铛！一个完美的描述矩阵完成了！它看起来很美好，不是吗？但我们也会发现增加了很多东西，正所谓 NO FREE LUNCH ! 因此我们也需要注意引入其次坐标带来的麻烦。</li></ul><hr><h2 id="4-3-4-个人思考"><a href="#4-3-4-个人思考" class="headerlink" title="4.3.4 个人思考"></a>4.3.4 个人思考</h2><ul><li>Q：为什么点是1而向量为0？</li><li>A：首先，这是一个区分向量和点的方式，这是他们不同的原因。向量之所以为0，是因为其有平移不变性，我们不希望对其进行平移操作时破坏这种不变性，因此为0。而点平移是会发生改变的，自然需要一个还原其本身意义的操作也就是将对点的操作×1，来保持这种操作的有效性。</li><li>同样，我们还可以利用这个特性，实现点与向量运算的性质，如下图，可以发现，实际上引入0,1能恰好使得运算得到的结果保持正确性：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027110952.png" alt="image.png"><br>                  <code>个人思考——为何其次坐标是这样的？</code></li></ul><hr><ul><li>而最后一项，点与点的加和，最后得到的其实是它们的中点，因为在二维变换中，实际上我们最后得到的应该是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241027111135.png" alt="image.png"><br>                  <code>个人思考——二维点的表述</code></li><li>1+1&#x3D;2 因此我们需要将这个点转换为一个标准的点，也就是将其额外的维度归为1，所以都除去w，最后发现实际上得到的就是这两个点的中点。</li></ul><hr><h2 id="4-3-5-其次矩阵"><a href="#4-3-5-其次矩阵" class="headerlink" title="4.3.5 其次矩阵"></a>4.3.5 其次矩阵</h2><ul><li>前文我们介绍了其次坐标，接下来我们就可以将矩阵改写为其次坐标的形式，也就是其次矩阵。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028082530.png" alt="image.png"><br>              <code>4.3.5 其次坐标下的其次矩阵</code></li><li>我们可以观察到他们有一些特点，比如最后一行都是001，比如变换都发生在右上角的位置。</li></ul><hr><h2 id="4-3-6-逆变换"><a href="#4-3-6-逆变换" class="headerlink" title="4.3.6 逆变换"></a>4.3.6 逆变换</h2><ul><li>逆矩阵就是逆变换</li><li>逆变换其实就是乘以一个逆矩阵来取消操作</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241028083652.png" alt="image.png"><br>              <code>4.3.6 逆变换</code></li></ul><hr><h2 id="在Processing中实践"><a href="#在Processing中实践" class="headerlink" title="在Processing中实践"></a>在Processing中实践</h2><p>我们通过Processing来实践这个变换，为了实现旋转缩放平移的统一，我们引入了其次坐标这个概念。 ^f256dd</p><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526162215.png" alt="Pasted image 20240526162215.png"></p><ul><li>在以上代码中，我们通过Processing内部封装的translate函数，通过改变变化基准坐标也就是改变坐标系的值，让方块进行运动，但实际上我们并没有改变方块本身的值：</li><li>如果左乘变换矩阵（算子），那么我们就在改变物体自身的值，而没有改变坐标，而如果我们右乘，就是上图的translate函数所做的，那就是改变坐标（坐标原点）。可在给出的源码中查看动态效果，这个方块在做循环往复的周期平移！</li></ul><hr><p>Scale矩阵如下</p><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524194857.png" alt="Pasted image 20240524194857.png"></li></ul><hr><h2 id="在Processing中实践-1"><a href="#在Processing中实践-1" class="headerlink" title="在Processing中实践"></a>在Processing中实践</h2><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526170525.png" alt="Pasted image 20240526170525.png"></p><ul><li>在以上代码中，我们通过Processing内置的Scale函数，对图形进行缩放。你可以找到对应的源码来观看实际的缩放动画，它是一组连续缩放的画面。</li></ul><hr><ul><li>Rotation矩阵如下</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524194915.png" alt="Pasted image 20240524194915.png"><br> ^165e7f</li></ul><hr><ul><li>效果图展示：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526204919.png" alt="Pasted image 20240526204919.png"></li></ul><hr><ul><li>源码展示：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240526204941.png" alt="Pasted image 20240526204941.png"></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学3——变化的基础</title>
      <link href="/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/11/17/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A63%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1矩阵"><a href="#3-1矩阵" class="headerlink" title="3.1矩阵"></a>3.1矩阵</h1><h2 id="3-1-1-矩阵的定义"><a href="#3-1-1-矩阵的定义" class="headerlink" title="3.1.1 矩阵的定义"></a>3.1.1 矩阵的定义</h2><ul><li>矩阵就是二维的向量数组。</li><li>矩阵是由c列维度为R的向量组成的，我们标记一个矩阵的方法是标记它的行与列也就是Mr×c。</li><li>如下这是一个二行三列的矩阵：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026103749.png" alt="image.png"><br>          <code>3.1.1 一个二行三列矩阵</code></li><li>在计算机图形学中，我们经常利用矩阵来进行空间的变换，通过其与向量进行计算来变化空间。</li></ul><h2 id="3-1-2-方阵与对角单位阵"><a href="#3-1-2-方阵与对角单位阵" class="headerlink" title="3.1.2 方阵与对角单位阵"></a>3.1.2 方阵与对角单位阵</h2><ul><li>当矩阵的行与列相同时，我们称其为方阵，可用n来直接代表其维数，一个方阵也就是n×n维的矩阵。</li><li>更特殊一点，如果一个方阵的其他非对角元素均为0，对角元素为1，那么我们就称其为单位阵，单位阵在矩阵运算中充当着与实数运算中1相当的地位，也就是<strong>任何矩阵乘以单位阵</strong>得到的还是原矩阵（前提是它们能相乘）。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104332.png" alt="image.png"><br>          <code>3.1.2 一个单位阵</code></li></ul><h2 id="3-1-3-相等矩阵与转置矩阵"><a href="#3-1-3-相等矩阵与转置矩阵" class="headerlink" title="3.1.3 相等矩阵与转置矩阵"></a>3.1.3 相等矩阵与转置矩阵</h2><ul><li>判断一个矩阵相等的前提是，首先它们的维数相同，其次，它们逐行逐列对应的元素均相同，由此我们判断两个矩阵相等。</li><li>转置是一个操作，简单来说就是将矩阵的行与列交换，也就是第一行元素变成第一列元素，第一列元素反之变为第一行元素。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026104648.png" alt="image.png"><br>          <code>3.1.3 矩阵的转置</code></li><li>转置我们用上标T来表示，一个矩阵转置的转置就等于其本身，单位阵的转置也等于其本身。</li></ul><h1 id="3-2-矩阵的运算"><a href="#3-2-矩阵的运算" class="headerlink" title="3.2 矩阵的运算"></a>3.2 矩阵的运算</h1><h2 id="3-2-1-矩阵的数乘与加法"><a href="#3-2-1-矩阵的数乘与加法" class="headerlink" title="3.2.1 矩阵的数乘与加法"></a>3.2.1 矩阵的数乘与加法</h2><ul><li>矩阵的数乘很简单，因为矩阵某些性质与向量类似，因此矩阵的数乘实际上就是每一行每一列都乘上这个数。</li><li>矩阵的加法就是每一行每一列对应的元素相加，而其前提是它们的维数相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026110956.png" alt="image.png"><br>          &#96;3.2.1 矩阵的加法</li></ul><h2 id="3-2-2-矩阵的乘法"><a href="#3-2-2-矩阵的乘法" class="headerlink" title="3.2.2 矩阵的乘法"></a>3.2.2 矩阵的乘法</h2><ul><li>矩阵乘法的前提是两个矩阵的行列对应相等，也就是Ac &#x3D; Bc &amp;&amp; Ar &#x3D; Br</li><li>其方法就是第一个矩阵的行乘以第二个矩阵的列，然后将其对应元素相加作为新矩阵的元素</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026111922.png" alt="image.png"><br>          <code>3.2.2 矩阵的乘法</code></li><li>如下面这个例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112057.png" alt="image.png"><br>          <code>3.2.2.1 矩阵乘法实例</code></li><li>因此作为矩阵乘法，其并不满足乘法的交换律，因为如果交换就会发生行列不相等的情况<ul><li>AB !&#x3D; BA</li></ul></li><li>同样的如果AB &#x3D; AC 不意味着 B &#x3D;C，但矩阵满足乘法结合律，如下</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026112751.png" alt="image.png"><br>      <code>3.2.2.2 矩阵满足乘法结合律</code></li></ul><h2 id="3-2-3-行列式与逆阵"><a href="#3-2-3-行列式与逆阵" class="headerlink" title="3.2.3 行列式与逆阵"></a>3.2.3 行列式与逆阵</h2><ul><li>行列式的定义<ul><li>行列式是方阵M对应的一个标量，记作|M|</li><li>行列式的计算：<ul><li>余子式与代数余子式<ul><li>我们通过观察行列式的求解可发现，实际上它是由一个个代数余子式相加得来的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026114721.png" alt="image.png"><br>     <code>3.2.3 矩阵的余子式求解</code></li><li>观察上图，实际上我们会发现余子式就是该元素乘上去除掉该元素所在的那一行和那一列后组合而成的矩阵。</li></ul></li></ul></li><li>矩阵转置的行列式等于原矩阵的行列式</li></ul></li><li>行列式的几何意义<ul><li>二维行列式的几何意义代表以基向量为两边构造的平行四边形的有符号面积</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026121109.png" alt="image.png"><br>          <code>3.2.4行列式的几何意义</code></li><li>在三维中，行列式的几何意义是以基向量为三边的平行六面体的有符号面积。</li></ul></li><li>逆矩阵<ul><li>逆矩阵是只有方阵才具备的性质，它本质上是说明一个方阵与另一个方阵的乘积为1，这两个方阵互为逆阵。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123201.png" alt="image.png"><br>                  <code>3.2.3.1 逆矩阵计算的举例</code></li></ul></li><li>判断是否可逆<ul><li>判断一个矩阵是否可逆需要检测矩阵行列式的值，一个具有逆矩阵的矩阵其行列式不为0，反之则为0。</li></ul></li><li>求解逆阵<ul><li>这里就需要利用我们之前学习到的求矩阵代数余子式的方式，先求出矩阵的代数余子式，并用其组成一个新的矩阵，我们称其为伴随阵，随后将伴随阵除以行列式的值即可得到矩阵的逆阵</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026123823.png" alt="image.png"><br>                  <code>3.2.3.2 求解一个矩阵的逆阵</code></li></ul></li><li>逆阵的应用<ul><li>逆阵往往被用于执行反向操作上，因为它可以将其逆阵转化为单位阵，也就是最后得到1，可视为取消操作。</li></ul></li></ul><h2 id="3-2-4-正交阵"><a href="#3-2-4-正交阵" class="headerlink" title="3.2.4 正交阵"></a>3.2.4 正交阵</h2><ul><li>定义：如果一个矩阵的转置（MT） 等于这个矩阵的逆，那么我们就称其为正交阵。</li><li>这个性质在以后得求矩阵逆的应用上非常方便，因为矩阵逆很难求，就像上面说的那样，因此如果知道该矩阵是个正交阵，那么我们可以直接求其转置，转置开销很小，所以就进一步优化了性能，简化了计算！</li></ul><hr><h1 id="3-3向量与矩阵"><a href="#3-3向量与矩阵" class="headerlink" title="3.3向量与矩阵"></a>3.3向量与矩阵</h1><h2 id="3-3-1-行向量与列向量"><a href="#3-3-1-行向量与列向量" class="headerlink" title="3.3.1 行向量与列向量"></a>3.3.1 行向量与列向量</h2><ul><li>向量其实就是单维度的矩阵，比如一个行向量其实就一个1×n的矩阵，一个列向量实际上就是n×1的矩阵。它们是可以与矩阵进行运算的，但为了使其运算有意义，矩阵的位置很重要，比如行向量只能在矩阵的左侧，而列向量则只能在矩阵的右侧</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026130105.png" alt="image.png"><br>                   <code>3.2.3.3 两个向量相乘为矩阵</code></li><li>所以实际上，结果向量的每一个元素，都是元向量与矩阵中单独行列的点积。</li><li>行向量左乘矩阵必为行向量，而列向量右乘矩阵必为列向量</li></ul><h2 id="3-3-2-矩阵的几何意义"><a href="#3-3-2-矩阵的几何意义" class="headerlink" title="3.3.2 矩阵的几何意义"></a>3.3.2 矩阵的几何意义</h2><ul><li><p>我们前文提到了基向量这个概念，其实坐标系就是用基向量来进行表示的，我们已经强调过了矩阵实际上最大的作用就是改变空间坐标，那么究竟是如何改变的呢？</p></li><li><p>实际上每个向量都可以写作基向量的形式，而不同空间的基向量组成不同，但它们都有一个特点，那就是它们之间线性无关（也就是不在一个平面上）</p></li><li><p>矩阵乘以向量，实际上就是对这个向量的基向量进行的点乘变化</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241026131455.png" alt="image.png"><br>                  <code>3.3.2 一个缩放矩阵</code></p></li><li><p>所以综上所述，矩阵与向量相乘，实际上就是对向量的基向量进行变化，又因为向量的基向量决定一个空间，因此实际上就是将一个向量，从一个空间变换到了另一个空间。</p></li><li><p>至此，我们完成了基本上所有的线性代数方面的学习，接下来就是去实际应用了，我们将会看到矩阵的实际作用，包括但不限于上述的例子。</p></li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学2——位置与方向</title>
      <link href="/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/"/>
      <url>/2024/11/15/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A62%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-点"><a href="#2-1-点" class="headerlink" title="2.1 点"></a>2.1 点</h1><ul><li>在上一节我们讲到，<strong>坐标系</strong>是图形学以及数学物理学等等学科中非常重要而基本的概念</li><li>坐标系又是有一系列<strong>离散</strong>的点（离散就是分散开的不连续的）组成的。</li><li>那么在这里我们就可以很简单的定义点：</li></ul><h2 id="2-1-1-点的定义"><a href="#2-1-1-点的定义" class="headerlink" title="2.1.1 点的定义"></a>2.1.1 点的定义</h2><ul><li>图形学中<strong>点</strong> 是坐标系中的一个<strong>位置，同时也是一个数组，记录这这个点所代表的值</strong>我们称为<strong>坐标</strong></li><li>点具有数值，维度这两个特征，并且是唯一的。</li></ul><hr><h1 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h1><h2 id="2-2-1-物理学家眼里的向量"><a href="#2-2-1-物理学家眼里的向量" class="headerlink" title="2.2.1 物理学家眼里的向量"></a>2.2.1 物理学家眼里的向量</h2><ul><li>在物理学中，向量也被称为矢量，它更多是描述一种<strong>运动</strong>，包含了运动的<strong>速度和方向</strong>，它的位置是没有意义的，可以在任何位置出现，下面是一个简单的例子</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113238.png" alt="image.png"><br>                      <code>2.2.1物理学家眼中的向量</code></li><li>这是一个三维空间里的向量分布，可以看出它们仅仅代表着不同的方向以及长度大小，它们的颜色值是根据数值对应的RGB颜色计算出来的（就像我们上节课所了解到的）</li><li>这是一种理解方式，但计算机学家眼中，还有另一种理解。</li></ul><h2 id="2-2-2-计算机学家眼里的向量"><a href="#2-2-2-计算机学家眼里的向量" class="headerlink" title="2.2.2 计算机学家眼里的向量"></a>2.2.2 计算机学家眼里的向量</h2><ul><li>计算机学家眼中，向量与物理学家眼中的不太相同，我们更多只在意它的<strong>数值特征</strong>，毕竟计算机的根本就是一组一组的数据运算（详细可在计算机基础入门中了解）</li><li>因此在他们眼里，向量也许是这样的：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023113747.png" alt="image.png"><br>                   <code>2.2.2 计算机学家眼中的向量</code></li><li>在这个例子中，我们记录的两个数本身有自身所代表的含义，而我们却忽略了其位置，毕竟一个房屋的售价和平米而言，位置信息对他们是无效的。</li><li>而数学家却尽力概括这两个观点，他们就提出了我们所学习到的数学上对向量的定义</li></ul><h2 id="2-2-3-向量的定义"><a href="#2-2-3-向量的定义" class="headerlink" title="2.2.3 向量的定义"></a>2.2.3 向量的定义</h2><ul><li><strong>向量是在坐标系下，以原点为起点的有一定距离的有向线段。</strong></li><li>本质上它们表示的是两点之间的<strong>差异，或者说是一个点如何变化到另一个点的指示。</strong></li><li>向量与点类似，同样具备两个特征，那就是<strong>方向（所指的角度）以及大小（它的长度）</strong></li><li>在计算机中，向量往往作为变化的一种手段，我们可以利用它进行物体或者数值的变换，这种变换是对于坐标系而言的。</li></ul><h2 id="2-2-4-基本的向量的运算"><a href="#2-2-4-基本的向量的运算" class="headerlink" title="2.2.4 基本的向量的运算"></a>2.2.4 基本的向量的运算</h2><ul><li><strong>点与向量的运算</strong><ul><li>点的减法运算<ul><li>向量是两点只差，有了这个根据我们就可以通过两点位置的计算来表示一个向量，比如从P点到O点的运动方式，我们就可以理解为一个向量，让我们表示它！</li><li>O(Ox，Oy) - P(Px，Py) &#x3D; Vpo</li><li>我们一定要从几何直观上理解它，就像这样：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023115903.png" alt="image.png"><br>                   <code>2.2.4 点与向量的运算</code></li></ul></li><li>点的加法运算<ul><li>实际上我们已经可以描述点的加法运算了，它本质上只是减法的逆运算，因此我们可以描述P到O的运算，就像这样：</li><li>P(Px，Py) + Vop &#x3D; (Ox，Oy) </li><li>描述的实际上还是这个过程，很容易理解。</li></ul></li></ul></li></ul><hr><ul><li><strong>向量之间的运算</strong><ul><li>向量与向量的<strong>加法</strong><ul><li>向量之间的加法本质上也可以用过<strong>点</strong>来定义，因为前文告诉我们实际上向量也是由点来表述的，因此我们可在二维坐标系下，定义一个向量的加减法，就像我们定义点与向量的运算一样</li><li>点P(Px，Py) ，(Ox，Oy) ，Q(Qx,Qy) </li><li>向量：O(Ox，Oy) - P(Px，Py) &#x3D; Vpo，Q(Qx，Qy) - P(Px，Py) &#x3D; Vpq</li><li>所以<ul><li>Vpo + Vpq &#x3D; O(Ox，Oy) - P(Px，Py) +Q(Qx，Qy) - P(Px，Py)<br>  &#x3D; (Ox+Qx - 2Px,Oy + Qy - 2Py)</li></ul></li><li>计算很简单，但我们如何去描述它呢，实际上它让我们做了什么？</li><li>前文提到，计算机中向量的运算实际上就是改变一个数的值，我们完成的实际上是一个全局尺度的变换。</li><li>从P出发我们先到了O，此时如果用我们上面的值来表示（Px + Ox - Px，Py+ Oy - Py）最后运算得到的就是O点，而后我们再向着Vpq所代表的方向运动那就是（Ox + Qx -Px，Oy + Qy - Py)。为何与上面的结果有所不同？</li><li>细心地同学会马上指出，你求得的结果是个点啊！</li><li>没错，我们上面推导的实际上是对于一个点而言的变化，而前面所推的则是向量的加减法。他们有什么区别？没错，因为向量是忽略位置而只是一个操作，所以我们没有加上最开始的点坐标。而他们之间其实就是这个差别。</li><li>由此我们系统的论证了为何向量是指示一个点到另一个点的变化。这种加法法则也被称为向量的四边形法则：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023131800.png" alt="image.png"><br>                 <code>2.2.4.1向量的四边形法则</code></li></ul></li></ul></li></ul><hr><ul><li><strong>向量的数乘</strong><ul><li>向量的数乘实际上并不难理解，数乘可以看做一个缩放操作，是只对于向量的数值大小进行的变化</li><li>但同样会有一个例外：如果乘数是个负数，那么就会导致向量变化为反方向的一个新向量，相当于向反方向进行缩放。</li></ul></li><li><strong>向量的模</strong><ul><li>向量的模|a|其实就是描述向量长度的方式，这个需要运用一定的勾股定理去理解，实际上我们是将向量的分量作为描述模的方式也就是<ul><li>|a|  &#x3D; √ Ax^2 + Ay^2</li></ul></li></ul></li><li><strong>向量的归一化</strong><ul><li>向量的归一化是保留向量方向信息而忽略其长度信息的一种操作。比如在计算光线与法线的过程中，我们只需要知道方向信息就可以了，而过多的信息会造成数据存储的浪费，而如何进行这个操作呢</li><li>我们观察模的定义，会发现，如果我们想让模为1，实际上只需要将一个向量的每一个值除以他们的模，这是个很巧妙的数学方法</li></ul></li><li><strong>基向量</strong><ul><li>现在，我们终于可以介绍这个概念了，基向量是我们描述一个坐标系的方式，往往一对或几对相互垂直的基向量使我们定义一个基本的坐标系空间的方式，他们的特点是：模长为1，方向相互垂直，本质上是便于我们通过这个向量，来描述其他向量。如我们之前的Vpo向量就可以写成：<ul><li>Vx &#x3D; （Ox - Px）* Xi ， Vy &#x3D; （Oy - Py ）* Yi</li></ul></li><li>这样做什么好处，好像根本没有什么变化啊！？毕竟模长是1乘上去压根不会有什么变化</li><li>实际上，这就是我们本次课或者说图形学最终的运行逻辑。就是通过变换基向量来进行空间的变换。试想一下，如果变换每一个向量每一个点来转换一个模型是不是会很麻烦？</li><li>那么如果我们变换基向量本身呢？没错，这样的话我们就可以很简单的将一个空间理所应当的改变为另一个空间了，而不用变换里面的每一个点。因为点本身就是这些基向量形成的，本质只是数乘而已。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241023144002.png" alt="image.png"><br>              <code>2.2.4.2 三个基向量张成一个向量空间</code></li></ul></li><li><strong>向量的乘法</strong><ul><li>点积<ul><li>点积是向量与向量相乘的结果，它最后得到的是一个数，公式如下<ul><li>a·b  &#x3D; axbx + ayby</li></ul></li><li>点积不但可以描述角度信息也可以描述一个向量再另一个向量方向上的投影长度<ul><li>a·b &#x3D; |a||b|cos&lt;a,b&gt;</li></ul></li><li>通过这个公式我们可以快速得出a，b之间夹角值，以及ab的大致方向判断。</li></ul></li><li>点积的特性使我们可以利用它将一个向量分为水平方向和垂直方向的分向量，为我们后期描述向量之间的关系提供了一个有力手段。</li><li>点积的实际应用：<ul><li>比如在计算光线与物体法线的关系中，我们就可以通过点积运算快速得出一个物体的受光信息：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"><br>                  <code>2.2.4.3 点积的应用——判断着色</code></li></ul></li><li>叉积<ul><li>叉积是向量之间的另一种运算，不同的是，它只适用于3维计算，它得到的不是一个数而是一个向量。<ul><li>a×b &#x3D; 【aybz - azby，axbz - azbx，axby - aybx】</li><li>axb &#x3D; （aybz - azby）x +（axbz - azbx）y +（axby - aybx）z</li></ul></li><li>叉积描述的是一个垂直于相乘的两个向量所构成平面的向量，因此往往应用于求解法向量。</li><li>叉积同样可以描述两个向量之间的角度关系<ul><li>a×b &#x3D; |a||b|sin&lt;a,b&gt;</li></ul></li><li>但需要注意的是，叉积可能会存在两个不同结果，这显而易见，因为垂直于ab平面的向量有两个，如何去判别他们呢？</li><li>我们可以通过平移向量使他们首尾相连，并判断是顺时针还是逆时针方向，通过左右手坐标系来判别他们的方向</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104047.png" alt="image.png"><br>                  <code>2.2.4.4 叉积存在两个方向 </code></li></ul></li><li>叉积的应用<ul><li>判定左右</li><li>前文我们提到，叉积有两个方向，并且我们可以根据方向的不同判定原始向量的旋向性，那么由此，我们就可以判断这两个向量之间的左右关系了，比如顺时针的方向排布，b在a的左边</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025115422.png" alt="image.png"><br>                  <code>2.2.4.5 插件的应用——判断左右</code></li><li>判断内外</li><li>这是一个很重要的应用那就是判断一个点是否在三角形内，这会在我们后续的<strong>光栅化</strong>阶段应用。我们可以依次连接一点与一个三角形顶点，并将其作为一个向量与三角形顶点组成的向量做叉积，如果三个顶点判断都为同一侧(左侧或者右侧)我们就将其判定为在三角形内，并渲染这个点到屏幕上。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025120903.png" alt="image.png"><br>                  <code>2.2.4.6叉积的应用——判断内外</code></li></ul></li></ul></li></ul><hr><h2 id="进阶2-3-在Processing中实践"><a href="#进阶2-3-在Processing中实践" class="headerlink" title="进阶2.3 在Processing中实践"></a>进阶2.3 在Processing中实践</h2><h2 id="2-3-1-向量加减法的直观实现"><a href="#2-3-1-向量加减法的直观实现" class="headerlink" title="2.3.1 向量加减法的直观实现"></a>2.3.1 向量加减法的直观实现</h2><p>我们通过Processing来定义两个向量构造函数，在Processing中我们进行如下定义，首先我们需要定义一个Pvector基类来实现向量，如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162520.png" alt="Pasted image 20240524162520.png"></p><p>在这些代码中，我们分别创建了三个向量对象，并且为他们赋值，让他们分别在xy上有了对应的值，因此我们可以在ellipse这个函数之中传入我们创建的对象的值，这样，我们就可以在想对应的坐标处为中心，创建圆形，add参数本质上就是将向量的对应坐标相加，得到v3的值。</p><hr><p>效果如下：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524162856.png" alt="Pasted image 20240524162856.png"></p><hr><h2 id="2-3-2-点乘的直观实现"><a href="#2-3-2-点乘的直观实现" class="headerlink" title="2.3.2 点乘的直观实现"></a>2.3.2 点乘的直观实现</h2><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164159.png" alt="Pasted image 20240524164159.png"></p><hr><p>同样，我们在其中使用dot函数，就可以进行点乘。我们还是定义两个向量，并且传入两个向量的位置，调用line绘制两条线段，而后，我们将v2标准化，也就是作为1，并且我们将标准化后的v2，作为值与v1进行点积，实际上我们得到的就是v1在v2上的投影，而后我们将v2乘上这个投影，并且绘制，就可以得到如下图形：<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524164140.png" alt="Pasted image 20240524164140.png"></p><hr><h2 id="2-3-3向量叉乘的直观实现："><a href="#2-3-3向量叉乘的直观实现：" class="headerlink" title="2.3.3向量叉乘的直观实现："></a>2.3.3向量叉乘的直观实现：</h2><p>叉乘本质上就是先进行两个向量的标准化，也就是与基向量点乘，而后，将它们赋值给一个新的向量。这个新的向量就是标准化之后的向量。</p><p>我们来看一下它的实现<br><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524183848.png" alt="Pasted image 20240524183848.png"></p><p>首先我们新建两个变量，然后在中心位置新建一个点，我们在这个点为基准，绘制两条支线，然后以这两条支线为基准，使用叉乘函数生成我们的第三条线段，它是垂直于另外两条线段的，然后我们将它标准化，也就是除以模长，之后，绘制：效果如下图：</p><hr><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240524184007.png" alt="Pasted image 20240524184007.png"></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>游戏开发入门——数学和物理 徐芝琦等著</li><li>UnityShaderLab新手宝典 唐福幸著</li><li>Shader开发实战 KyleHalladay著 郭华丰 韦静译</li><li>DirectX12 3D游戏开发实战（龙书）Frank D.Luna 著 王臣译</li><li>【【官方双语&#x2F;合集】线性代数的本质 - 系列合集】 <a href="https://www.bilibili.com/video/BV1ys411472E/?p=2&share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1ys411472E/?p=2&amp;share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>Fundamental Of ComputerGraphics（虎书）by Steve Marschner</li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——8</title>
      <link href="/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/"/>
      <url>/2024/11/08/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%948/</url>
      
        <content type="html"><![CDATA[<h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>数据逻辑节点：Ue中常用的数据选择节点有：switch，if节点等，我们可以简单利用这些节点对数据进行简单的判断。</li></ul><h1 id="switch节点"><a href="#switch节点" class="headerlink" title="switch节点"></a>switch节点</h1><ul><li>我们可以利用ue中的switch节点进行一些数据运算的判断，可以输入两个数据以及一个判断数据，来在外部创建选项进行数据的切换。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017131843.png" alt="image.png"></li></ul></li></ul><h1 id="if-节点"><a href="#if-节点" class="headerlink" title="if 节点"></a>if 节点</h1><ul><li>我们可以使用if节点进行一些简单的逻辑判断，比如a是否大于b或相反，这些在进行一些需要判断范围或者蒙版遮罩比较适用。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132235.png" alt="image.png"></li></ul><hr><h1 id="常用的数学运算节点"><a href="#常用的数学运算节点" class="headerlink" title="常用的数学运算节点"></a>常用的数学运算节点</h1><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241017132429.png" alt="image.png"></p><ul><li>以上是Ue中常用的三个数学计算节点，分别为点积，叉积，以及归一化运算，其相关的数学基础比较容易，在此就不赘述，各位谨记，实际上颜色也是数据，是向量组成的矩阵，对其进行操作就是进行向量的运算。</li></ul><h2 id="点积运算"><a href="#点积运算" class="headerlink" title="点积运算"></a>点积运算</h2><ul><li>点积运算本质是判断两个向量的方向关系，方向不同点积的结果也不同。这里给出基本的点积运算逻辑：<br>               A · B &#x3D; |A|B|cos(a,b)  </li><li>从公式可以看出，得到的结果存在一个ab的夹角的余弦值，我们可以利用这个值进行一些条件判断或者效果制作。</li></ul><h2 id="叉积运算"><a href="#叉积运算" class="headerlink" title="叉积运算"></a>叉积运算</h2><ul><li>差集运算本质是已知两个向量求第三个与这两个向量所在平面垂直的向量方向，因此我们可以利用这两个向量得出第三个向量的方向，在判断一点与三角形位置关系的时候经常使用，以下是叉积的运算逻辑：<br>               A×B &#x3D; |A||B|sin(a,b)</li><li>从公式可以看出实际上与它们垂直的第三个向量的长度在数值上等于以a，b，夹角为θ组成的平行四边形的面积。<br>               |c|&#x3D;|a×b|&#x3D;|a||b|sin&lt;a，b&gt;</li></ul><h2 id="归一化运算"><a href="#归一化运算" class="headerlink" title="归一化运算"></a>归一化运算</h2><ul><li>归一化往往是在简化运算方面进行的，有些时候我们只需要向量的方向信息而忽略它的位置信息，这时候我们就可以使用归一化操作，忽略它的具体位置信息而保留它的方向，让其模长为1。以下是归一化运算逻辑<br>                     B&#x2F;|B|</li><li>去除其长度信息，只保留其方向信息</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学1——基本概念</title>
      <link href="/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/11/08/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A61%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1画布与坐标系"><a href="#1-1画布与坐标系" class="headerlink" title="1.1画布与坐标系"></a>1.1画布与坐标系</h1><h2 id="1-1-1画布的定义"><a href="#1-1-1画布的定义" class="headerlink" title="1.1.1画布的定义"></a>1.1.1画布的定义</h2><ul><li>画布实际上可以理解为显示到屏幕上的画面，是一个像素矩阵，无论是3D场景抑或是2D场景，最后都要通过画布来呈现</li><li>画布可以使用一个函数（会在编写着色器时遇到它）它接受一个坐标值，并绘制一个颜色。</li></ul><hr><h2 id="1-1-2-坐标系"><a href="#1-1-2-坐标系" class="headerlink" title="1.1.2 坐标系"></a>1.1.2 坐标系</h2><ul><li>坐标系量化排布数值的方式。我们这里讨论的主要是屏幕坐标系，在不同的平台坐标系的定义不一样，但它们都应该具备几个基本特征：<ul><li>坐标轴</li><li>原点</li><li>轴距</li></ul></li><li>比如在OpenGL中坐标是这样的，y轴正方向向上</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145259.png" alt="image.png"><br>                      <code>1.1.2.1 OpenGL坐标系</code></li></ul><hr><ul><li>而在DirectX中，坐标轴是这样的：<br>*<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022145422.png" alt="image.png"><br>                      <code>1.1.2.2 DirectX坐标系</code></li><li>我们可以通过变化轴来进行坐标系的变化。</li></ul><hr><h2 id="1-1-3-左右手坐标系"><a href="#1-1-3-左右手坐标系" class="headerlink" title="1.1.3 左右手坐标系"></a>1.1.3 左右手坐标系</h2><ul><li>在计算机软件中，我们常常会接触到判断物体坐标系的情况，最常用的两个坐标系分别是左手坐标系和右手坐标系，它们最大的不同就是它们所对应的x轴方向不同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104607.png" alt="image.png"><br>          <code>1.1.2.3 左右手坐标系</code></li></ul><hr><ul><li>区别两个坐标系的方式是考虑他们的旋向性，两个坐标系无法通过旋转重合。</li><li>如Unity使用的就是左手坐标系，它的特点是x轴向右。我们可以通过左右手法则来判断左右手坐标系</li><li>左手坐标系下旋转方向是顺时针的，而右手法则下旋转方向是逆时针的，对应的大拇指的方向也是垂直方向同样是不一样的</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241025104937.png" alt="image.png"><br>          <code>1.1.2.4 左右手法则</code></li></ul><hr><h1 id="1-2-色彩与色彩空间"><a href="#1-2-色彩与色彩空间" class="headerlink" title="1.2 色彩与色彩空间"></a>1.2 色彩与色彩空间</h1><h2 id="1-2-1色彩的感性理解"><a href="#1-2-1色彩的感性理解" class="headerlink" title="1.2.1色彩的感性理解"></a>1.2.1色彩的感性理解</h2><ul><li>色彩的<strong>冷暖，色彩的对比度，色彩的饱和度，色彩的色相</strong></li></ul><h2 id="1-2-2色彩的理性理解"><a href="#1-2-2色彩的理性理解" class="headerlink" title="1.2.2色彩的理性理解"></a>1.2.2色彩的理性理解</h2><ul><li>由<strong>光源产生的光线</strong>，进入人眼，在人眼细胞产生一系列化学反应，信号传入大脑，最终形成感知</li></ul><hr><h2 id="1-2-3光源的定义"><a href="#1-2-3光源的定义" class="headerlink" title="1.2.3光源的定义"></a>1.2.3光源的定义</h2><ul><li>**发出光线的物体</li><li>光的波长：<ul><li>理论上是无穷大的，人眼的<strong>可见光范围</strong>决定了我们对其颜色的定义。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120443.png" alt="image.png"><br>                       <code> 1.2.3.1 光波总览</code></li></ul></li></ul><hr><ul><li>如何去<strong>定量</strong>描述光？<ul><li>光实际上是<strong>波</strong>，波形可以叠加，我们通过<strong>功率单位</strong>（流明，瓦数等）描述。</li><li>分光光度计：通过分光后对波长进行感知，最终得知光能量集中在550nm区域（图中绿色区域）</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022120750.png" alt="image.png"><br>                      <code>1.2.3.2 人眼可见光范围</code></li></ul></li></ul><hr><h2 id="1-2-4-光传播的方式"><a href="#1-2-4-光传播的方式" class="headerlink" title="1.2.4 光传播的方式"></a>1.2.4 光传播的方式</h2><ul><li>基本的传播方式：<ul><li><strong>直射，折射，反射，</strong> 光线追踪方式</li></ul></li><li>反射过程中，光的<strong>能量会减少，因为材质吸收了一定能量的光</strong>而吸收了某种颜色的光就代表人眼<strong>无法再看到这部分光。</strong><br>因此我们能看到的就是它们<strong>补集</strong>，也就是反射出的光</li></ul><hr><h2 id="1-2-5-光源的接受者"><a href="#1-2-5-光源的接受者" class="headerlink" title="1.2.5 光源的接受者"></a>1.2.5 光源的接受者</h2><ul><li>光源的接受者实际上是摄像机视图，但最终呈现给的是人眼</li><li>关于人眼的HDR：人眼可以调节自动曝光，分辨出高亮度的区域中不同亮度层次的区域。</li><li>人眼感知色彩的细胞主要分为杆状细胞和锥状细胞<ul><li>前者主要负责对亮度的感知</li><li>后者负责感知色彩</li></ul></li><li>我们主要关注感知色彩的锥状细胞，它又能分为分别感知红绿蓝三种颜色的SML三种细胞</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122148.png" alt="image.png"><br>                      <code>1.2.5 锥状细胞感受管线波长图</code></li><li>很明显他们感知的光线光波长度不一样。</li></ul><hr><h2 id="1-2-6-色彩的猜想"><a href="#1-2-6-色彩的猜想" class="headerlink" title="1.2.6 色彩的猜想"></a>1.2.6 色彩的猜想</h2><ul><li><p>人们猜想人的眼睛有数百种感光细胞感受不同颜色</p></li><li><p>人们猜想人有三种细胞分别感受红绿蓝三种颜色</p></li><li><p>人们猜想人分别有感知黑白，红绿，黄蓝这几种细胞</p></li><li><p>后来第二种和第三种分别演变为了两种色彩模型</p></li></ul><hr><h2 id="1-2-7-艺术家们的Munsell色彩系统"><a href="#1-2-7-艺术家们的Munsell色彩系统" class="headerlink" title="1.2.7 艺术家们的Munsell色彩系统"></a>1.2.7 艺术家们的Munsell色彩系统</h2><ul><li>来自于美国艺术家AlbertHenryMunsell</li><li>是通过色卡描述色彩，旋转轴是色相，垂直是亮度，由内到外是饱和度</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022122917.png" alt="image.png"><br>                      <code>1.2.7 Munsell 颜色描述系统</code></li></ul><hr><ul><li>更多是<strong>基于经验而不是物理</strong>，不过这种HSL（色相饱和亮度）的色彩方法仍然被大多数艺术家所接受，至今活跃于各大DCC软件平台中。（如Photoshop）</li></ul><hr><h2 id="1-2-8-科学家们的-RGB-CSS系统"><a href="#1-2-8-科学家们的-RGB-CSS系统" class="headerlink" title="1.2.8 科学家们的 RGB CSS系统"></a>1.2.8 科学家们的 RGB CSS系统</h2><ul><li>即RGB Color Specification System（RGB色彩规格系统）</li><li>来自于CIE在1931年建立的色彩系统，从物理的方式客观描述量化色彩 </li><li>通过三原色打光进行观察对比，对于不同的光得到不同的参数值，最后的的结果如下：</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022133857.png" alt="image.png"><br>                      <code>1.2.8 RGB CSS 描述系统波形图</code></li></ul><hr><ul><li>图中表示方式并不规范，因此科学家又对其进行了归一化操作。这个操作在图形学中很常见，主要是为了更加规范的量化数值，便于表述和调节，这里我们使用将rgb三个量相加并且分别被rgb的量所除去的方式建立这个归一化算式：<ul><li><code>R&#39; = R/RGB,   G&#39;= G/RGB,   B&#39; = B/RGB</code></li></ul></li><li>至此，利用此算式和其变式，我们就可以用其中两个已知数计算另外一个数的值。</li></ul><hr><h2 id="1-2-9-基础的色域概念"><a href="#1-2-9-基础的色域概念" class="headerlink" title="1.2.9 基础的色域概念"></a>1.2.9 基础的色域概念</h2><ul><li>在此基础上，我们将r与g分别作为xy轴，就可以创建一个二维色彩空间，来描述一个颜色r与g部分的组成，前文我们可知，任何一个颜色都是可以由两个参数得出的，因此b就可以通过r与g计算得到。<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022134614.png" alt="image.png"></li></ul></li></ul><hr><ul><li>XYZ色彩空间<ul><li>在上述二维色彩空间或称色域的基础上，为了避免出现负数，科学家又进行了一次迭代，这是用数学的方式做的一次更新，避免了<strong>负数的产生</strong>，但本身目的就是为了<strong>简化计算</strong></li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135023.png" alt="image.png"></li></ul></li></ul><hr><ul><li>转换的方式：<ul><li>XYZ转换使用了矩阵进行转化计算，矩阵相关运算我们在下一节进行，这里只需要知道，矩阵起到了转换空间坐标的作用：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135351.png" alt="image.png"></li></ul></li></ul><hr><ul><li>为了便于计算，人们同样对该矩阵进行了归一化操作：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135429.png" alt="image.png"><br>          <code>XYZ转换矩阵进行归一化操作</code></li></ul><hr><h2 id="1-2-10-色域与Yxy色彩空间"><a href="#1-2-10-色域与Yxy色彩空间" class="headerlink" title="1.2.10 色域与Yxy色彩空间"></a>1.2.10 色域与Yxy色彩空间</h2><ul><li>经过1.2.9的演变最终形成了色域马蹄图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022135719.png" alt="image.png"><br>               <code>色域马蹄图</code></li></ul><hr><ul><li>但这只是一张二维图片，虽然是人眼可见的色域范围，但并没有亮度表示，因此又将Y轴单独拿出来与xy组成了Yxy色彩空间，这个色彩空间中的Y轴是亮度：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140002.png" alt="image.png"><br>                  <code>Yxy色彩空间</code></li></ul><hr><h2 id="1-2-11-色彩空间的定义"><a href="#1-2-11-色彩空间的定义" class="headerlink" title="1.2.11 色彩空间的定义"></a>1.2.11 色彩空间的定义</h2><ul><li>一个色彩空间所具备的基础<ul><li>色域（三个基色坐标，由此形成三角形）</li><li>伽马（对三角形进行切分,一种采样方式）</li><li>白点（色彩中心）</li></ul></li><li>Gamma值<ul><li>简单来说就是色域切分片段的比例，主要分为<ul><li>均匀切割（Gamma &#x3D; 1）便于计算</li><li>非均匀切割（Gamma !&#x3D; 1）</li></ul></li></ul></li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022140752.png" alt="image.png"></li><li>对暗部描述更多，对亮部描述更少。</li></ul><hr><h2 id="1-2-12-sRGB空间"><a href="#1-2-12-sRGB空间" class="headerlink" title="1.2.12 sRGB空间"></a>1.2.12 sRGB空间</h2><ul><li>sRGB空间是一种常用的色彩空间，它的gamma值为2.2，由内而外切线越来越粗</li><li>为何要用gamma？<ul><li>便于储存（远古）</li><li>人对亮部信息感受少对暗部感受多</li></ul></li><li>目前大部分游戏都会使用线性空间。任何色彩空间都可以是线性的linear，但linear本身不是一个色彩空间，它只是一个伽马值。</li></ul><hr><h2 id="1-2-13-颜色的表示以及处理法"><a href="#1-2-13-颜色的表示以及处理法" class="headerlink" title="1.2.13 颜色的表示以及处理法"></a>1.2.13 颜色的表示以及处理法</h2><ul><li>我们来看在计算机中如何表示一个颜色</li><li>颜色通道<ul><li>我们通过八位二进制数来对颜色进行表示，八位二进制数最多能表示255个数值，一共三个通道24位二进制数，总共为1670万种。</li><li>这种格式也被称为R8G8B8格式</li></ul></li><li>颜色深度<ul><li>颜色深度就是二进制数的总位数，如上述这种格式的颜色深度为24位</li></ul></li><li>对于颜色的处理<ul><li>我们可以对颜色进行一些处理，比如对颜色值乘以一个数值，或者对两个颜色值进行加减法运算，这些都是常见的处理方式。但我们限制单个颜色通道的范围为0~255之间。大于或小于这个数值都会被归为最大或最小值。</li></ul></li></ul><hr><h2 id="进阶-1-2-14-色彩空间的转换"><a href="#进阶-1-2-14-色彩空间的转换" class="headerlink" title="进阶 1.2.14 色彩空间的转换"></a>进阶 1.2.14 色彩空间的转换</h2><ul><li>我们已经初步了解了色彩空间的概念，色彩空间有很多，我们可以通过程序方式，对色彩空间进行转换。各位可以运用自己的编程能力，完成一个RGB2HSV的转化运算。欢迎大家给出自己的解决方案！下面是提示：</li></ul><hr><ul><li>RGB2HSV</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141834.png" alt="image.png"></li><li>HSV2RGB<img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022141903.png" alt="image.png"></li><li>作为本章的小作业，我会在文末给出我的源码供大家参考！<br>  小提示：mod为取模运算，即取余数</li></ul><hr><h1 id="1-3-颜色模型"><a href="#1-3-颜色模型" class="headerlink" title="1.3 颜色模型"></a>1.3 颜色模型</h1><h2 id="1-3-1-什么是颜色模型"><a href="#1-3-1-什么是颜色模型" class="headerlink" title="1.3.1 什么是颜色模型"></a>1.3.1 什么是颜色模型</h2><ul><li>前文我们提到了色彩空间，其中简单介绍了两种颜色模型，颜色模型有很多，但它们可以大体上分为两类：加色法模型和减色法模型</li></ul><hr><h2 id="1-3-2-减色法模型（色料）"><a href="#1-3-2-减色法模型（色料）" class="headerlink" title="1.3.2 减色法模型（色料）"></a>1.3.2 减色法模型（色料）</h2><ul><li>减色法模型主要模拟现实中调颜料的过程，打印机的原理就是这样，我们之前讲过，颜色实际上是其材料发射出的颜色，而其余颜色都被吸收了，如果你去调一盘颜料，会发现最后混合在一起就会变为黑色(美术同学应该深有体会)</li></ul><hr><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144121.png" alt="image.png"></li></ul><hr><ul><li>但不管我们用什么颜料去调色也不应该会出现纯黑色，因此这个稍暗的颜色被称为黑色（K）</li><li>而它对应的三原色是品红M青色C和黄色Y因此也被称作CMYK模型。</li></ul><hr><h2 id="1-3-3-加色法模型（色光）"><a href="#1-3-3-加色法模型（色光）" class="headerlink" title="1.3.3 加色法模型（色光）"></a>1.3.3 加色法模型（色光）</h2><ul><li>与前文减色法相对，在计算机以及物理中，我们会用加色来模拟真正的光线，从纯黑一步步添加颜色，最后叠加在一起被称为白色，而构成它的三原色也就是我们熟悉的RGB三种颜色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022144414.png" alt="image.png"></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>介绍了计算机图形学中图形渲染的基本概念，从画布和坐标系的基本定义入手，到光源、色彩及色彩空间的深入解析，再到颜色模型的区分。最终提供了一个基础的RGB转HSV的算法实现</li></ul><hr><h1 id="进阶作业案例"><a href="#进阶作业案例" class="headerlink" title="进阶作业案例"></a>进阶作业案例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HSV</span> &#123;</span><br><span class="line">    <span class="type">float</span> h; <span class="comment">// 色相</span></span><br><span class="line">    <span class="type">float</span> s; <span class="comment">// 饱和度</span></span><br><span class="line">    <span class="type">float</span> v; <span class="comment">// 价值 (亮度)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HSV <span class="title">rgbToHsv</span><span class="params">(<span class="type">const</span> RGB&amp; rgb)</span> </span>&#123;</span><br><span class="line">    HSV hsv;</span><br><span class="line">    <span class="type">float</span> r = rgb.r / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> g = rgb.g / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">float</span> b = rgb.b / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> maxVal = std::<span class="built_in">max</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> minVal = std::<span class="built_in">min</span>(&#123;r, g, b&#125;);</span><br><span class="line">    <span class="type">float</span> delta = maxVal - minVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算亮度</span></span><br><span class="line">    hsv.v = maxVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算饱和度</span></span><br><span class="line">    <span class="keyword">if</span> (maxVal != <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.s = delta / maxVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里如果 maxVal 是 0，说明 RGB 都是 0</span></span><br><span class="line">        hsv.s = <span class="number">0</span>;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 设定为 0</span></span><br><span class="line">        <span class="keyword">return</span> hsv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算色相</span></span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        hsv.h = <span class="number">0</span>; <span class="comment">// 如果没有颜色，则色相为 0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal == r) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * <span class="built_in">fmod</span>((g - b) / delta, <span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == g) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((b - r) / delta + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxVal == b) &#123;</span><br><span class="line">            hsv.h = <span class="number">60</span> * ((r - g) / delta + <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hsv.h &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hsv.h += <span class="number">360</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hsv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RGB rgb;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入 RGB 值 (r, g, b) 范围在 [0, 255] 之间: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; rgb.r &gt;&gt; rgb.g &gt;&gt; rgb.b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> (rgb.r &lt; <span class="number">0</span> || rgb.r &gt; <span class="number">255</span> || rgb.g &lt; <span class="number">0</span> || rgb.g &gt; <span class="number">255</span> || rgb.b &lt; <span class="number">0</span> || rgb.b &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RGB 值必须在 [0, 255] 之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HSV hsv = <span class="built_in">rgbToHsv</span>(rgb);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对应的 HSV 值为: &quot;</span> &lt;&lt; <span class="string">&quot;H: &quot;</span> &lt;&lt; hsv.h &lt;&lt; <span class="string">&quot;, S: &quot;</span> &lt;&lt; hsv.s &lt;&lt; <span class="string">&quot;, V: &quot;</span> &lt;&lt; hsv.v &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>欢迎批评指正！</li></ul><hr><h2 id="参考资料以及链接"><a href="#参考资料以及链接" class="headerlink" title="参考资料以及链接"></a>参考资料以及链接</h2><ul><li>计算机图形学入门——3D渲染指南       GabrielGambetta著 贾凡译</li><li>games101图形学入门——闫令琪 <a href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a></li><li>技术美术百人计划——霜狼may等 <a href="https://learn.u3d.cn/tutorial/technical-artist-may">https://learn.u3d.cn/tutorial/technical-artist-may</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门图形学0——图形学引入</title>
      <link href="/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/"/>
      <url>/2024/10/31/%E5%85%A5%E9%97%A8%E5%9B%BE%E5%BD%A2%E5%AD%A60%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1-图形学能做些什么？"><a href="#0-1-图形学能做些什么？" class="headerlink" title="0.1 图形学能做些什么？"></a>0.1 图形学能做些什么？</h1><ul><li><strong>游戏方面</strong>：<ul><li><p>真实的渲染画面</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Forza%20Horizon%204%20Screenshot%202024.10.11%20-%2017.41.24.95.png" alt="Forza Horizon 4 Screenshot 2024.10.11 - 17.41.24.95.png"><br>                      <code>游戏：极限竞速：地平线四</code></p></li><li><p>风格化的渲染模式</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101238.png" alt="image.png"><br>                      <code>游戏：无主之地3</code></p></li></ul></li></ul><hr><ul><li><strong>特效电影方面</strong>：<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101412.png" alt="image.png"><br>                     <code>电影：黑客帝国</code></li></ul></li><li><strong>动画方面</strong>：<ul><li>真实系动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101636.png" alt="image.png"><br>                      <code>动画电影：疯狂动物城</code></li><li>三渲二风格动画</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022101847.png" alt="image.png"><br>                      <code>动画短片：星穹铁道角色PV——飞霄【君莫笑】</code></li></ul></li></ul><hr><ul><li>设计与效果模拟<ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241022102238.png" alt="image.png"><br>                     <code>地形编辑软件：GeoGen</code></li></ul></li></ul><hr><ul><li>综上所属，实际上图形学本质上是属于人机交互与视觉传达的基础学科，它是<strong>物理与数学</strong>相结合的产物，用于描绘出现实世界的光影变化外貌轮廓。</li></ul><hr><h1 id="0-2-什么是渲染"><a href="#0-2-什么是渲染" class="headerlink" title="0.2 什么是渲染"></a>0.2 什么是渲染</h1><ul><li>渲染是将场景信息通过一系列操作（渲染流程）作为帧或者图像呈现在屏幕上的过程。</li><li>负责渲染帧或图像的部分被称为渲染引擎，渲染引擎如Unity，Ue等将场景的数据通过渲染流程呈现在屏幕上。</li></ul><hr><ul><li>学习图形学需要具备什么？<ul><li>需要具备一颗会<strong>观察生活，追求美好画面</strong>的审美的心</li><li>需要具备一个<strong>严谨分析，善于思考剖析原理</strong>的脑</li></ul></li></ul><hr><h1 id="0-3-究竟学习什么？"><a href="#0-3-究竟学习什么？" class="headerlink" title="0.3 究竟学习什么？"></a>0.3 究竟学习什么？</h1><ul><li>总体而言：学习基础，学习方法，学习思维模式，主要入门的是离线渲染中的光栅化部分</li><li>总体时间段：<ul><li><strong>基础课和入门课结束之后：11月中旬到春节前</strong></li><li>2025年寒假以前（除考试周外）：每周六下午一节</li><li>2025年寒假到春节前一周：每周两到三节</li></ul></li><li>分享形式：每周由部长与副部长轮流交替直播分享，有录屏文件</li><li>课程所需：电脑（不要求配置），Processing，VisualStudio，Photoshop<ul><li>提供课程录播文件（上传部长Bilibili），提供原版教案（上传部长博客网站），提供课程所需素材（包括但不限于代码，资产，软件等）</li></ul></li></ul><h1 id="0-4-具体阶段："><a href="#0-4-具体阶段：" class="headerlink" title="0.4 具体阶段："></a>0.4 具体阶段：</h1><ul><li>1.<strong>基础入门概念</strong>：<ul><li>画布，颜色模型，颜色深度和颜色表示等</li><li>数学：线性代数</li><li>计算机硬件</li><li>课程安排：两到三节课</li></ul></li><li>2.<strong>渲染管线综述</strong>：<ul><li>渲染管线的大致划分</li><li>各个阶段的详解</li><li>课程安排：一到两节课</li></ul></li><li>3.<strong>光栅化阶段1：变换与几何部分</strong><ul><li>聚焦单个片元： </li><li>如何绘制直线，三角形——配合代码编写程序</li><li>如何填充一个三角形？——配合代码编写程序</li><li>三角形的变换与着色</li><li>课程安排：四到五节课</li></ul></li><li><strong>4.光栅化阶段2：着色与处理</strong>  配合DCC软件<ul><li>介绍基础概念如着色模型处理技术等</li><li>介绍材质</li><li>介绍UV贴图等概念</li><li>课程安排：三到四节课</li></ul></li><li>综上，入门图形学课程深入浅出，为各位进行日后的创作与研究奠定理论基础，正所谓千里之行始于足下，我们一起进步！</li></ul><hr><p><strong>深入学习，找到自己感兴趣的方向!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 入门图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——7</title>
      <link href="/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/"/>
      <url>/2024/10/26/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%947/</url>
      
        <content type="html"><![CDATA[<h1 id="法线底层原理"><a href="#法线底层原理" class="headerlink" title="法线底层原理"></a>法线底层原理</h1><ul><li>法线是赋予模型材质凹凸感的工具，其本身实际上是一组组的向量数据，通过光线与这些向量数据做矩阵运算，来得到凹凸效果</li><li>Bump贴图和Normal贴图：<ul><li>两者都可以用于实现法线所能够实现的凹凸效果，但Bump只有单一的凹陷凸起变化，而法线则是可以向四面八方进行变化，因此它们视觉上的颜色也是不一样的</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015153242.png" alt="image.png"></li><li>不同的颜色代表不同的方向，这一点前文我们已经了解过了，其本质是对颜色通道的映射，因为颜色通道RGB本身也可以视作一种向量（颜色向量）</li></ul></li><li>面法线与顶点法线：<ul><li>每个顶点自然都有自己的法线方向，而面法线是通过对一个面片上的顶点法线（通常为3个）进行插值得到的。</li></ul></li></ul><hr><h1 id="法线与光照运算"><a href="#法线与光照运算" class="headerlink" title="法线与光照运算"></a>法线与光照运算</h1><ul><li>在图形学的学习过程中我们了解到，很多光照模型都加入了法线来进行不同着色程度的运算，这里我们可以简单抽象为：<ul><li>若法线方向与光照方向相反则为-1(注意计算中光线方向是由物体指向光源)</li><li>若法线方向与光照方向垂直则为0</li><li>若法线方向与光照方向相同则为1</li></ul></li><li>以上，我们可以简单得出一个拥有明暗交界面的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154216.png" alt="image.png"></li></ul><hr><h2 id="Ue中的实现"><a href="#Ue中的实现" class="headerlink" title="Ue中的实现"></a>Ue中的实现</h2><ul><li>我们通过调取光源方向节点SkyAtomsphereLightDirection，用Dot节将其与VertexNormal节点做点积运算，最后得到一个上述效果的材质：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154449.png" alt="image.png"></li></ul><hr><h1 id="法线贴图的数据原理"><a href="#法线贴图的数据原理" class="headerlink" title="法线贴图的数据原理"></a>法线贴图的数据原理</h1><ul><li><p>法线贴图是在切线空间的，而切线空间中的x，y轴分别为tan与bitan也就是切线与副切线，而与他们垂直的就是法线：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015154804.png" alt="image.png"></p></li><li><p>根据这个原理，我们就可以进行一定的数据运算，来实现法线凸起的效果，因此我们可以分析出一张法线贴图实际上是分别具有三个颜色通道的值，分别代表tan，bitan方向上凸起程度，加在一起便成为了一张法线贴图，因此使用法线时需要使用RGB通道：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015155058.png" alt="image.png"></p></li><li><p>根据上面的原理，我们可以自行验证一下，三个方向是不是具备相互垂直的关系，我们利用dot节点和Append节点来用GB两个通道的值来代替R通道的值：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015160239.png" alt="image.png"></p><ul><li>R点积G得到的是除B通道外的值，因为这两个方向是互相垂直的，点积为0，取反之后得到的就是B通道的值了。不要想复杂哦！</li></ul><h1 id="不同的法线贴图"><a href="#不同的法线贴图" class="headerlink" title="不同的法线贴图"></a>不同的法线贴图</h1></li></ul><hr><ul><li>OpenGL法线与DirectX法线：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015165216.png" alt="image.png"></li><li>他们的最大区别是轴向不同，导致的结果就是代表的方向不同，会导致模型表面突出方向倒置，区别方法就是看符合左手坐标系还是右手坐标系，OpenGl右手DirectX左手，分别对应逆时针和顺时针</li><li>我们可以对其进行简单的取反操作来让轴向改变，由此来转换不同的贴图。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——6</title>
      <link href="/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/"/>
      <url>/2024/10/25/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%946/</url>
      
        <content type="html"><![CDATA[<h1 id="棋盘格"><a href="#棋盘格" class="headerlink" title="棋盘格"></a>棋盘格</h1><ul><li><p>我们来看一个有趣的效果，顺便介绍UE中常用的三角函数节点。</p></li><li><p>上一节我们已经初步认识了三角函数的威力，学习并分析了arctan节点</p></li><li><p>今天，我们从最基本的sine和cosine节点来认识Ue中的三角函数节点以及作用。</p></li><li><p>效果分析：我们需要实现黑白相间的棋盘格，本质上就是黑白的重复，我们可以用PS简单实现一下，供我们分析！</p></li></ul><h2 id="PS中的实现"><a href="#PS中的实现" class="headerlink" title="PS中的实现"></a>PS中的实现</h2><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%A3%8B%E7%9B%98%E6%A0%BC.png" alt="imag.png"></li><li>我们可以观察到，这个图形是由黑色（0）以及白色（1）区域构成的，那么我们需要考虑如何实现这个排序，黑色可以通过乘法得出，我们可以利用Mask节点，将这张图横竖分开，并进行操作，让它变为横竖都是黑白相间的纹理，这就要隆重介绍我们今天的主角——sine节点。</li></ul><h2 id="SIne节点"><a href="#SIne节点" class="headerlink" title="SIne节点"></a>SIne节点</h2><ul><li>SIne节点作为一个三角函数节点，它模拟的就是三角函数的数值，它有一个周期参数，并且拥有三角函数的最大值最小值，它接受一个标量并将其进行三角函数运算，会出现波峰和波谷，波峰为正值而波谷为负值</li><li>在Ue中就会显示为黑白相间的条纹颜色！</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241014094712.png" alt="image.png"></li><li>如上图所示，这样我们就可以利用它来创建网格了！</li></ul><h1 id="网格的实现"><a href="#网格的实现" class="headerlink" title="网格的实现"></a>网格的实现</h1><ul><li><p>网格需要横向和竖向的排列，因此我们需要将原有的纹理坐标节点使用mask节点拆分为R通道与G通道，分别对其进行计算</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150346.png" alt="image.png"></p></li><li><p>随后，为了控制纹理细分数量，我们为两个拆分后的节点分别添加Multipl乘法节点，并且新建一个常量数值接入他们，我们通过控制常量的大小来控制网格的数量，实际上是控制uv的缩放</p></li><li><p>随后我们分别为这两个节点添加SINE节点，这样，我们就可以在SINE节点的预览窗口中观察到条纹状的纹理了</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150409.png" alt="image.png"></p></li><li><p>而后，我们需要考虑如何混合这两个结果，我们需要让黑的部分叠加白的部分，并保留下来，因此我们使用Multipl节点将两个结果值相乘，这样黑色（&lt;0）的部分就会被保留，因为0乘以任何数仍为0，于是我们就得到了一张有些模糊的网格图。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150436.png" alt="image.png"></p></li><li><p>这看起来还有些不对，因为sine得出的有很多非整数结果，它们导致我们的边缘值比较模糊（再次记忆我们的颜色值始终置于0,1之间）</p></li><li><p>因此我们需要将它们取整，我们使用Ceil节点，将其取整，这个函数我们高中就学习过，大于0的值会变为1,1-2则变为2，因此他们会取整为1，这样我们的边缘值就正常了！</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241015150455.png" alt="image.png"></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——5</title>
      <link href="/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/"/>
      <url>/2024/10/22/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%945/</url>
      
        <content type="html"><![CDATA[<h1 id="材质中的渐变"><a href="#材质中的渐变" class="headerlink" title="材质中的渐变"></a>材质中的渐变</h1><ul><li>常用的渐变的分类<ul><li>方形渐变</li><li>中心渐变</li><li>角度渐变</li></ul></li><li>渐变与UV坐标的关系<ul><li>在Ue以及其它三维软件中，UV坐标的直观显示是一个由白到黑的颜色渐变，随着数值变化而渐变，因此这种显示方式决定了，我们可以利用它来进行渐变效果的模拟</li></ul></li></ul><h1 id="方形渐变"><a href="#方形渐变" class="headerlink" title="方形渐变"></a>方形渐变</h1><ul><li><p>方形渐变的拆解：</p><ul><li>方形渐变本质上，通过观察我们可以发现，实际上它就是两个方向渐变的叠加：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png" alt="未标题-1.png"></li><li>实际上我们可以通过从水平方向和竖直方向分别拆解这个渐变，它是由白（1）到黑（0）再到白（1）的过程，那么我们只需要让它的数值变化符合这个规律，并且在最后取其中的最小值即可完成上图效果的实现：</li></ul></li><li><p>详细实现过程（UE）</p></li><li><p>首先，我们需要进行的是第一部，UV坐标的分解和处理，当然，我们同样可以对二维数据同时处理，我们先考虑第二种：</p></li><li><p>创建UV节点（U+左键）并且创建一个Mask掩码节点，用于分离UV常量：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008100813.png" alt="image.png"></p></li><li><p>随后，我们根据拆解的分析，利用subtract节点，将数值范围调整为：-0.5,0,0.5，之后，我们利用绝对值节点ABS将数值取正，调整为0.5,0,0.5,再乘2，即可达成1,0,1的数值变化：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101232.png" alt="image.png"></p></li><li><p>但这时你若直接输出，则会发现它与我们的期待正好相反，我们所需要的是0，1，0，但现在是1,0,1，不用担心，我们只需将其取反，利用取反节点onesubx（1-x）即可将数值变化变为0,1,0：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101422.png" alt="image.png"></p></li><li><p>数值满足了，但此时若直接输出会发现，依然不是我们所需要的效果，这是为何呢？</p></li><li><p>原来实际上我们同时处理UV的代价就是它们是混合进行的，所以若想达到效果，就需要将混合去除，</p></li><li><p>我们同样利用掩码Mask节点，分离UV方向，然后做最后一步，那么就是按我们的需求混合，我们希望保留下黑色部分，黑色部分是0，也就是最小值min，因此我们需要利用最小值节点min，以此来获得最终图像的效果：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008101750.png" alt="image.png"></p></li><li><p>这样我们的方形渐变就大功告成了！</p></li><li><p><strong>一些思考</strong>：</p><ul><li>既然它是一个效果材质，那么我们理应提供调节效果的手段，我们在目前先提供一个控制范围的参数，若想控制渐变的区域，我们可以利用之前学过的Power节点，让整体数值趋于0，这样我们就可以将渐变范围调整了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102405.png" alt="image.png"></li><li>其他的调整方式，也欢迎大家实践！</li></ul></li></ul><h1 id="中心渐变"><a href="#中心渐变" class="headerlink" title="中心渐变"></a>中心渐变</h1><ul><li>下面我们再来看一个类型，中心渐变</li><li>中心渐变的拆解：<ul><li>中心渐变是一个圆形，从中心向外变化，内部为0，最外部为1，常常用来作为相机晕影的效果出现</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008102703.png" alt="image.png"></li><li>实际上，它是一个特殊的方形渐变，它是365°的方向上变化的方形渐变，正如圆本身是一个很多边的多边形一样。因此，我们可以用类似的思考方式去模拟：</li></ul></li><li>详细实现过程（UE）：</li><li>首先，同样我们需要创建一个UV节点，但与上面条件不同的是，我们需要利用另一个节点来完成对全部方向上渐变的计算，我们使用Distance节点，它可以测量输入值与一个接收的数值的距离，我们将其设定为0.5,0.5,也就是正中心的UV坐标，我们就可以的到一个很棒的效果，一个看起来不错的圆形渐变：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103405.png" alt="image.png"></li><li>但仔细观察你会发现，它有些暗，是的，它的变化范围并不是0-1而是0-0.75，这是为什么呢，根据简单的勾股定理计算，实际上斜边并没有到1，因此为了让它的范围正确，我们需要进行一系列调整，首先，利用乘法节点，将其范围增大到1以上，接着在利用subtract节点规范它的范围到0-1之间：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008103621.png" alt="image.png"></li><li>我们可以肉眼直观地看到它的变化，接下来，我们依然要解决它数值相反的问题，所以使用1-x节点，调整它的数值范围，最后得到正确的效果。</li><li>我们可以利用我们得到的效果，制作一个晕影图片！</li><li>导入一张外部贴图，连接到一个新建的乘法节点上，并将1-x节点的输出连到这个乘法节点上：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104047.png" alt="image.png"></li><li><strong>同样的</strong>，我们也可以对其增加一些外部数据调整的节点，让这个材质更加具备一个材质应该有的属性！</li></ul><h1 id="角度渐变"><a href="#角度渐变" class="headerlink" title="角度渐变"></a>角度渐变</h1><ul><li>接下来是一个小难点，角度渐变</li><li>角度渐变的分析拆解：<ul><li>角度渐变实际上是根据角度的变化，渐变的颜色逐渐变化，也就是在一个圆（2π）的变化范围内，数据从0-1变化的过程，本质上与前两个渐变没有区别，难点在于它涉及到了一定的三角函数运算：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008104626.png" alt="image.png"></li><li>不过我们依然可以对其进行分析，只要细心拆解，就不会有无法实现的效果，本篇略长，希望大家耐心学习，争取有所收获</li></ul></li><li>角度渐变的实现(UE):</li><li>首先，万变不离其宗，我们依然创建UV节点，同时分离UV方向，当然你也可以尝试不分离，并思考其中的关系，我们这里使用掩码Mask节点来分离UV：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105251.png" alt="image.png"></li><li>不同的是，我们需要对UV坐标进行数值上的调整，之前的调整方式有些麻烦了，我们可以通过一个高级节点来简化这个过程，但本质依旧还是一样的，只不过是一个上层的封装罢了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008105422.png" alt="image.png"></li><li>这个节点可以接受四个数值，分别是原始的minMax值，和想要转换的max和min值，就可以将其变为对应数值范围的数据，随后，我们将其分别输出到一个关键节点arctan节点，它是我们实现这个效果的关键，从数学角度分析如下图：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008115714.png" alt="image.png"></li><li>因此，我们得到的范围为从-π&#x2F;4到π&#x2F;4，也就是能看到的变化范围为45°,但实际上，ue中颜色变化范围是0-1，而45°还未达到上限，因此实际上我们看见的结果并非45度，而我们可以通过除法变化该图像范围</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241008141113.png" alt="image.png"></li><li>该图实际显示的其实是-π到π，但实际上是0到2π所以如果我们将整个结果同时除以2π，最后我们将得到一个0-1范围的变化，而如果我们除以π，则是-1到0，0到1的变化，这里ue改变了原本数学的值域范围将它变为了-π到π的显示，而实际数值计算中却有所不同</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——4</title>
      <link href="/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/"/>
      <url>/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/</url>
      
        <content type="html"><![CDATA[<h1 id="数据维度的控制"><a href="#数据维度的控制" class="headerlink" title="数据维度的控制"></a>数据维度的控制</h1><ul><li>在UE中，我们可以利用一些节点来进行数据的拆分与提升，例如在UV方向上，我们就可以利用掩码节点Mask来进行通道的拆分，如下图所示，我们将原本的UV节点拆分为R(U)通道以及G(V)通道：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184403.png" alt="image.png"></li><li>同样，我们也可以利用节点将他们合并起来，对于合并输出节点Ue提供了基础的Append节点以及封装多个Append节点从而实现多个输入的MakeFloat系列节点，他们都可以接受两个以上的参数并将他们合并输出：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184606.png" alt="image.png"></li></ul><h1 id="色彩维度的控制"><a href="#色彩维度的控制" class="headerlink" title="色彩维度的控制"></a>色彩维度的控制</h1><ul><li>UE中图片的色彩控制有以下几种：<ul><li>Add节点的加法调节</li><li>Multiply节点的乘法调节</li><li>Power节点的乘方调节</li><li>CheapContrast与CheapContrastRGB的灰度和对比度调节</li><li>以及1-x节点的取反调节<br>  我们逐一进行介绍</li></ul></li></ul><hr><h2 id="ADD节点"><a href="#ADD节点" class="headerlink" title="ADD节点"></a>ADD节点</h2><ul><li>首先是Add节点，这一节点主要功能就是为原图像加上一个常量，因为图像输入的是RGBA通道值，就会为这些值加上一个量，如果大于1，则会为白色，这与我们之前了解的相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001194813.png" alt="image.png"></li></ul><hr><h2 id="Multiply节点"><a href="#Multiply节点" class="headerlink" title="Multiply节点"></a>Multiply节点</h2><ul><li>随后是Multiple节点，这一节点可以在原有通道的基础上，乘上一个常量，如果常量小于1，则会让整体变暗，大于一则变亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203147.png" alt="image.png"></li></ul><hr><h2 id="Power结点"><a href="#Power结点" class="headerlink" title="Power结点"></a>Power结点</h2><ul><li>再之后是Power节点，POW节点是指数节点，可以让原来的值乘以n次方，会让暗的地方更暗，亮的地方更亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203430.png" alt="image.png"></li></ul><hr><h1 id="CheapContrast以及RGB"><a href="#CheapContrast以及RGB" class="headerlink" title="CheapContrast以及RGB"></a>CheapContrast以及RGB</h1><ul><li>这两个节点分别是针对单通道的灰度调节节点以及针对三通道的对比度节点，实际区别就是接受的数据不一样，本身都是调节黑白灰关系的节点，为了让图片对比度更加明显：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203647.png" alt="image.png"></li></ul><hr><h2 id="1-x节点"><a href="#1-x节点" class="headerlink" title="1-x节点"></a>1-x节点</h2><ul><li>这个节点是为了取反操作而诞生的，本质上就是统一进行一个偏移，也就是减去1，这样图片的整体输出就截然相反了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204112.png" alt="image.png"></li></ul><hr><h1 id="一些额外的注意点"><a href="#一些额外的注意点" class="headerlink" title="一些额外的注意点"></a>一些额外的注意点</h1><ul><li>在上文提到POWER节点与CheapContrast节点都能让暗部更暗亮部更亮，而它们之间有什么区别呢？</li><li>答案是，他们的作用区间不一样，前者是在0-1之间，而后者则是以0.5为中间值进行变换，我们实践就会发现，结果就是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204718.png" alt="image.png"></li></ul><hr><h1 id="UV的运算"><a href="#UV的运算" class="headerlink" title="UV的运算"></a>UV的运算</h1><ul><li>UV节点可以控制一个纹理的缩放，本质是调整一个纹理的坐标位置，而模型的UV则与之无关，就好比UV是皮肤而纹理坐标是衣服，UV节点调整的是怎么穿这件衣服。</li><li>UV节点有几个重要参数：<ul><li>U方向偏移量</li><li>V方向偏移量</li><li>解除镜像U</li><li>解除镜像V</li></ul></li></ul><h2 id="U，V方向偏移量"><a href="#U，V方向偏移量" class="headerlink" title="U，V方向偏移量"></a>U，V方向偏移量</h2><ul><li>这两个参数控制的实际上是UV数值的大小，视觉上的效果就是UV相较于模型坐标的缩放大小，比如若增大UV的坐标，那么多出来的部分（因为UV本是0-1）就会平铺填充同样的图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214316.png" alt="image.png"></li><li>我们可以用ADD节点或Multiply节点来控制这个过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214413.png" alt="image.png"></li></ul><h2 id="U-V方向镜像解除"><a href="#U-V方向镜像解除" class="headerlink" title="U,V方向镜像解除"></a>U,V方向镜像解除</h2><ul><li>本质上，我们通过UV节点调节的纹理，是以0.5为中心调节的，若解除这一镜像，我们就会得到从0.5开始的纹理图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214651.png" alt="image.png"></li><li>上面的图像就是画面的下四分之一，也就是上端为0.5，左端为0.5的方式，这可以帮助我们进行一些的运算</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——3</title>
      <link href="/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/"/>
      <url>/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/</url>
      
        <content type="html"><![CDATA[<h1 id="数据是基础"><a href="#数据是基础" class="headerlink" title="数据是基础"></a>数据是基础</h1><ul><li>在Ue中，一切引擎中，一切都是由数据构成的。</li><li>Ue中最上层数据为四通道数据，即RGBA</li><li>数据代表颜色一样可以代表法线方向等等其他含义</li></ul><h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>本质都是向量的运算</li><li>一位数据因为是一个常量因此是可以与任意数据进行乘除法运算的</li></ul><hr><h1 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h1><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><ul><li>在Ue中基础颜色的色彩范围是0-1，它是根据输入值计算的，如果大于1则为1，小于0则为0.</li><li>而自发光颜色是可以无限增加的，直到照亮整个场景（配合虚幻五特有的Luman全局光照系统）</li></ul><hr><h2 id="色彩运算"><a href="#色彩运算" class="headerlink" title="色彩运算"></a>色彩运算</h2><h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><ul><li>前文提到，一切颜色依然是由数据组成的，因此我们同样可以通过向量运算来计算颜色：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090525.png" alt="image.png"></li><li>Ue中的颜色计算使用了与现实世界颜料不同的减色法，即模拟自然光是由白光分出的红绿蓝三色光。</li><li>上图的运算我们可知，白色对应RGB通道值为（1,1,1）,这也对应了前文提到色彩范围是0-1</li><li>除法运算同理</li></ul><hr><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><ul><li>乘法运算是根据向量基础进行的运算，如果将上图中的红色通道与绿色通道相乘，那么结果为0，自然会显示黑色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090932.png" alt="image.png"></li><li>而白色为（1,1,1）,那么它与任何颜色相乘，仍为该颜色</li></ul><hr><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><ul><li>在除法运算之中，如果除数为0，则会保存一个有效值，若全为0 则会不进行这个运算，同样返回原有值，但不建议这样做！任何情况下！</li></ul><hr><h1 id="纹理图像的运算"><a href="#纹理图像的运算" class="headerlink" title="纹理图像的运算"></a>纹理图像的运算</h1><ul><li>纹理图像是一个一个数组，它们同样可以进行加减法运算，因为本质都是向量组成的，这也被称为矩阵。</li></ul><h2 id="图像的加减法运算"><a href="#图像的加减法运算" class="headerlink" title="图像的加减法运算"></a>图像的加减法运算</h2><ul><li>这里我们通过PS来进行观察：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092206.png" alt="image.png"></li><li>这里我们设置了线性减淡添加，这本事就是一种相加算法，它会让图片越来越亮</li><li>反之如果我们使用相减运算，那么就会让图片越来越暗</li></ul><hr><h2 id="图像的乘除法"><a href="#图像的乘除法" class="headerlink" title="图像的乘除法"></a>图像的乘除法</h2><ul><li>在Ps中，乘法被称为正片叠底，因为是乘法，如果黑色部位乘上一个不为黑色的部位，那么就会让图片变暗，并且保留黑色部分。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092704.png" alt="image.png"></li><li>PS中，除法运算的方式叫做划分，它会根据图像的乘除关系，让图片变亮抑或是变暗，取决于除数与被除数的大小关系</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093000.png" alt="image.png"></li></ul><hr><h2 id="偏差比例运算"><a href="#偏差比例运算" class="headerlink" title="偏差比例运算"></a>偏差比例运算</h2><ul><li>这是一种组合运算，先加上一个值再乘上一个值，相当于先进行加法运算，再进行乘法运算</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093835.png" alt="image.png"></li></ul><hr><h2 id="线性插值运算"><a href="#线性插值运算" class="headerlink" title="线性插值运算"></a>线性插值运算</h2><ul><li>本质上是一种混合运算，可以通过调节Alpha输入的值来控制线性插值的结果。我们同样可以通过输入某一个纹理的Alpha值来控制。</li><li>一般Alpha通道值需要一个一维向量为参数，我们可以通过Clamp或saturate节点来限制范围，后者在UnityShader中就很常见，它的系统损耗最低，我们一般倾向于使用它作为限制数值范围的工具，但它的范围只有0-1这一个固定参数范围，而前者clamp可以接受我们自主定义：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930094924.png" alt="image.png"></li><li>混合节点最好使用Saturate节点控制，这样可以减少性能损耗！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——2</title>
      <link href="/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
      <url>/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h1><ul><li>长宽必须是2的幂数，并且上线不超过8192，当然也可以导入不符合该标准的纹理，但这样Ue就无法为我们生成MIPMAP了。</li><li>简单来说，MIPMAP就是为我们生成一系列的图片，让我们在场景中根据距离远近智能调节纹理质量，以此来降低性能开销的一种手段，同样的手段为LOD，只不过后者是只能调节物体面数的，在UE中更为强大的Nanite系统将同时为我们做到以上两点。</li></ul><h1 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h1><ul><li><p>Ue支持很多纹理格式，例如psd，tga等，这两者也是最常用的无损格式之一</p></li><li><p>Ue支持一种叫做3Dtexture的贴图，它可以通过直接在内容窗口中创建得到，下面是它的原理图：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240929200955.png" alt="image.png"></p></li><li><p>一般用于特效制作</p></li><li><p>虚拟纹理：虚拟纹理是Ue所具有的一种动态加载纹理的功能，同样可以减少性能开销，它可以智能加载所需要的贴图，不加载看不见的贴图，从而减少开销。</p></li><li><p>虚幻同样支持由SD导入纹理材质球</p></li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>默认导入状态下，纹理会被压缩为DXTC或BC格式，而B8G8R8A8或G8表示未压缩，HDR格式纹理的FloatRGBA也不会压缩纹理。</li><li>Ue具备一种特有的纹理压缩模式，称为Oodle，是一种高效快捷的纹理编码，它有多层线性级别，通过控制<code>Lambda</code>值来调节压缩级别，一般<code>Lambda</code> &#x3D; 1为最优秀</li><li>详细可以参考Ue官方文档：</li><li><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/">https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/</a></li><li>请注意在移动端中暂时无法使用该选项</li></ul><h1 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h1><ul><li>创建材质实例可以帮助我们快速的调整场景中已有材质物体的材质属性，类似于类的对象这一概念</li><li>我们可以通过将纹理贴图等节点暴露为参数，从而在实例化的材质中自定义调节，它不会影响我们父材质的效果</li><li>SwitchParam节点可以帮助我们设置默认参数与自定义参数，如果打开实例节点中的对应选项就可以调节输入，并且取代我们的默认参数值，关闭则可恢复默认</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——1</title>
      <link href="/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/"/>
      <url>/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="材质编辑器"><a href="#材质编辑器" class="headerlink" title="材质编辑器"></a>材质编辑器</h1><ul><li>材质编辑界面主要由几部分组成，分别是材质图标，节点表，材质属性表，和各类操作面板：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220416.png" alt="image.png"></li><li>类似于Blender的原理化BSDF节点，一开始就会存在的是右侧的输出节点</li><li>我们需要通过连线的方式，将节点连接到对应的输出端口上</li><li>在操作完成后，我们需要进行保存和应用，这些操作全部在上方的材质编辑器的操作面板上完成</li></ul><hr><h1 id="一些常用的材质节点"><a href="#一些常用的材质节点" class="headerlink" title="一些常用的材质节点"></a>一些常用的材质节点</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220757.png" alt="image.png"></li><li>以上是一些常用的基础材质节点，分别是：<ul><li>1+左键： 常量节点，用于输入一个常量</li><li>2+左键： 一个二维向量节点，用于输入一个二维向量</li><li>3+左键：一个三维向量节点，可以看到对应的RGB值，输入一个三维向量</li><li>M+左键：乘法，接受两个常量输入，输出他们相乘的结果</li><li>T+左键：输入一个材质，可以选择一个图像，输出RGB或其他选项</li></ul></li><li>还有更多的节点可以通过右键呼出搜索面板来进行搜索，与blender shift+a类似</li></ul><hr><h1 id="常用的输出端简介"><a href="#常用的输出端简介" class="headerlink" title="常用的输出端简介"></a>常用的输出端简介</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928221546.png" alt="image.png"></li><li>根据我们选择着色模型的不同，也会有对应的不同的输出端口，但常用的基本一致，比如作为颜色信息的基础颜色，控制粗糙度的粗糙度端口。以下是逐项的介绍</li></ul><h2 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h2><ul><li>类似于UnityShader中的Color Tint，是作为基本的输出颜色存在的，决定了材质视觉上的呈现，往往直接可以连接一张Texture</li></ul><h2 id="金属感"><a href="#金属感" class="headerlink" title="金属感"></a>金属感</h2><ul><li>取值为0-1，所有的导电物体都应该具备的属性，可以让视觉上材质呈现出金属质感，类似于哑光质感。</li></ul><h2 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h2><ul><li>取值为0-1，类似于UnityShader中的_Gloss属性，用于控制高光的大小</li></ul><h2 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h2><ul><li>取值为0-1，用于控制物体的粗糙程度，可以接受Texture输入，类似于diffuse与Specular的混合程度，0即为100%Specular，1即为100%diffuse</li></ul><h2 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h2><ul><li>用于控制高光反射的形状，底层逻辑是一张采样的贴图</li></ul><h2 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h2><ul><li>用于控制物体自发光强度，数值越大发光强度越高，在UE中可以照亮周围的物体</li></ul><h2 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h2><ul><li>取值为0-1，用于控制物体可见性的数值，本质依然是不透明度混合的结果，这个数值就是可以对其的范围进行调节。可参考UnityShader中不透明效果的代码实现</li></ul><h2 id="不透明蒙版"><a href="#不透明蒙版" class="headerlink" title="不透明蒙版"></a>不透明蒙版</h2><ul><li>不透明蒙版可以做出类似PS中剪贴蒙版的作用，可以对有A通道的照片素材进行裁切，并且让场景中的面片跟随变化轮廓</li></ul><h2 id="法线与切线"><a href="#法线与切线" class="headerlink" title="法线与切线"></a>法线与切线</h2><ul><li>经常用作制作物体表面凹凸质感，在UnityShader中，可以在切线空间下计算法线贴图也可以在世界空间计算，美术更喜欢前者，因为可以清晰判别模型的各个视觉方向。</li></ul><h2 id="全局位置偏移"><a href="#全局位置偏移" class="headerlink" title="全局位置偏移"></a>全局位置偏移</h2><ul><li>移动模型位置，更多用于动态效果的创建</li></ul><h2 id="次表面颜色"><a href="#次表面颜色" class="headerlink" title="次表面颜色"></a>次表面颜色</h2><ul><li>需要配合次表面着色模型开启，开启后可以实现透光效果</li></ul><h2 id="折射与像素深度偏移"><a href="#折射与像素深度偏移" class="headerlink" title="折射与像素深度偏移"></a>折射与像素深度偏移</h2><ul><li>前者多为玻璃材质所需，后者则是软化模型交界处质感</li></ul><hr><h1 id="渲染模式与着色模型"><a href="#渲染模式与着色模型" class="headerlink" title="渲染模式与着色模型"></a>渲染模式与着色模型</h1><ul><li><p>在UE中一共有六种材质域，数种着色模型：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928223722.png" alt="image.png"></p></li><li><p>许多与Unity共同的特点，只不过有更好的封装进而有更便捷的实现。例如混合模式就是UnityShader中的Blend关键字，可以很容易的进行混合模式的开启，从而渲染半透明等材质</p></li><li><p>同样，着色模型也为我们提供了实现某些渲染效果更轻松的实现，这些都是UE为我们进行的优化。</p></li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>这一节，我们初步认识了UE的材质编辑界面，简单来说，就是利用可视化节点的方式代替code编辑从而便捷的实现效果，但请记住，本身仍然是一个个函数实现，因此结合Shader代码的学习必不可少！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——2</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的语言—二进制"><a href="#计算机的语言—二进制" class="headerlink" title="计算机的语言—二进制"></a>计算机的语言—二进制</h1><ul><li>计算机内部都是由IC（集成电路）组成的，它们只具有两种状态，&#x3D;&#x3D;高电平和低电平&#x3D;&#x3D;，这个特性决定了计算机的数据只能以二进制来处理。</li><li>计算机处理的最小单位：位，就相当于二进制中的一位，也叫做bit。</li><li>八位二进制数被称为一个字节，字节(byte)是基本信息计量单位，是基本单位。</li><li>再用字节处理数据时，&#x3D;&#x3D;如果数字小于存储的字节数&#x3D;&#x3D;，那么高位就用0占位填补。</li><li>&#x3D;&#x3D;二进制数可以表示文字&#x3D;&#x3D;，&#x3D;&#x3D;图像等&#x3D;&#x3D;，其表示的内容取决于程序的编写方式。</li></ul><h1 id="二进制数的计算"><a href="#二进制数的计算" class="headerlink" title="二进制数的计算"></a>二进制数的计算</h1><ul><li>二进制数的本质就是逢二进位，那么它与十进制的转化就是用每一位的数字乘以它的位权。位权的意思就是基数的对应位数指数。  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417094555.png">  指数由第一位开始向左累加。</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>移位运算是指将二进制数值个数为进行左右的移位。&#x3D;&#x3D;移位有左移&#x3D;&#x3D;，&#x3D;&#x3D;右移两种&#x3D;&#x3D;。 <ul><li>运算符：&lt;&lt;被称为左移运算符，&gt;&gt;被称为右移运算符，两者的左侧是被移位值，右侧是要移位的位数。</li><li>左移：左移空出的低位要进行补0操作。<br>  移位可以重来充当乘除法运算，左移两位数值会变为原来的4倍。</li><li>右移：二进制中表示负数值时，&#x3D;&#x3D;会将最高位当作符号位来使用&#x3D;&#x3D;，如果最高位为0则为正数，反之为1则为负数。<br>  这就区分了有符号数和无符号数，有符号数就是有符号位的数</li><li>补数：因为计算机实际上是在做加法运算来进行减法。![[计算机底层结构——1#^3cacdc]]<br>  获得补数的方式就是将全部数位取反再加1，补数与原来的数字之和为0，这很像是相反数。</li></ul></li><li>计算机中，0包含在正数范围内，所以负数要比真正的正数多一个。</li></ul><h2 id="逻辑右移与算术右移"><a href="#逻辑右移与算术右移" class="headerlink" title="逻辑右移与算术右移"></a>逻辑右移与算术右移</h2><ul><li>逻辑右移： 当二进制数的值表示图形模式而非数值时，移位后就需要在最高位前补0</li><li>算术右移：移位后需要在最高位前填充移位前的符号位的值，比如若为0，则需要填充1，反之亦然。</li></ul><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><ul><li>在保持值不变的情况下，将原有的低位数转化为高位数，直接用符号位填充前面的所有位数。</li></ul><h2 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h2><ul><li>逻辑非：1变0,0变1的取反操作</li><li>逻辑与：两者同时为1时，结果为1</li><li>逻辑或：至少一方为1时，结果为1。</li><li>逻辑异或：排斥相同，相同为0不相同为1</li></ul><h1 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h1><ul><li>在使用二进制存储数据时，我们往往会出现大量的数据，而如何简化其表示，以便操作，就是我们要考虑的问题，因此，&#x3D;&#x3D;我们出现了将二进制转化为8进制甚至16进制的操作&#x3D;&#x3D;。</li></ul><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><ul><li>八进制是二进制的简化表示，每位八进制数对应三位二进制数<br>  <code>二进制 001 = 八进制 1  </code>二进制010  &#x3D;  八进制2</li></ul><h2 id="二进制转化为八进制"><a href="#二进制转化为八进制" class="headerlink" title="二进制转化为八进制"></a>二进制转化为八进制</h2><ul><li>将二进制三位一组分开，每三位表示八进制数一位</li><li>如1011101 按三位一组分组 001，011，101(注意，高位是00可以直接省略)</li><li>对应八进制数135</li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><ul><li>16进制数分为0，T，2，3，4，5，6，7，8，9，A，B，C，D，E，F</li><li>每位十六进制数对应四位二进制数</li><li><code>二进制0000 = 十六进制0</code><br>  <code>二进制0001 = 十六进制1</code><br>  <code>二进制1111 = 十六进制F</code></li></ul><h2 id="二进制转化为十六进制"><a href="#二进制转化为十六进制" class="headerlink" title="二进制转化为十六进制"></a>二进制转化为十六进制</h2><ul><li>将二进制数每四位一组进行分割，每组对应一位十六进制数</li><li>如二进制数11011010四位一组为1101,1010<br>  对应十六位数DA</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——1</title>
      <link href="/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/"/>
      <url>/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul><li><p>CPU是集成了&#x3D;&#x3D;控制器，运算器，寄存器，时钟&#x3D;&#x3D;的终端，它负责将我们的&#x3D;&#x3D;汇编语言&#x3D;&#x3D;解释为&#x3D;&#x3D;机器语言&#x3D;&#x3D;，从而供底层微处理器执行。他们通过&#x3D;&#x3D;总线&#x3D;&#x3D;相互连接，传递数据和指令。</p><ul><li><strong>寄存器</strong>：用于&#x3D;&#x3D;暂存指令&#x3D;&#x3D;，&#x3D;&#x3D;等对象&#x3D;&#x3D;。是内存的一种</li><li><strong>控制器</strong>：负责将内存上的指令数据&#x3D;&#x3D;读入寄存器&#x3D;&#x3D;并依据结果&#x3D;&#x3D;控制整个计算机&#x3D;&#x3D;，主要是输入输出时间的控制。</li><li><strong>运算器</strong>：负责运算寄存器中的数据，并把结果输出。</li><li><strong>时钟</strong>：发出CPU开始计时的时钟信号。（&#x3D;&#x3D;信号频率越高，CPU运行越快&#x3D;&#x3D;）</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><strong>内存</strong>指的是计算机的主存储器，负责存储指令和数据。&#x3D;&#x3D;每个字节都有一个地址编号&#x3D;&#x3D;，cpu通过它来读取指令与数据。</li></ul><h1 id="CPU与寄存器"><a href="#CPU与寄存器" class="headerlink" title="CPU与寄存器"></a>CPU与寄存器</h1><ul><li>CPU是寄存器的集合体，程序将寄存器作为对象来描述。</li><li><strong>汇编</strong>：指的是将汇编语言转化为机器语言。</li><li>寄存器种类多样：比如有&#x3D;&#x3D;程序计数器&#x3D;&#x3D;，&#x3D;&#x3D;标志寄存器&#x3D;&#x3D;，累加寄存器，&#x3D;&#x3D;基址寄存器&#x3D;&#x3D;，&#x3D;&#x3D;变址寄存器&#x3D;&#x3D;等。</li></ul><h1 id="寄存器与程序执行"><a href="#寄存器与程序执行" class="headerlink" title="寄存器与程序执行"></a>寄存器与程序执行</h1><ul><li><strong>寄存器</strong>中的<strong>程序计数器</strong>被赋予了分配程序执行顺序的能力。当硬盘中的文件被复制到内存后，程计会被&#x3D;&#x3D;设定为初始值0100&#x3D;&#x3D;，然后开始运行，&#x3D;&#x3D;每当&#x3D;&#x3D;CPU执行完一个指令，程计中的数值都会进行&#x3D;&#x3D;累加&#x3D;&#x3D;操作。CPU会按照程计的数值，从内存中读取命令并执行。</li><li><strong>循环，顺序，条件分支</strong>：这三种执行方式组成了程序的流程。<ul><li><strong>条件分支</strong>：如果在程序执行的过程中，需要有条件分支语句，那么在程计中，遇到这个语句，&#x3D;&#x3D;会将程计的数值设置为对应的地址数值&#x3D;&#x3D;，这个操作被称为&#x3D;&#x3D;jump&#x3D;&#x3D;。</li></ul></li></ul><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417091436.png" alt="Pasted image 20240417091436"></p><ul><li><p><strong>&#x3D;&#x3D;标志&#x3D;&#x3D;寄存器</strong>：标志寄存器主要的作用为将累加寄存器中的结果&#x3D;&#x3D;状态&#x3D;&#x3D;进行记录，比如正负奇偶都会将其进行保存。所以在条件分支前，由其判断是否进行jump。标志寄存器&#x3D;&#x3D;前三个字节分别表示正0负三种状态&#x3D;&#x3D;。</p></li><li><p>标志寄存器的判断，实际上是对数值进行&#x3D;&#x3D;减法&#x3D;&#x3D;运算，通过结果设定状态。 ^3cacdc</p></li><li><p><strong>函数的调用</strong></p><ul><li>函数在调用时，在程计中会存在一个&#x3D;&#x3D;函数调用点&#x3D;&#x3D;。</li><li>call，return指令：call指令在函数入口地址设定到程计前，会把&#x3D;&#x3D;函数调用后&#x3D;&#x3D;要执行的地址存储在栈中。<br>  栈相关：[[内存与数据类型#栈]]<br>  函数处理完后，在通过函数出口来执行&#x3D;&#x3D;return&#x3D;&#x3D;指令，将栈中的地址设定到程计中。</li></ul></li><li><p>基址寄存器与变址寄存器：通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似数组的操作。数组相关：[[数组部分]] </p><ul><li>CPU会将基址寄存器和变址寄存器中的&#x3D;&#x3D;值之和&#x3D;&#x3D;视作实际要去查看的内存地址。变址寄存器相当于&#x3D;&#x3D;数组索引功能！&#x3D;&#x3D;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——0</title>
      <link href="/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/"/>
      <url>/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><ul><li><p>何为计算机？</p><ul><li>计算机是执行输入，计算，输出的机器</li></ul></li><li><p>何为程序？</p><ul><li>程序是指令与数据的集合</li></ul></li><li><p>何为计算机的处理方式？</p><ul><li>计算机的处理方式与人类习惯不同</li></ul></li><li><p>计算机由软硬件共同组成</p></li></ul><h2 id="输入，运算与输出是硬件基础"><a href="#输入，运算与输出是硬件基础" class="headerlink" title="输入，运算与输出是硬件基础"></a>输入，运算与输出是硬件基础</h2><ul><li>计算机硬件由大量IC（集成电路）组成</li><li>IC上有很多引脚，有的用于输入有的用于输出，IC会在内部运算输入的信息，并把结果输出。</li><li>所有的计算机操作都归于输入计算与输出缺一不可</li></ul><h2 id="软件是指令与数据的集合"><a href="#软件是指令与数据的集合" class="headerlink" title="软件是指令与数据的集合"></a>软件是指令与数据的集合</h2><ul><li>所有的操作都是基于一条一条指令</li><li>一组指令可以成为<strong>函数，方法，语句</strong>等等。程序中的数据分为两类，一类作为指令执行对象的输入数据，另一类是输出数据。</li><li>我们将数据称为<strong>变量</strong> 。</li><li>正如数学中的函数概念一样，往往我们都将程序中的方法写作：<br>  <code>y = f(x)</code></li><li>其中x为输入数据，这表示将x输入到函数y中</li><li>在程序中可能是这个样子的：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> answer = a+b+c/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序会通过编译（见1）将我们所写的高级语言代码转换成机器能看懂的机器语言代码。这会是一系列数值，它们既包含指令同样也包含数据。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240914112937.png" alt="image.png"></li></ul><h2 id="对于计算机来说什么都是数字"><a href="#对于计算机来说什么都是数字" class="headerlink" title="对于计算机来说什么都是数字"></a>对于计算机来说什么都是数字</h2><ul><li>计算机将一切都当作数字对待，最基础的可能是单纯的数字加减，但同样也可以是图片，音乐等等。</li></ul><h1 id="计算机组成简介"><a href="#计算机组成简介" class="headerlink" title="计算机组成简介"></a>计算机组成简介</h1><ul><li>计算机主要有CPU，内存和I&#x2F;O组成</li><li>CPU负责对数据运算和控制内存I&#x2F;O</li><li>内存负责存储CPU需要的指令与数据</li><li>I&#x2F;O则负责把键盘鼠标显示器等与主机连接实现数据的输入与输出</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>作为向美术等非专业人员介绍计算机相关内容的第一篇，诚惶诚恐，但愿能解答一些大家的疑惑，帮助大家更好的工作，本文会在后续持续跟进更改！感谢大家</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ul><li>计算机是怎样跑起来的（矢泽久雄）</li><li>程序是怎样跑起来的(矢泽久雄)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
