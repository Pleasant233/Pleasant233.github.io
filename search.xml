<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客搭建感想</title>
      <link href="/2024/10/17/hello-template/"/>
      <url>/2024/10/17/hello-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><ul><li>本地化部署流程</li><li>线上发布流程</li></ul><hr><h2 id="本地化部署"><a href="#本地化部署" class="headerlink" title="本地化部署"></a>本地化部署</h2><ul><li>前期准备<ul><li>首先，本地化部署需要提前安装好两个东西，<br>可参考hexo框架官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>需要下载node.js，同时下载npm，也就是版本管理器，这些可以帮助我们管理博客版本内容。<ul><li>node.js 官网：<a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>你可以直接在官网复制它的代码并且打开本地自带的Windows命令窗口：powershell，粘贴你复制的代码</li><li>等待安装完成就可以了</li></ul></li><li>下载git，git主要作用是建立起云端和本地之间的桥梁，让我们能够从云端拉取数据。<ul><li>同样可以在官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a> </li><li>git安装相对简单，你可以直接全部选择next就自动安装完成了，很无脑！</li></ul></li><li>在安装完成后，本地的环境就基本上搭建完成了。</li></ul></li></ul><h2 id="线上发布："><a href="#线上发布：" class="headerlink" title="线上发布："></a>线上发布：</h2><ul><li>首先访问：<a href="https://github.com/mmdjiji/hexo-template">https://github.com/mmdjiji/hexo-template</a> 获取该库的代码，并且由此新建一个库，<br>详细教程可参考：<a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&vd_source=a506bd54314456e886d3818e488bb1c8">https://www.bilibili.com/video/BV1Bu4y1d7YF/?spm_id_from=333.999.0.0&amp;vd_source=a506bd54314456e886d3818e488bb1c8</a></li><li>断点发生在使用spacecode编辑处，因为该方法是完全基于云端的部署，所以完全依赖虚拟机的网速<br>然而经过多方验证，虚拟机网速堪忧，因此在此我们选择在本地部署！</li></ul><h2 id="独家揭秘！"><a href="#独家揭秘！" class="headerlink" title="独家揭秘！"></a>独家揭秘！</h2><ul><li>本地化部署就是本教程独一无二之处，大部分教程都会将两者割裂，但本教程才是最无脑的过程，<br>前文我们已经提到，云端部署十分缓慢，那有没有办法加快这个速度呢？</li><li>答案当然是有的！我们可以利用githubdesktop更快捷的进行上传与下载，避免云端网速的问题！</li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><ul><li>首先，下载githubdesktop，这个在你的库里local选项就能下载，为了方便起见，本文还是给大家配图</li><li>配图使用PicGo，同样也会给大家介绍，并且介绍obsidian中的PicGo联动小功能！  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-12%20111142.png"></li><li>下载安装完成后，我们就可以将线上的库克隆到本地了，这里各位自行摸索即可，很简单，就不再赘述</li></ul><h3 id="在bush窗口中完成部署"><a href="#在bush窗口中完成部署" class="headerlink" title="在bush窗口中完成部署"></a>在bush窗口中完成部署</h3><ul><li>克隆完成后，我们需要再本地进行编辑，首先，找到克隆库所在本地文件夹，在文件夹中右键</li><li>打开选项栏，选择open git bush here</li><li>然后我们就嫩得到一个这样的窗口，很好，你已经几乎要完成它了！  <img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912111820.png"></li><li>随后，我们需要先安装hexo框架，在对话框中输入：<br>   <code>$ npm install -g hexo-cli </code></li><li>等待安装完成，在这里你可以加速这个过程，可将上述代码替换为：<br>   <code>$ cnpm install -g hexo-cli</code></li><li>这是一个国内镜像，但前提是你需要下载它，你可以通过powershell输入：<br>   <code>npm install -g cnpm --registry=https://registry.npmmirror.com </code><br>   下载完成后，之后的所有需要npm的代码就都可以用cnpm替换了</li><li>之后我们继续键入<code>cnpm install</code>来安装依赖，请确保你进行了上一步！</li><li>在此之后，我们就完成了全部部署，你可以输入<code>hexo g</code>来检测部署结果</li><li>注意！按此方式部署的hexo是局部的，所以需要输入<code>npx+hexo...</code>命令！注意区分</li><li>若如图所示，则说明部署完成：  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240912112800.png"></li><li>请注意，上图中，butterfly字样是主题，若未安装是不会显示的，这无伤大雅。</li></ul><h3 id="配合github上传"><a href="#配合github上传" class="headerlink" title="配合github上传"></a>配合github上传</h3><ul><li>第一阶段我们的githubdesktop就排上用场了，你只需要在面板中点击commit，</li><li>随后点击push origin 上传到云端即可了，返回到github库主页面，点击setting，查看page页面更新消息，你可以按F5刷新页面，不过多久，一个网站就搭建好了，并且你可以在本地完全控制它！</li></ul><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>这是我的第一篇真正的博客，讲解了如何优雅而简便的搭建一个你的博客，接下来我会更新后续的内容，包括技术美术全部相关学习心得，笔记，随笔，图形学系列课程，希望能共同学习交流，那么最后一步！</li><li>push to origin！</li></ul><hr><h1 id="参考链接与项目"><a href="#参考链接与项目" class="headerlink" title="参考链接与项目"></a>参考链接与项目</h1><ul><li>1.hexo官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>2.b站up主：方欲遣兵北逐胡的视频：【基于Hexo搭建本地博客并部署到云服务器教程】 <a href="https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1qU4y1K7Hk/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>3.b站up主：吉吉学长的视频：【【Hexo | 03】创建属于你的追番列表】 <a href="https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&vd_source=18d60239a339ad21d3b3f050742622f4">https://www.bilibili.com/video/BV1Bu4y1d7YF/?share_source=copy_web&amp;vd_source=18d60239a339ad21d3b3f050742622f4</a></li><li>全部为开源项目，不承担任何责任！</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——4</title>
      <link href="/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/"/>
      <url>/2024/10/17/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%944/</url>
      
        <content type="html"><![CDATA[<h1 id="数据维度的控制"><a href="#数据维度的控制" class="headerlink" title="数据维度的控制"></a>数据维度的控制</h1><ul><li>在UE中，我们可以利用一些节点来进行数据的拆分与提升，例如在UV方向上，我们就可以利用掩码节点Mask来进行通道的拆分，如下图所示，我们将原本的UV节点拆分为R(U)通道以及G(V)通道：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184403.png" alt="image.png"></li><li>同样，我们也可以利用节点将他们合并起来，对于合并输出节点Ue提供了基础的Append节点以及封装多个Append节点从而实现多个输入的MakeFloat系列节点，他们都可以接受两个以上的参数并将他们合并输出：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001184606.png" alt="image.png"></li></ul><h1 id="色彩维度的控制"><a href="#色彩维度的控制" class="headerlink" title="色彩维度的控制"></a>色彩维度的控制</h1><ul><li>UE中图片的色彩控制有以下几种：<ul><li>Add节点的加法调节</li><li>Multiply节点的乘法调节</li><li>Power节点的乘方调节</li><li>CheapContrast与CheapContrastRGB的灰度和对比度调节</li><li>以及1-x节点的取反调节<br>  我们逐一进行介绍</li></ul></li></ul><hr><h2 id="ADD节点"><a href="#ADD节点" class="headerlink" title="ADD节点"></a>ADD节点</h2><ul><li>首先是Add节点，这一节点主要功能就是为原图像加上一个常量，因为图像输入的是RGBA通道值，就会为这些值加上一个量，如果大于1，则会为白色，这与我们之前了解的相同</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001194813.png" alt="image.png"></li></ul><hr><h2 id="Multiply节点"><a href="#Multiply节点" class="headerlink" title="Multiply节点"></a>Multiply节点</h2><ul><li>随后是Multiple节点，这一节点可以在原有通道的基础上，乘上一个常量，如果常量小于1，则会让整体变暗，大于一则变亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203147.png" alt="image.png"></li></ul><hr><h2 id="Power结点"><a href="#Power结点" class="headerlink" title="Power结点"></a>Power结点</h2><ul><li>再之后是Power节点，POW节点是指数节点，可以让原来的值乘以n次方，会让暗的地方更暗，亮的地方更亮</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203430.png" alt="image.png"></li></ul><hr><h1 id="CheapContrast以及RGB"><a href="#CheapContrast以及RGB" class="headerlink" title="CheapContrast以及RGB"></a>CheapContrast以及RGB</h1><ul><li>这两个节点分别是针对单通道的灰度调节节点以及针对三通道的对比度节点，实际区别就是接受的数据不一样，本身都是调节黑白灰关系的节点，为了让图片对比度更加明显：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001203647.png" alt="image.png"></li></ul><hr><h2 id="1-x节点"><a href="#1-x节点" class="headerlink" title="1-x节点"></a>1-x节点</h2><ul><li>这个节点是为了取反操作而诞生的，本质上就是统一进行一个偏移，也就是减去1，这样图片的整体输出就截然相反了：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204112.png" alt="image.png"></li></ul><hr><h1 id="一些额外的注意点"><a href="#一些额外的注意点" class="headerlink" title="一些额外的注意点"></a>一些额外的注意点</h1><ul><li>在上文提到POWER节点与CheapContrast节点都能让暗部更暗亮部更亮，而它们之间有什么区别呢？</li><li>答案是，他们的作用区间不一样，前者是在0-1之间，而后者则是以0.5为中间值进行变换，我们实践就会发现，结果就是：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001204718.png" alt="image.png"></li></ul><hr><h1 id="UV的运算"><a href="#UV的运算" class="headerlink" title="UV的运算"></a>UV的运算</h1><ul><li>UV节点可以控制一个纹理的缩放，本质是调整一个纹理的坐标位置，而模型的UV则与之无关，就好比UV是皮肤而纹理坐标是衣服，UV节点调整的是怎么穿这件衣服。</li><li>UV节点有几个重要参数：<ul><li>U方向偏移量</li><li>V方向偏移量</li><li>解除镜像U</li><li>解除镜像V</li></ul></li></ul><h2 id="U，V方向偏移量"><a href="#U，V方向偏移量" class="headerlink" title="U，V方向偏移量"></a>U，V方向偏移量</h2><ul><li>这两个参数控制的实际上是UV数值的大小，视觉上的效果就是UV相较于模型坐标的缩放大小，比如若增大UV的坐标，那么多出来的部分（因为UV本是0-1）就会平铺填充同样的图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214316.png" alt="image.png"></li><li>我们可以用ADD节点或Multiply节点来控制这个过程：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214413.png" alt="image.png"></li></ul><h2 id="U-V方向镜像解除"><a href="#U-V方向镜像解除" class="headerlink" title="U,V方向镜像解除"></a>U,V方向镜像解除</h2><ul><li>本质上，我们通过UV节点调节的纹理，是以0.5为中心调节的，若解除这一镜像，我们就会得到从0.5开始的纹理图像：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20241001214651.png" alt="image.png"></li><li>上面的图像就是画面的下四分之一，也就是上端为0.5，左端为0.5的方式，这可以帮助我们进行一些的运算</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——3</title>
      <link href="/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/"/>
      <url>/2024/10/16/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%943/</url>
      
        <content type="html"><![CDATA[<h1 id="数据是基础"><a href="#数据是基础" class="headerlink" title="数据是基础"></a>数据是基础</h1><ul><li>在Ue中，一切引擎中，一切都是由数据构成的。</li><li>Ue中最上层数据为四通道数据，即RGBA</li><li>数据代表颜色一样可以代表法线方向等等其他含义</li></ul><h1 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h1><ul><li>本质都是向量的运算</li><li>一位数据因为是一个常量因此是可以与任意数据进行乘除法运算的</li></ul><hr><h1 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h1><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><ul><li>在Ue中基础颜色的色彩范围是0-1，它是根据输入值计算的，如果大于1则为1，小于0则为0.</li><li>而自发光颜色是可以无限增加的，直到照亮整个场景（配合虚幻五特有的Luman全局光照系统）</li></ul><hr><h2 id="色彩运算"><a href="#色彩运算" class="headerlink" title="色彩运算"></a>色彩运算</h2><h2 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h2><ul><li>前文提到，一切颜色依然是由数据组成的，因此我们同样可以通过向量运算来计算颜色：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090525.png" alt="image.png"></li><li>Ue中的颜色计算使用了与现实世界颜料不同的减色法，即模拟自然光是由白光分出的红绿蓝三色光。</li><li>上图的运算我们可知，白色对应RGB通道值为（1,1,1）,这也对应了前文提到色彩范围是0-1</li><li>除法运算同理</li></ul><hr><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><ul><li>乘法运算是根据向量基础进行的运算，如果将上图中的红色通道与绿色通道相乘，那么结果为0，自然会显示黑色</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930090932.png" alt="image.png"></li><li>而白色为（1,1,1）,那么它与任何颜色相乘，仍为该颜色</li></ul><hr><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><ul><li>在除法运算之中，如果除数为0，则会保存一个有效值，若全为0 则会不进行这个运算，同样返回原有值，但不建议这样做！任何情况下！</li></ul><hr><h1 id="纹理图像的运算"><a href="#纹理图像的运算" class="headerlink" title="纹理图像的运算"></a>纹理图像的运算</h1><ul><li>纹理图像是一个一个数组，它们同样可以进行加减法运算，因为本质都是向量组成的，这也被称为矩阵。</li></ul><h2 id="图像的加减法运算"><a href="#图像的加减法运算" class="headerlink" title="图像的加减法运算"></a>图像的加减法运算</h2><ul><li>这里我们通过PS来进行观察：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092206.png" alt="image.png"></li><li>这里我们设置了线性减淡添加，这本事就是一种相加算法，它会让图片越来越亮</li><li>反之如果我们使用相减运算，那么就会让图片越来越暗</li></ul><hr><h2 id="图像的乘除法"><a href="#图像的乘除法" class="headerlink" title="图像的乘除法"></a>图像的乘除法</h2><ul><li>在Ps中，乘法被称为正片叠底，因为是乘法，如果黑色部位乘上一个不为黑色的部位，那么就会让图片变暗，并且保留黑色部分。</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930092704.png" alt="image.png"></li><li>PS中，除法运算的方式叫做划分，它会根据图像的乘除关系，让图片变亮抑或是变暗，取决于除数与被除数的大小关系</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093000.png" alt="image.png"></li></ul><hr><h2 id="偏差比例运算"><a href="#偏差比例运算" class="headerlink" title="偏差比例运算"></a>偏差比例运算</h2><ul><li>这是一种组合运算，先加上一个值再乘上一个值，相当于先进行加法运算，再进行乘法运算</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930093835.png" alt="image.png"></li></ul><hr><h2 id="线性插值运算"><a href="#线性插值运算" class="headerlink" title="线性插值运算"></a>线性插值运算</h2><ul><li>本质上是一种混合运算，可以通过调节Alpha输入的值来控制线性插值的结果。我们同样可以通过输入某一个纹理的Alpha值来控制。</li><li>一般Alpha通道值需要一个一维向量为参数，我们可以通过Clamp或saturate节点来限制范围，后者在UnityShader中就很常见，它的系统损耗最低，我们一般倾向于使用它作为限制数值范围的工具，但它的范围只有0-1这一个固定参数范围，而前者clamp可以接受我们自主定义：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240930094924.png" alt="image.png"></li><li>混合节点最好使用Saturate节点控制，这样可以减少性能损耗！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——2</title>
      <link href="/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/"/>
      <url>/2024/10/15/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h1><ul><li>长宽必须是2的幂数，并且上线不超过8192，当然也可以导入不符合该标准的纹理，但这样Ue就无法为我们生成MIPMAP了。</li><li>简单来说，MIPMAP就是为我们生成一系列的图片，让我们在场景中根据距离远近智能调节纹理质量，以此来降低性能开销的一种手段，同样的手段为LOD，只不过后者是只能调节物体面数的，在UE中更为强大的Nanite系统将同时为我们做到以上两点。</li></ul><h1 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h1><ul><li><p>Ue支持很多纹理格式，例如psd，tga等，这两者也是最常用的无损格式之一</p></li><li><p>Ue支持一种叫做3Dtexture的贴图，它可以通过直接在内容窗口中创建得到，下面是它的原理图：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240929200955.png" alt="image.png"></p></li><li><p>一般用于特效制作</p></li><li><p>虚拟纹理：虚拟纹理是Ue所具有的一种动态加载纹理的功能，同样可以减少性能开销，它可以智能加载所需要的贴图，不加载看不见的贴图，从而减少开销。</p></li><li><p>虚幻同样支持由SD导入纹理材质球</p></li></ul><h1 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h1><ul><li>默认导入状态下，纹理会被压缩为DXTC或BC格式，而B8G8R8A8或G8表示未压缩，HDR格式纹理的FloatRGBA也不会压缩纹理。</li><li>Ue具备一种特有的纹理压缩模式，称为Oodle，是一种高效快捷的纹理编码，它有多层线性级别，通过控制<code>Lambda</code>值来调节压缩级别，一般<code>Lambda</code> &#x3D; 1为最优秀</li><li>详细可以参考Ue官方文档：</li><li><a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/">https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/Oodle/Texture/</a></li><li>请注意在移动端中暂时无法使用该选项</li></ul><h1 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h1><ul><li>创建材质实例可以帮助我们快速的调整场景中已有材质物体的材质属性，类似于类的对象这一概念</li><li>我们可以通过将纹理贴图等节点暴露为参数，从而在实例化的材质中自定义调节，它不会影响我们父材质的效果</li><li>SwitchParam节点可以帮助我们设置默认参数与自定义参数，如果打开实例节点中的对应选项就可以调节输入，并且取代我们的默认参数值，关闭则可恢复默认</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ue材质入门——1</title>
      <link href="/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/"/>
      <url>/2024/10/14/Ue%E6%9D%90%E8%B4%A8%E5%85%A5%E9%97%A8%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="材质编辑器"><a href="#材质编辑器" class="headerlink" title="材质编辑器"></a>材质编辑器</h1><ul><li>材质编辑界面主要由几部分组成，分别是材质图标，节点表，材质属性表，和各类操作面板：</li><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220416.png" alt="image.png"></li><li>类似于Blender的原理化BSDF节点，一开始就会存在的是右侧的输出节点</li><li>我们需要通过连线的方式，将节点连接到对应的输出端口上</li><li>在操作完成后，我们需要进行保存和应用，这些操作全部在上方的材质编辑器的操作面板上完成</li></ul><hr><h1 id="一些常用的材质节点"><a href="#一些常用的材质节点" class="headerlink" title="一些常用的材质节点"></a>一些常用的材质节点</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928220757.png" alt="image.png"></li><li>以上是一些常用的基础材质节点，分别是：<ul><li>1+左键： 常量节点，用于输入一个常量</li><li>2+左键： 一个二维向量节点，用于输入一个二维向量</li><li>3+左键：一个三维向量节点，可以看到对应的RGB值，输入一个三维向量</li><li>M+左键：乘法，接受两个常量输入，输出他们相乘的结果</li><li>T+左键：输入一个材质，可以选择一个图像，输出RGB或其他选项</li></ul></li><li>还有更多的节点可以通过右键呼出搜索面板来进行搜索，与blender shift+a类似</li></ul><hr><h1 id="常用的输出端简介"><a href="#常用的输出端简介" class="headerlink" title="常用的输出端简介"></a>常用的输出端简介</h1><ul><li><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928221546.png" alt="image.png"></li><li>根据我们选择着色模型的不同，也会有对应的不同的输出端口，但常用的基本一致，比如作为颜色信息的基础颜色，控制粗糙度的粗糙度端口。以下是逐项的介绍</li></ul><h2 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h2><ul><li>类似于UnityShader中的Color Tint，是作为基本的输出颜色存在的，决定了材质视觉上的呈现，往往直接可以连接一张Texture</li></ul><h2 id="金属感"><a href="#金属感" class="headerlink" title="金属感"></a>金属感</h2><ul><li>取值为0-1，所有的导电物体都应该具备的属性，可以让视觉上材质呈现出金属质感，类似于哑光质感。</li></ul><h2 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h2><ul><li>取值为0-1，类似于UnityShader中的_Gloss属性，用于控制高光的大小</li></ul><h2 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h2><ul><li>取值为0-1，用于控制物体的粗糙程度，可以接受Texture输入，类似于diffuse与Specular的混合程度，0即为100%Specular，1即为100%diffuse</li></ul><h2 id="各向异性"><a href="#各向异性" class="headerlink" title="各向异性"></a>各向异性</h2><ul><li>用于控制高光反射的形状，底层逻辑是一张采样的贴图</li></ul><h2 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h2><ul><li>用于控制物体自发光强度，数值越大发光强度越高，在UE中可以照亮周围的物体</li></ul><h2 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h2><ul><li>取值为0-1，用于控制物体可见性的数值，本质依然是不透明度混合的结果，这个数值就是可以对其的范围进行调节。可参考UnityShader中不透明效果的代码实现</li></ul><h2 id="不透明蒙版"><a href="#不透明蒙版" class="headerlink" title="不透明蒙版"></a>不透明蒙版</h2><ul><li>不透明蒙版可以做出类似PS中剪贴蒙版的作用，可以对有A通道的照片素材进行裁切，并且让场景中的面片跟随变化轮廓</li></ul><h2 id="法线与切线"><a href="#法线与切线" class="headerlink" title="法线与切线"></a>法线与切线</h2><ul><li>经常用作制作物体表面凹凸质感，在UnityShader中，可以在切线空间下计算法线贴图也可以在世界空间计算，美术更喜欢前者，因为可以清晰判别模型的各个视觉方向。</li></ul><h2 id="全局位置偏移"><a href="#全局位置偏移" class="headerlink" title="全局位置偏移"></a>全局位置偏移</h2><ul><li>移动模型位置，更多用于动态效果的创建</li></ul><h2 id="次表面颜色"><a href="#次表面颜色" class="headerlink" title="次表面颜色"></a>次表面颜色</h2><ul><li>需要配合次表面着色模型开启，开启后可以实现透光效果</li></ul><h2 id="折射与像素深度偏移"><a href="#折射与像素深度偏移" class="headerlink" title="折射与像素深度偏移"></a>折射与像素深度偏移</h2><ul><li>前者多为玻璃材质所需，后者则是软化模型交界处质感</li></ul><hr><h1 id="渲染模式与着色模型"><a href="#渲染模式与着色模型" class="headerlink" title="渲染模式与着色模型"></a>渲染模式与着色模型</h1><ul><li><p>在UE中一共有六种材质域，数种着色模型：</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240928223722.png" alt="image.png"></p></li><li><p>许多与Unity共同的特点，只不过有更好的封装进而有更便捷的实现。例如混合模式就是UnityShader中的Blend关键字，可以很容易的进行混合模式的开启，从而渲染半透明等材质</p></li><li><p>同样，着色模型也为我们提供了实现某些渲染效果更轻松的实现，这些都是UE为我们进行的优化。</p></li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>这一节，我们初步认识了UE的材质编辑界面，简单来说，就是利用可视化节点的方式代替code编辑从而便捷的实现效果，但请记住，本身仍然是一个个函数实现，因此结合Shader代码的学习必不可少！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ue材质入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——2</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%942/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的语言—二进制"><a href="#计算机的语言—二进制" class="headerlink" title="计算机的语言—二进制"></a>计算机的语言—二进制</h1><ul><li>计算机内部都是由IC（集成电路）组成的，它们只具有两种状态，&#x3D;&#x3D;高电平和低电平&#x3D;&#x3D;，这个特性决定了计算机的数据只能以二进制来处理。</li><li>计算机处理的最小单位：位，就相当于二进制中的一位，也叫做bit。</li><li>八位二进制数被称为一个字节，字节(byte)是基本信息计量单位，是基本单位。</li><li>再用字节处理数据时，&#x3D;&#x3D;如果数字小于存储的字节数&#x3D;&#x3D;，那么高位就用0占位填补。</li><li>&#x3D;&#x3D;二进制数可以表示文字&#x3D;&#x3D;，&#x3D;&#x3D;图像等&#x3D;&#x3D;，其表示的内容取决于程序的编写方式。</li></ul><h1 id="二进制数的计算"><a href="#二进制数的计算" class="headerlink" title="二进制数的计算"></a>二进制数的计算</h1><ul><li>二进制数的本质就是逢二进位，那么它与十进制的转化就是用每一位的数字乘以它的位权。位权的意思就是基数的对应位数指数。  <img src ="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417094555.png">  指数由第一位开始向左累加。</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>移位运算是指将二进制数值个数为进行左右的移位。&#x3D;&#x3D;移位有左移&#x3D;&#x3D;，&#x3D;&#x3D;右移两种&#x3D;&#x3D;。 <ul><li>运算符：&lt;&lt;被称为左移运算符，&gt;&gt;被称为右移运算符，两者的左侧是被移位值，右侧是要移位的位数。</li><li>左移：左移空出的低位要进行补0操作。<br>  移位可以重来充当乘除法运算，左移两位数值会变为原来的4倍。</li><li>右移：二进制中表示负数值时，&#x3D;&#x3D;会将最高位当作符号位来使用&#x3D;&#x3D;，如果最高位为0则为正数，反之为1则为负数。<br>  这就区分了有符号数和无符号数，有符号数就是有符号位的数</li><li>补数：因为计算机实际上是在做加法运算来进行减法。![[计算机底层结构——1#^3cacdc]]<br>  获得补数的方式就是将全部数位取反再加1，补数与原来的数字之和为0，这很像是相反数。</li></ul></li><li>计算机中，0包含在正数范围内，所以负数要比真正的正数多一个。</li></ul><h2 id="逻辑右移与算术右移"><a href="#逻辑右移与算术右移" class="headerlink" title="逻辑右移与算术右移"></a>逻辑右移与算术右移</h2><ul><li>逻辑右移： 当二进制数的值表示图形模式而非数值时，移位后就需要在最高位前补0</li><li>算术右移：移位后需要在最高位前填充移位前的符号位的值，比如若为0，则需要填充1，反之亦然。</li></ul><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><ul><li>在保持值不变的情况下，将原有的低位数转化为高位数，直接用符号位填充前面的所有位数。</li></ul><h2 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h2><ul><li>逻辑非：1变0,0变1的取反操作</li><li>逻辑与：两者同时为1时，结果为1</li><li>逻辑或：至少一方为1时，结果为1。</li><li>逻辑异或：排斥相同，相同为0不相同为1</li></ul><h1 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h1><ul><li>在使用二进制存储数据时，我们往往会出现大量的数据，而如何简化其表示，以便操作，就是我们要考虑的问题，因此，&#x3D;&#x3D;我们出现了将二进制转化为8进制甚至16进制的操作&#x3D;&#x3D;。</li></ul><h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><ul><li>八进制是二进制的简化表示，每位八进制数对应三位二进制数<br>  <code>二进制 001 = 八进制 1  </code>二进制010  &#x3D;  八进制2</li></ul><h2 id="二进制转化为八进制"><a href="#二进制转化为八进制" class="headerlink" title="二进制转化为八进制"></a>二进制转化为八进制</h2><ul><li>将二进制三位一组分开，每三位表示八进制数一位</li><li>如1011101 按三位一组分组 001，011，101(注意，高位是00可以直接省略)</li><li>对应八进制数135</li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><ul><li>16进制数分为0，T，2，3，4，5，6，7，8，9，A，B，C，D，E，F</li><li>每位十六进制数对应四位二进制数</li><li><code>二进制0000 = 十六进制0</code><br>  <code>二进制0001 = 十六进制1</code><br>  <code>二进制1111 = 十六进制F</code></li></ul><h2 id="二进制转化为十六进制"><a href="#二进制转化为十六进制" class="headerlink" title="二进制转化为十六进制"></a>二进制转化为十六进制</h2><ul><li>将二进制数每四位一组进行分割，每组对应一位十六进制数</li><li>如二进制数11011010四位一组为1101,1010<br>  对应十六位数DA</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——1</title>
      <link href="/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/"/>
      <url>/2024/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%941/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul><li><p>CPU是集成了&#x3D;&#x3D;控制器，运算器，寄存器，时钟&#x3D;&#x3D;的终端，它负责将我们的&#x3D;&#x3D;汇编语言&#x3D;&#x3D;解释为&#x3D;&#x3D;机器语言&#x3D;&#x3D;，从而供底层微处理器执行。他们通过&#x3D;&#x3D;总线&#x3D;&#x3D;相互连接，传递数据和指令。</p><ul><li><strong>寄存器</strong>：用于&#x3D;&#x3D;暂存指令&#x3D;&#x3D;，&#x3D;&#x3D;等对象&#x3D;&#x3D;。是内存的一种</li><li><strong>控制器</strong>：负责将内存上的指令数据&#x3D;&#x3D;读入寄存器&#x3D;&#x3D;并依据结果&#x3D;&#x3D;控制整个计算机&#x3D;&#x3D;，主要是输入输出时间的控制。</li><li><strong>运算器</strong>：负责运算寄存器中的数据，并把结果输出。</li><li><strong>时钟</strong>：发出CPU开始计时的时钟信号。（&#x3D;&#x3D;信号频率越高，CPU运行越快&#x3D;&#x3D;）</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><strong>内存</strong>指的是计算机的主存储器，负责存储指令和数据。&#x3D;&#x3D;每个字节都有一个地址编号&#x3D;&#x3D;，cpu通过它来读取指令与数据。</li></ul><h1 id="CPU与寄存器"><a href="#CPU与寄存器" class="headerlink" title="CPU与寄存器"></a>CPU与寄存器</h1><ul><li>CPU是寄存器的集合体，程序将寄存器作为对象来描述。</li><li><strong>汇编</strong>：指的是将汇编语言转化为机器语言。</li><li>寄存器种类多样：比如有&#x3D;&#x3D;程序计数器&#x3D;&#x3D;，&#x3D;&#x3D;标志寄存器&#x3D;&#x3D;，累加寄存器，&#x3D;&#x3D;基址寄存器&#x3D;&#x3D;，&#x3D;&#x3D;变址寄存器&#x3D;&#x3D;等。</li></ul><h1 id="寄存器与程序执行"><a href="#寄存器与程序执行" class="headerlink" title="寄存器与程序执行"></a>寄存器与程序执行</h1><ul><li><strong>寄存器</strong>中的<strong>程序计数器</strong>被赋予了分配程序执行顺序的能力。当硬盘中的文件被复制到内存后，程计会被&#x3D;&#x3D;设定为初始值0100&#x3D;&#x3D;，然后开始运行，&#x3D;&#x3D;每当&#x3D;&#x3D;CPU执行完一个指令，程计中的数值都会进行&#x3D;&#x3D;累加&#x3D;&#x3D;操作。CPU会按照程计的数值，从内存中读取命令并执行。</li><li><strong>循环，顺序，条件分支</strong>：这三种执行方式组成了程序的流程。<ul><li><strong>条件分支</strong>：如果在程序执行的过程中，需要有条件分支语句，那么在程计中，遇到这个语句，&#x3D;&#x3D;会将程计的数值设置为对应的地址数值&#x3D;&#x3D;，这个操作被称为&#x3D;&#x3D;jump&#x3D;&#x3D;。</li></ul></li></ul><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020240417091436.png" alt="Pasted image 20240417091436"></p><ul><li><p><strong>&#x3D;&#x3D;标志&#x3D;&#x3D;寄存器</strong>：标志寄存器主要的作用为将累加寄存器中的结果&#x3D;&#x3D;状态&#x3D;&#x3D;进行记录，比如正负奇偶都会将其进行保存。所以在条件分支前，由其判断是否进行jump。标志寄存器&#x3D;&#x3D;前三个字节分别表示正0负三种状态&#x3D;&#x3D;。</p></li><li><p>标志寄存器的判断，实际上是对数值进行&#x3D;&#x3D;减法&#x3D;&#x3D;运算，通过结果设定状态。 ^3cacdc</p></li><li><p><strong>函数的调用</strong></p><ul><li>函数在调用时，在程计中会存在一个&#x3D;&#x3D;函数调用点&#x3D;&#x3D;。</li><li>call，return指令：call指令在函数入口地址设定到程计前，会把&#x3D;&#x3D;函数调用后&#x3D;&#x3D;要执行的地址存储在栈中。<br>  栈相关：[[内存与数据类型#栈]]<br>  函数处理完后，在通过函数出口来执行&#x3D;&#x3D;return&#x3D;&#x3D;指令，将栈中的地址设定到程计中。</li></ul></li><li><p>基址寄存器与变址寄存器：通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似数组的操作。数组相关：[[数组部分]] </p><ul><li>CPU会将基址寄存器和变址寄存器中的&#x3D;&#x3D;值之和&#x3D;&#x3D;视作实际要去查看的内存地址。变址寄存器相当于&#x3D;&#x3D;数组索引功能！&#x3D;&#x3D;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机底层结构——0</title>
      <link href="/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/"/>
      <url>/2024/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E2%80%94%E2%80%940/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><ul><li><p>何为计算机？</p><ul><li>计算机是执行输入，计算，输出的机器</li></ul></li><li><p>何为程序？</p><ul><li>程序是指令与数据的集合</li></ul></li><li><p>何为计算机的处理方式？</p><ul><li>计算机的处理方式与人类习惯不同</li></ul></li><li><p>计算机由软硬件共同组成</p></li></ul><h2 id="输入，运算与输出是硬件基础"><a href="#输入，运算与输出是硬件基础" class="headerlink" title="输入，运算与输出是硬件基础"></a>输入，运算与输出是硬件基础</h2><ul><li>计算机硬件由大量IC（集成电路）组成</li><li>IC上有很多引脚，有的用于输入有的用于输出，IC会在内部运算输入的信息，并把结果输出。</li><li>所有的计算机操作都归于输入计算与输出缺一不可</li></ul><h2 id="软件是指令与数据的集合"><a href="#软件是指令与数据的集合" class="headerlink" title="软件是指令与数据的集合"></a>软件是指令与数据的集合</h2><ul><li><p>所有的操作都是基于一条一条指令</p></li><li><p>一组指令可以成为<strong>函数，方法，语句</strong>等等。程序中的数据分为两类，一类作为指令执行对象的输入数据，另一类是输出数据。</p></li><li><p>我们将数据称为<strong>变量</strong> 。</p></li><li><p>正如数学中的函数概念一样，往往我们都将程序中的方法写作：<br>  <code>y = f(x)</code></p></li><li><p>其中x为输入数据，这表示将x输入到函数y中</p></li><li><p>在程序中可能是这个样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b =<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c =<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> answer = a+b+c/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序会通过编译（见1）将我们所写的高级语言代码转换成机器能看懂的机器语言代码。这会是一系列数值，它们既包含指令同样也包含数据。</p></li><li><p><img src="https://pleasant233.oss-cn-beijing.aliyuncs.com/20240914112937.png" alt="image.png"></p></li></ul><h2 id="对于计算机来说什么都是数字"><a href="#对于计算机来说什么都是数字" class="headerlink" title="对于计算机来说什么都是数字"></a>对于计算机来说什么都是数字</h2><ul><li>计算机将一切都当作数字对待，最基础的可能是单纯的数字加减，但同样也可以是图片，音乐等等。</li></ul><h1 id="计算机组成简介"><a href="#计算机组成简介" class="headerlink" title="计算机组成简介"></a>计算机组成简介</h1><ul><li>计算机主要有CPU，内存和I&#x2F;O组成</li><li>CPU负责对数据运算和控制内存I&#x2F;O</li><li>内存负责存储CPU需要的指令与数据</li><li>I&#x2F;O则负责把键盘鼠标显示器等与主机连接实现数据的输入与输出</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>作为向美术等非专业人员介绍计算机相关内容的第一篇，诚惶诚恐，但愿能解答一些大家的疑惑，帮助大家更好的工作，本文会在后续持续跟进更改！感谢大家</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ul><li>计算机是怎样跑起来的（矢泽久雄）</li><li>程序是怎样跑起来的(矢泽久雄)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
